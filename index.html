<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freefe.cc","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:type" content="website">
<meta property="og:title" content="NiYingfeng 的博客">
<meta property="og:url" content="http://freefe.cc/index.html">
<meta property="og:site_name" content="NiYingfeng 的博客">
<meta property="og:description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="倪颖峰">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://freefe.cc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>NiYingfeng 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">NiYingfeng 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、生活与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2021/04/01/cognitive-trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/cognitive-trap/" class="post-title-link" itemprop="url">《认知陷阱》 - 如何理性和科学的去生活</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-02T00:00:00+08:00">2021-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 22:45:02" itemprop="dateModified" datetime="2022-03-10T22:45:02+08:00">2022-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-08-031.png"></p>
<p>《认知陷阱》全书都旨在帮助我们分析理解一个问题：为什么如今高度文明的人类社会，依旧还有那么多毫无科学依据、不理性的医疗和健康观点？</p>
<p>本书是需要我们颇费一定精力去阅读的书，它抛开传统的科普方式，从行为背后的心理学、社会学以及神经生物学出发来剖析现代文明中不科学的行为和信念。比如站在科学的角度，其严谨性使得对于任何问题，永远不可能给出百分之百的结论，只能非常接近绝对，而这一点就与我们人类的惯有的心理与思维背道而驰。</p>
<p>或许你受过高等教育，自认为与那些不科学与不理性的事情毫无关系，那就真的错了。很多影响我们判断的因素深深纂刻在了我们的基因里，并不会因为教育程度高低而改变，教育只是能更好的帮助我们有意识的去感知，理解和接受行为。在作者看来，我们没必要厌恶自己的错误行为，而是去理解它背后的原因，进而慢慢去做改变。</p>
<p>本书整体从阴谋论、卡里斯玛型领袖、确认偏误、因果关系、逃避复杂性以及接受风险几点来详细剖析我们作为人受各种因素影响导致的各类不理性与不科学的行为的真正原因。</p>
<h2 id="阴谋论"><a href="#阴谋论" class="headerlink" title="阴谋论"></a>阴谋论</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-11-39.png"></p>
<p>我们是如何被诱导陷入阴谋论的漩涡中的？</p>
<p>书中表达了一个观点：『阴谋论给了相信它的人某个具体事物，让这些人可以责怪是这东西让自己陷于困境中，而不必归咎于非人为的、抽象的社会力量。』</p>
<p>通俗点来说就是，既想表达对于世俗的不满，有满是借口来规避自身责任去改变。习惯将自身作为受害者，而又要克服无力感的欲望，这就激发了我们内心深处对于阴谋论的认同感。我们喜欢将自己无力控制的事情归咎于强大而又黑暗的幕后力量，使得我们对此的坦然的接受。既满足了情感上的需要又得到了一个自认为合理的解释。</p>
<p>一般来说，我们在判定某一阴谋论是否成立时，会有两种情况：当我们去思考熟悉的阴谋论时，会尝试使用已知事实和科学证据来评估其可信度。而对于陌生的阴谋论时，确主要依赖阴谋论的动机强弱做出判断。</p>
<p>比如，我们普通人对于转基因其实并没有多少了解，但是从利益角度思考是成立的，就理所当然的任务转基因的阴谋论就是成立的。其实从本质上看，将问题从科学可能性转化为了动机的强烈程度，显然就有悖于科学了。</p>
<h2 id="卡里斯玛型领袖"><a href="#卡里斯玛型领袖" class="headerlink" title="卡里斯玛型领袖"></a>卡里斯玛型领袖</h2><p>当我们处在群体中，对我们理解复杂问题的方式、决定信赖什么、判断事物的真伪造成怎样的影响？</p>
<p>《乌合之众》一书也表达了其观点，可能存在一定偏激，不过现实也并没有我们想象的那么理想。作为人类，面对矛盾的容忍度着实不高，而社交动机上又希望表现的与其他人一致，进而导致由于群体引发的诸多问题。</p>
<p>从人脑结构以及其功能来说，人类最基本的情绪源自于大脑中较为原始的部分，比如杏仁核、岛叶以及伏隔核，而理性则来自于我们的前额皮质层。强烈的刺激会导致杏仁核抑制前额皮质，为迅速反应做好准备。而强势的前额皮质也可以用理性来抑制情绪脑，避免做出冲动行为。理性与感性平衡时，则出现了理想的人类：可以很好的体验爱、恐惧、同情等复杂的情绪，也能读、写以及计划等高等的理性思考。所以说，理性与感性，我们更应该学习的是如何平衡，而非去抑制某一端。但平衡仅仅是作为人类的最佳理想情况。</p>
<p>而卡里斯玛型领袖是什么？将原本理性分析的问题，抹上感性的色彩，比如回避科学的数据分析将问题放宽到自由和公正这类普遍关注的问题上来转移我们对核心议题的注意力（怎么感觉就是说的灯塔国。。。）。然后，我们便深信不疑的支持以及推崇。不过我们需要明确，卡里斯玛型领袖并非完全贬义。</p>
<h2 id="确认偏误"><a href="#确认偏误" class="headerlink" title="确认偏误"></a>确认偏误</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-15-24.png"></p>
<p>为什么我们总是各执己见，为坚持自己的言论的而争论不休？</p>
<p>确认偏误指的是作为人类普遍的一种倾向，只关注与我们原本就认为是正确的信息相一致的信息，主动有所选择地去关注那些与我们的假设一致的事物的过程（其本质依旧与我们大脑中的奖惩机制有关）。</p>
<p>确认偏误有不少特点。首先，它容易形成非理性首因效应：我们对初次听到或体验到的信息的信任程度比之后得到的信息要高。其次，确认偏误受情绪影响，比如我们容易被激情冲昏了头脑。最后，为了坚持某一个信念，我们对任何与这个判断有冲突的事情都听不进去。</p>
<p>而科学又是一个持久的过程，在此过程中，一个人将尽自己最大的努力去证明我们相信的每件事都是错的（科学的证伪）。如果这种证伪的尝试严格重复了足够多次之后依然毫无成果，我们才开始相信这个科学理论或许就是真的。</p>
<p>在确认偏误的强大力量面前，我们需要转移我们的注意力，全心全意地对证据进行理性且持续的评估。认识到人对自身信念的执着背后有着深刻的情感方面的理由，在可以预见到的特定脑回路和脑网络活动下，这些理由得到了巩固。</p>
<h2 id="因果关系和知识空白"><a href="#因果关系和知识空白" class="headerlink" title="因果关系和知识空白"></a>因果关系和知识空白</h2><p>你觉得什么是因果关系？仅仅是总能观察到B在A之后发生，先后的连续性，便能断定A就是B的因么？</p>
<p>哲学家、科学家和经济学家千年来都在争论是什么构成了因果关系，至今可能都没有一个出色的答案。</p>
<p>因果关系最早源于亚里士多德的四因说（质料因、形式因、动力因、目的因），他提出：除非我们知道某事物的原因，否则就不算掌握了关于该事物的知识。</p>
<p>哲学家休谟对于因果关系的话题，其更感兴趣的是确立我们感知因果关系的模式，而不是其真实概念。我们对因果关系的感知方式取决于因果两者在时序上有先后且在空间上相邻，这是不是真正可靠的建立因果关系的办法？</p>
<p>在波普尔看来，证明因果关系存在这个目标是错的。归纳推理的目的不是“证明”，而是“证伪”。</p>
<p>那么十分现实的问题是：一方面是专业科学家带着健康的怀疑主义精神寻求建立因果关系，另一方面是亚里士多德指出的人类追求因果机制的天性。</p>
<p>比如有50个实验与他们的信念相冲突，而唯独有一个实验似乎与之相符，这些人当然就会抓住那一个实验大肆宣传，同时还要对科学家们加以控诉，说后者始终知道内情，只是一直在掩盖真相。这种做法通常被称为“精选数据”。</p>
<h2 id="逃避复杂性"><a href="#逃避复杂性" class="headerlink" title="逃避复杂性"></a>逃避复杂性</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-17-58.png"></p>
<p>近些年比较火爆的观点是将我们的思维分成两种类型，快思考和慢思考，反思系统和反射系统等。</p>
<p>情绪脑，人类进化过程中保留的大脑中相对原始的、哺乳动物都有的部分，深植在哺乳动物大脑中称为边缘皮质的区域内。用于做出迅速的、情绪化的决定来保证原始环境自身的生存几率。</p>
<p>而相对的大脑中进化程度最高的部分-前额皮质，我们称之为理性脑。它能调节常规信念处理过程的三个组成部分：</p>
<ul>
<li>在理性思考时对一种信念刻意做假装它可能不成立的“信念抑制”；</li>
<li>用直觉对一种信念的成立“感觉其正确性”；</li>
<li>用直觉对超乎寻常的信念内容“感觉其错误性”，或提高警惕。</li>
</ul>
<p>不过理性思维的困难在于运用前额皮质并做出理性选择消耗的能量非常之高，令人极度疲惫。这也是为什么我们习惯于不假思索，逃避花费时间与精力去理性思考。</p>
<h2 id="接受风险"><a href="#接受风险" class="headerlink" title="接受风险"></a>接受风险</h2><p>为什么我们忽视了与每天都发生的活动——如淋浴和驾驶——联系在一起的风险，却不停地为小到近乎不存在的可能性——如对疫苗有不良反应，核电站、高压电线的伤害？</p>
<p>答案就隐藏在人类心理对风险的感知中：当涉及健康问题时，人们无法容忍由感觉上控制不了的危害产生的风险，却可以心满意足地接受觉得在自己控制之下的风险，即使这两种感觉是不准确的。</p>
<p>几个能导致我们对风险做出判断的关键定性特征。除了对自我感觉无法控制的风险难以容忍，我们还不能忍受可能造成灾难的风险、有致死后果的风险，或者自己所在的人群承担风险而好处却被别的人群拿走。</p>
<p>核武器和核电站高度满足上述全部特征，即：</p>
<ul>
<li>（1）我们不能控制发生在核电站里的事情；</li>
<li>（2）假如真的发生与核能相关的事故，那将是致命的；</li>
<li>（3）我们总有办法发电的，所以从核电站得到电力这种做法怎么值得冒险尝试呢？</li>
</ul>
<p>从专业角度看，心理学家、行为经济学家以及神经科学家把人们高估小的可能性而低估大的可能性的倾向称为“非线性可能性估算”。</p>
<p>我们不认为火车是高风险事物，哪怕刚看到一起被大肆报道的火车事故的新闻，但核反应堆的一起小事故就会引发显而易见的社会震荡和强烈忧虑，以及排斥核技术的反应。风险研究者提出，我们心中对这两类事故产生区别对待的依据是我们对发生事故的系统的熟悉程度。</p>
<p>我们大脑的一种常见的经验法则：熟悉就是好且安全的；不熟悉就是坏且危险的。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>整本书都在主张，在拒绝接受科学证据这种行为背后有着复杂的心理学、社会学以及神经生物学基础。作者也提出了，此类倾向中有很多在各个方面都是适应性行为，很正常，也很符合人类的本性。</p>
<p>告诉人们不要感情用事不仅无济于事，压抑人脑的这一面不符合任何人的最大利益。所以，不过我们可以使用一种多要素方法来帮助人们，引导他们直面证据，同时又不会忽略人性中重要的那一部分。最后，我们不希望人们在本应关注数据的时候争先恐后地寻觅逸事。</p>
<p>以下是作者的几条指导原则：</p>
<ol>
<li>不是只有未受过教育的人才会做出不理性的医疗健康类决策。</li>
<li>不是“信息匮乏”这么简单，不能忽视了心理学、情绪及社交方面的本能。</li>
<li>同情心与进化优势有时与理性思维有冲突。</li>
<li>假设检验无力发表绝对肯定的主张，人们对此感到不自在。</li>
<li>人们对情感的回应比对数据的回应热烈，但卡里斯玛型领袖利用情感，而科学家利用数据。</li>
<li>人们要改变想法是很难的。</li>
<li>人们很难理解概率与风险。</li>
</ol>
<p>如果我们不把心理学、情感和社会动力纳入对话中，就永远不能在反对危险的、不科学的理念的斗争中取得任何进展。</p>
<p>人们为什么会坚持毫无科学依据的、不理性的医疗和健康观点——的答案其实就这么简单：因为我们是人类，我们是有同理心而且社交动机强烈的人类，具有复杂的心理与情感，以及高层次的社交因素。</p>
<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>本书真真实实的加强了自身对于自我认知的理解。自以为作为现代社会受教育程度和学习力还可以的人，缺也是没法绕开人类与社会等影响。</p>
<p>作者通过非常多强有力的事实证据来从多个角度阐明了『为什么如此发达的现代文明中，仍有如此之多的人去坚信毫无科学依据、不理性的医疗以及健康观点』。</p>
<p>答案很简单，因为我们是人类，我们是有同理心而且有构建社群的强烈动机的人类，复杂的心理学、社会学以及神经生物学等非常多之因素在影响我们的判断与分析。</p>
<p>在各类复杂因素的相互作用下出现了阴谋论、卡里斯玛型领袖、确认偏误、因果误判、逃避复杂性、错误的分险与可能性等，让我们沉溺于不科学与非理性之中，难以自拔。</p>
<p>而从科学的角度，其弱势就是我们永远不能给出百分之百的结论，只能非常接近绝对肯定，这又与人类惯有的思维背道而驰。</p>
<p>这是一本需要颇耗心力去阅读与理解的书，给我最大的触动并非作者将认知陷阱这个问题分析的如此之透彻，而是作者并不否定任何一种行为，而从更深层次的角度去剖析与认可该行为背后的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2021/02/17/2020-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/2020-summary/" class="post-title-link" itemprop="url">2020年度总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-18T00:00:00+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 22:45:02" itemprop="dateModified" datetime="2022-03-10T22:45:02+08:00">2022-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当前已是21年2月，最近被一些事情所触动，决定重新拿起键盘去记录一些东西，让自己保持反思与思考的习惯，那么暂且从这2020的年度总结开始。</p>
<p>写作对于自己而言，从来不是一件容易的事情，毕竟就连当年的高考作文，离800字的合格线也还差了两行。自认为就语言方面而言，可能有点欠缺&amp;#x1f613;！</p>
<p>新的一年，希望自己能坚持持续性的做一些沉淀，反思，以写作的形式做一些有意义的输出。</p>
<h2 id="回想过往"><a href="#回想过往" class="headerlink" title="回想过往"></a>回想过往</h2><p>9年前的那个春节，拿着三千块独自去了北京，住在生命科学园的村子里，每天挤着昌平线，而那时的自己是充实而又纯粹，地铁上捧着红宝书的自己或许是这辈子最努力的样子。自身没啥过人的天赋，只是感谢曾经努力的自己，为着纯粹的做一个前端开发的理想。</p>
<p>在此也发自内心的感谢东哥、洪梅姐、百分点的那波玩伴，俊阁，许总以及果壳的那一大家子人，成了一个南方人，在北京的故事。（由于个人性格关系，后期联系较少，也请见谅）。</p>
<p>北漂的日子，简单，充实，也瞬息万变。让我从一个跨专业到计算机行业就业的学生，慢慢成为了一个算是合格前端工程师。</p>
<p>6年前的那个春节，离开了呆了3年的北京，那个带给自己很多故事的地方，满怀期望来到了上海，自己向往已久的公司 - 百度，开始了作为人生第二段的职业故事。</p>
<p>自己走上前端的道路，纯粹因大三的计算机网络选修课上，那位老师说百度的校招生，基本月薪1万起，11年时的我们确实单纯而又世俗&amp;#x1f602;。算是回到了梦最初的地方。</p>
<p>上海的生活，便是逐渐走向平稳。在百度，眨眼间就是5年多，可能因为自身开始缺乏目标性的原因，感觉慢慢的走向舒适，而也变得有一定焦虑。</p>
<h2 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h2><p>2020年，沈逸老师用『百年未有之大变局』来描述世界格局的变化。</p>
<p>而对于自己人生来说也是如此，小满哥的到来，媳妇的被隔离，从百度的离开，在B站的融入，在上海的看房买房，与房东的斗智斗勇…，确实也可以写成一部短篇小说。</p>
<p>2020年里，做了很多抉择，学会了更加全面的看待自己，成长确实不多，但还是有幸能时常的去反思自己，开始学习去构建自己的知识体系，有规划的完备一些技术与非技术储备，学会去接受本不完美的自己。</p>
<p>而2020年的遗憾也不少，计划执行力下降明显，读书计划惨不忍睹，每日使用自家APP时长过长&amp;#x1f625;（少刷视频多看书），懒癌晚期患者~，两个自我的斗争中，明显败的挺惨。</p>
<h2 id="关于2021"><a href="#关于2021" class="headerlink" title="关于2021"></a>关于2021</h2><p>2021年，收拾行囊，重新出发。</p>
<p>今年，希望自己在专注、靠谱、情绪管理以及沟通方面能有一定成长，以及继续完善自己的知识体系，产出一些自己的心得体会。</p>
<p>在专注力上，能有自己的行为方式与习惯，提高自身各方面效能，加强自身的核心竞争力。</p>
<p>在靠谱度上，重新找回年轻的心态和斗志，认真有态度的去做到每一件自己认可的、承诺的事情。</p>
<p>在情绪管理方面，期望能控制短时间内的冲动，多角度，多立场的看待与解决问题，作为情绪的管理者而非奴隶。</p>
<p>沟通方面，能较好的快速获取对方的观点，简洁的表达自身观点，以及权衡双方矛盾等，需要继续有待学习与提升。</p>
<p>学习方面，不断完善自身的知识体系，学习沉淀对于技术与非技术的有效认知，以体系的形式去看待与解决问题。</p>
<p>2021年以及未来，学会接受各种磨砺与挫折，能正向的面对。有句话听过好多次，有点过，但是很不错：『世界以痛吻我，我要报之以歌！』。希望自己能以更宽广包容的心态去拥抱这个世界！</p>
<blockquote>
<p>尚未佩妥剑，<br>转眼便江湖。<br>愿历尽千帆，<br>归来仍少年。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2020/04/10/fe-engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/fe-engineering/" class="post-title-link" itemprop="url">浅谈前端工程化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-11T00:00:00+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 22:45:02" itemprop="dateModified" datetime="2022-03-10T22:45:02+08:00">2022-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://image.freefe.cc/202004111008.jpeg" alt="image"></p>
<p>在前端开发的角度看工程化，相对来说缺乏一定的经验标准。在此简单聊聊自身前端工程化的概念和理解。若有错误，欢迎指正。</p>
<h2 id="软件危机与软件工程"><a href="#软件危机与软件工程" class="headerlink" title="软件危机与软件工程"></a>软件危机与软件工程</h2><p>简单的了解下早期由于软件问题引发的真实案例。</p>
<blockquote>
<p><strong>Therac-25医疗事故：</strong><br>加拿大原子能公司生产的放射线疗法机器，其软件系统由于未处理好多进程时序的冲突问题，导致多起医疗事故。患者接受了高出正常剂量的百倍辐射，造成多起死亡或严重灼伤事件。</p>
</blockquote>
<blockquote>
<p><strong>美国银行信托软件系统开发：</strong><br>82年美国银行规划发展信托软件系统，原计划预算2千万美元，耗时9个月，于84年底前完成。实际至87年3月，期间投入6千万美元，最终因系统不稳定而放弃。导致被迫转移340亿美元信托资金，失去6亿美元的信托商机。</p>
</blockquote>
<blockquote>
<p><strong>阿丽亚娜-5运载火箭爆炸事件：</strong><br>96年6月，阿丽亚娜-5运载火箭首次测试发射，在发射后37秒被迫自行引爆，原因由于64位的运算错误地变为16位的运算，造成程序崩溃，火箭感测角度失常，从而触发自毁装置的启动。</p>
</blockquote>
<p>以上软件问题均出现在计算机诞生早期，而在如今互联网崛起的时代，问题似乎越发严峻。单以安全为例，不管我们的防御如何的升级与完善，相关的事件问题确越来越多。</p>
<blockquote>
<p>Google遭受黑客入侵的极光运动、索尼PlayStation和索尼影视黑客事件、Adobe攻击事件、Carbanak组织入侵银行、乌克兰电网入侵、雅虎数据泄露、万豪酒店数据泄露等。</p>
</blockquote>
<p>或许你会觉得，以上软件问题和网络安全事件，与工程化或者说软件工程又有什么关系呢？</p>
<p>其实很简单，所有的各类软件或网络安全问题，本质上都指向了一个根本原因：<strong>日益庞大的软件系统，其复杂度已经远超我们人脑可以直接控制的程度。</strong></p>
<p>于是北大西洋公约组织，在1968年创造了软件危机一词，来定义软件项目开发中的预算、周期以及质量引发的问题。同时召集了数十位业界顶尖的编程人员、计算机科学家和工业届巨头，讨论制定摆脱软件危机的对策，也是首次提出软件工程）的概念。</p>
<h3 id="软件危机（Software-crisis）"><a href="#软件危机（Software-crisis）" class="headerlink" title="软件危机（Software crisis）"></a>软件危机（Software crisis）</h3><p><img src="http://image.freefe.cc/202004111002.jpeg" alt="image"></p>
<p>软件危机的概念：在软件开发与维护过程中暴露出来的一系列的严重问题，导致直接影响软件的使用寿命甚至夭折。</p>
<p>对应具体问题主要有以下类型：</p>
<ul>
<li>项目超出预算。</li>
<li>项目超过排期。</li>
<li>软件质量低落。</li>
<li>软件不符合需求。</li>
<li>项目无法管理，代码难以维护。</li>
</ul>
<p>是不是与我们现在项目中遇到的问题大同小异？</p>
<h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><blockquote>
<p>软件工程：研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科 - 维基百科。</p>
</blockquote>
<p>因软件危机而生的软件工程，主要由以下两个构面：（深入了解学习具体可参见《代码大全》学习）</p>
<ul>
<li>软件开发技术：开发方法、工具、开发环境</li>
<li>软件项目管理：软件度量、项目估算、进度控制、人员组织、配置管理、项目计划</li>
</ul>
<p>简单说完软件危机和软件工程，那边开始简单说说前端工程化的概念。</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>随着互联网的飞速的迭代，前端也从早期的页面项目形态到日趋复杂的软件形态，项目复杂度呈指数级上升，也就给前端开发者带来了不可避免的软件危机的问题。</p>
<ul>
<li>接手的项目代码质量是不是想口吐芬芳？</li>
<li>多人协作开发是不是混乱不堪？</li>
<li>公共方法、函数、样式、组件等是不是使维护无从下手？</li>
<li>提交、测试、上线流程是不是存在各类安全分险问题？</li>
<li>…</li>
</ul>
<p>作为一线开发者，我们肯定遇到过以上类似情况，这也是目前软件开发赤裸裸的实现。那么对于前端工程化，就是希望能更好的解决类似的问题。</p>
<ul>
<li>如何保证项目的协作开发效率？</li>
<li>如何保证项目的代码质量与迭代开发质量？</li>
<li>如何保证项目的可复用性、可维护性和可扩展性？</li>
<li>如何保证项目重复工作的效率与准确性？</li>
<li>如何保证项目开发、上线流程的低风险？</li>
<li>……</li>
</ul>
<p>结合工程化的概念来说，<strong>前端工程化的定义就是借助软件工程的技术、方法和思想，来优化前端侧的流程、效率和规范等，使用系统性、规范化、可定量的前端工程实践，结合项目自身，构建出相对较优的工程实践方案</strong>。</p>
<p>参考网上将前端工程化分四个能力点：规范化、模块化、组件化、自动化，个人还是比较认同。</p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p><img src="http://image.freefe.cc/202004111018.jpeg" alt="image"></p>
<p>无规矩不成方圆，对于编程这件事情，我们需要建立许多的规范标准，有效的执行才能确保我们项目各方面质量。而之所以将规范列为首要条件，不仅仅因为规范是最重要的一点也是最难做好的一点。</p>
<p>框架层面不管我们使用的是React、VUE或者是jQuery，样式上不管是用Sass、Less还是原生css，只要在早期的基础架构上，积极的制定好初步的规范，持之以恒去坚持和完善，那么我们的项目就可以具有生生不息的生命力。而遵守规范也是作为一个合格程序员最基础的条件。唯一的准则是你可以去质疑或者优化规范，但是没有打破之前，你不能不遵守规范。</p>
<p>以下简单梳理下个人能考虑到的一些关于开发规范方面的点：</p>
<h4 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h4><p>分支规范是处理多人协同开发的关键点，没有绝对的正确答案，具体依照项目自身复杂程度以及基础环境，来评估最佳的分支实践。</p>
<p>目前大致有以下类型分支形态：</p>
<ul>
<li>1、主干开发工作流：主干开发主干发布。</li>
<li>2、功能分支工作流：功能分支开发，主干发布。</li>
<li>3、分支开发分支发布工作流：功能分支开发，功能分支发布，合入主干。</li>
<li>4、GitFlow：Master、Develop、Feature、Release、Hotfix 多功能分支动态协作方式。</li>
<li>5、Github Flow：Master 与 Feature 分支的简单模型。</li>
<li>6、GitLab Flow：与Github Flow类似，添加Pre-Production 和 Production 分支进行环境部署处理</li>
</ul>
<blockquote>
<p>注意分支规范等同时，需要遵守标签的规范。</p>
</blockquote>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><p>编码规范的目的就是提高代码的可读性和可维护性，确保自己或者他人维护或者扩展代码的统一性，降低复杂度，也避免语言上的一些细节问题等。前端侧包含但不仅限于 HTML规范、CSS规范、JS规范、VUE&amp;React规范、TS规范等。</p>
<h4 id="架构规范"><a href="#架构规范" class="headerlink" title="架构规范"></a>架构规范</h4><p>前期保证简单易扩展的基础架构模式，开发人员需严格遵守现有的结构、组织以及构建模式。在需要升级优化架构时，进行基础评估以及各使用方确认，在保证兼容，不降低质量的前提下进行架构升级以满足业务的复杂度。</p>
<h4 id="提交与CR规范"><a href="#提交与CR规范" class="headerlink" title="提交与CR规范"></a>提交与CR规范</h4><p>代码的提交前置检测与CR，是我们确保项目代码质量最重要的环节。代码规范是否统一，是否可能含有隐性的逻辑问题，代码质量是否符合标准等各方面的质量控制均在这两个环节进行把控。自动化风格检测，自评与他评等，是作为我们开发者自身去确保代码质量最基础的标准。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他方面还包括对于自身项目设计评审规范、单测标准规范、提测流程规范、上线流程规范等标准化的建立与执行等。</p>
<p>所有环节均以标准化、规范化进行执行，方能确保我们的项目不至于快速陷入项目的软件危机之中。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><img src="http://image.freefe.cc/202004111032.jpg" alt="image"></p>
<p>万物皆模块！在前端工程化的不断进化中，我们逐渐将前端侧所接触的一切内容，行为以及资源，均作为模块的概念进行抽象与管理，达到我们统一管理项目资源的目的。</p>
<p>对项目进行逻辑细化、管理拆分是模块化概念不变的主题，旨在降低我们大脑的思维逻辑在同一时间需要思考的复杂度级别，从而提高项目的简单可维护性。管理复杂度是我们最终目标。</p>
<h4 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h4><p>随着ES规范的不断完善，JS的模块化历程也逐渐的统一。从早期的AMD、CMD转化到了ES6 Module，从标准规范转到了ES6规范，成为了语言的特性。</p>
<p>CommonJS：主要用于Node侧，每个文件均为独立的模块，均含有自身的作用域，通过require来引入内置、自定义以及第三方模块。由于偏向服务端侧规范，以同步模式进行引入，相对来说不适用于浏览器侧模式。</p>
<p>AMD：RequireJS的模块化规范产出，非同步模块的加载，以回调函数方式执行。define来定义模块以及require来加载模块使用模块。需提前加载所有依赖而非按需加载，依赖前置，提前执行。</p>
<p>CMD：依赖就近，延迟执行。主要为SeaJS推广的模块定义规范，集成了CommonJS与AMD的一些特新，同时支持同步与异步加载。</p>
<p>ES6 Module：作为JS内置的语言特性，相对于CommonJS</p>
<ul>
<li>CommonJS为运行时加载，ES6 Module为编译时输出接口</li>
<li>CommonJS加载整个模块的所有接口，ES6 Module可以独立输出其中一个接口</li>
<li>CommonJS输出值的拷贝，ES6 Module输出值的引用</li>
</ul>
<p>当然，借助于强大的Webpack我们能很好的将不同类型的模块化规范的JS文件进行结合构建，共存使用。</p>
<p>JS的模块化历程也算是前端模块化历程的缩影，不断的尝试以及最后的统一，感谢ESMA，当然也感谢WebPack。</p>
<h4 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h4><p>借助于CSS预编译工具的广泛使用，如Sass、Less、Stylus等，前端侧相对较为死板的CSS也变得无比灵活，在支持变量、嵌套、混合等高级的能力支持，使得CSS的细化拆分变得容易，从而使得前端开发者能更好的以模块化的思维来对项目的CSS进行统筹管理。极大简化了项目CSS的开发与维护复杂度。</p>
<p>但是以上的工具纯粹解决的只是样式模块化复用，编程能力弱的问题，缺无法解决以下问题：</p>
<ul>
<li>样式全局污染，以及各类权重覆盖问题</li>
<li>命名混乱的冲突</li>
<li>CSS模块引入相互影响，作用域问题无法解决</li>
<li>压缩侧对于冗长的样式名等无能为力</li>
</ul>
<p>于是乎，BEM风格解决方案、CSS Modules 模块化方案等开始应运而生，各类方案各有利弊，依据项目与团队本身进行评估选择。</p>
<p>BEM风格：Block、Element和Modifier通过命名规范来规避以上问题，前提是在各方开发者遵守既定规范的前提下。</p>
<p>CSS Modules：类似的仍是基于命名层面处理，对应组件内模块化样式进行特定规范标识，从而解决上述问题。</p>
<p>当然，没有银弹，我们要做好的就是以最合适的方案解决我们项目的问题。</p>
<h4 id="资源模块化"><a href="#资源模块化" class="headerlink" title="资源模块化"></a>资源模块化</h4><p>万物皆模块的基本表达，不管是图片、数据还是其他各类资源，借助于WebPack的强大能力，将所有项目相关资源视为模块进行管理。</p>
<blockquote>
<p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
</blockquote>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><img src="http://image.freefe.cc/202004111023.jpeg" alt="image"></p>
<p>组件化相对于模块化来说，是一个更高纬度的颗粒化，而在前端侧，组件化主要指的UI组件化。如果说各类构建工具推动了前端模块化的支持与发展，那边前端流程的框架便推动了前端组件化概念思维的大爆发。</p>
<p>组件化的目标与模块化类似，主旨便是降低复杂度。将特定的逻辑、模板以及样式独立封装，具有可复用性和低耦合性的基础UI模块。简单来说无非就是隐藏自身内部逻辑，减小编程开发中时间点所需要思考的复杂度。</p>
<p>对于项目来说，一般对于组件的划分模式较多，自己喜欢将其划分为基础UI组件，业务逻辑组件以及页面组件。</p>
<ul>
<li><p><strong>基础UI组件：</strong> 相对项目来说最底层支持配置的组件，具有统一的业务逻辑和行为等，比如项目自定义Button、Input等，广泛使用的一些基础UI组件库（Ant Design、ElementUI等）。在编写基础UI组件时，需要明确与具体业务逻辑剥离，专注于所定义的基础组件的逻辑、交互和行为，按需进行配置化支持。基础组件更偏向于复用性。</p>
</li>
<li><p><strong>业务逻辑组件：</strong> 在基于基础组件的前提下，结合项目业务进行组件化，对于页面级别进行拆分和组件化，目标仍是封住逻辑，降低项目内页面开发复杂度。相对而言，业务组件更偏向于逻辑封装和管理。</p>
</li>
<li><p><strong>页面组件：</strong> 页面级别对于基础组件与业务逻辑组件的统筹管理，在页面级别则不在深入具体的细节交互逻辑。</p>
</li>
</ul>
<p>当然组件类型的拆分编程思维，万千世界各有不同，每位开发者对于组件化思维的考虑均有不同，以符合项目自身出发。</p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><img src="http://image.freefe.cc/202004111033.jpg" alt="image"></p>
<p>前端自动化主要指前端工程上各阶段使用自动化工具来提高效率与准确性的方式。如代码风格与质量检测，构建、部署、测试、发布等大量重复性和大数量级工作的处理，实现自动化检测、评估与运行。</p>
<p>自动化概念设计到开发者整个开发流程的各阶段，具有非常重要的席位，下面简单介绍一些实用的自动化工具：</p>
<ul>
<li>自动化代码检测：不用说，强大的套餐，ESLint、StyleLint、HTMLHint等，以项目代码规范进行静态资源检测配置，进行代码前置检测。</li>
<li>自动化构建工具：毫无疑问，目前WebPack算是一统天下，并且其加载器、插件几乎集成了所有基础的自动化处理工具的能力。grunt -&gt; gulp -&gt; webpack 也算是前端构建历史的迭代历程了。 </li>
<li>自动化测试工具：除了大量流程的测试框架如mocha、jest等，还有如测试平台karma、断言工具库chai，以及无头浏览器PhantomJS，真实浏览器工具puppeteer等。</li>
<li>自动化部署：此处工具依赖各开发者公司的几次发布平台，一般均有固定的支持的模式。（如jenkins支持等）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结来说一下，前端工程化所需要解决的问题，也无非就是软件工程所要解决的难点。软件工程中没有银弹，也没有绝对的好与坏，只有是否适用和正收益。</p>
<p>前端工程化问题无非从软件规范、开发思维以及开发工具，认真做好每一步，尽量减弱破坏项目规则的每一个可能的点来加强我们项目的健壮性。当然对于非常多的项目，实现以上所有的点太过于理想化，所以要评估我们项目工程化程度的前提是，我们是否确定已经评估我们所需要项目的健壮程度，而后在进行评估做到怎样程度的工程化。</p>
<p>最后结合百度工程化的一些评估要求，简单产出相对可量化评估的偏前端工程化Map：</p>
<ul>
<li>需求阶段：迭代管理、需求管理、BUG管理</li>
<li>开发阶段：设计评审、分支管理、项目规范、编码规范、提交规范、需求关联</li>
<li>准入阶段：CodeReview、单元测试、增量代码扫描、集成构建方式、核心功能准入测试</li>
<li>测试阶段：手动测试用例、自动化测试用例、全量代码扫描、性能评估、功能回归</li>
<li>发布阶段：部署产物规范、资源缓存规范、页面监控检测</li>
</ul>
<p>最最后，我们需要记住任何行为，均有其正面与反面意义，我们需要评估的是其正收益是什么！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/06/07/coding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/07/coding/" class="post-title-link" itemprop="url">如何优雅的编程 - 来自《代码大全》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-08T00:00:00+08:00">2019-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 22:45:02" itemprop="dateModified" datetime="2022-03-10T22:45:02+08:00">2022-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来自《代码大全》内容信息整理，豆瓣评分9.3。</p>
<blockquote>
<p>Write Programs for People Frist, Computers Second.<br>首先为人写程序，其次才是机器。</p>
</blockquote>
<h2 id="软件构建的世界"><a href="#软件构建的世界" class="headerlink" title="软件构建的世界"></a>软件构建的世界</h2><h3 id="什么是软件构建"><a href="#什么是软件构建" class="headerlink" title="什么是软件构建"></a>什么是软件构建</h3><p>软件开发中的各类不同活动：定义问题、需求分析、规划构建、软件架构、详细设计、编码与调试、单元测试、集成测试、集成、系统测试、保障维护、</p>
<p>软件构建一般也会被认为编码 coding，或者编程 programming。而构建感觉就不显得那么机械化，而需可观的创造力与判断力。构建活动主要集中于编码与调试，但也牵涉来除定义问题以外的所有活动。</p>
<p><img src="http://image.freefe.cc/2019-06-28_08-41-55%20%281%29.png"></p>
<h3 id="软件构建为何如此重要"><a href="#软件构建为何如此重要" class="headerlink" title="软件构建为何如此重要"></a>软件构建为何如此重要</h3><ul>
<li>构建活动是软件开发的<strong>主要组成部份</strong>。根据项目的不同，一般占据项目的 30% - 80% 的总开发时间。</li>
<li>构建活动是软件开发的<strong>核心活动</strong>。需求分析与架构设计都是项目的基础工作，使得我们更有效的构建。测试则为构建活动的后续工作，用以验证构建的正确性。</li>
<li>将主要精力集中于构建活动，可以大大<strong>提高程序员的生产效率</strong>。不同程序员的生产效率差异可达10-20倍（1968）。后续该结果被大量研究所验证。</li>
<li>构建活动产物-源代码-往往是<strong>对软件的唯一精确描述</strong>。很多项目，程序员唯一的到的文档就是源代码本书，因此，源代码就比必须有尽可能高的质量，利用各类技术来改善源代码从而得到一个详细、正确且信息丰富的程序。</li>
<li>构建活动是<strong>唯一一项确保会完成的工作</strong>。不管项目如何紧急，不管舍弃哪一环节，构建活动是不可或缺的环节，所以构建活动进行改进，是对改进软件开发过程一种有效的途径。构建活动的质量对于软件的质量有着实质性的影响。</li>
</ul>
<h2 id="隐喻，更充分的理解软件开发"><a href="#隐喻，更充分的理解软件开发" class="headerlink" title="隐喻，更充分的理解软件开发"></a>隐喻，更充分的理解软件开发</h2><p>计算机科学领域中有着丰富的语言，<strong>病毒、木马、蠕虫（worm），臭虫（bug）、崩溃（crash）、错误</strong>等。这些隐喻描述了软件领域中的各类特定的现象和事物，让我们更深刻的理解软件开发的过程。</p>
<h3 id="隐喻的重要性"><a href="#隐喻的重要性" class="headerlink" title="隐喻的重要性"></a>隐喻的重要性</h3><blockquote>
<p>通过把你不太理解的东西和一些较为理解、十分类似的东西做比较，你便可以对不理解的的东西产生更深刻的理解，这类形式的隐喻则为『建模』。</p>
</blockquote>
<p>化学家库勒梦见咬着自己尾巴的蛇，从而提出来环状分子结构，解释了苯环的各种特性。还有比如气体分子的运动理论、钟摆的思考、地心说，日心说等。隐喻都发挥着十分重要的力量。</p>
<p>在软件方面，隐喻好比是一个探照灯，不会告诉你去哪里寻找答案，而是告诉你如何寻找答案。隐喻的作用更像启示，启发式方法，而非算法。</p>
<p><img src="http://image.freefe.cc/2019-06-28_09-19-35%20%281%29.png"></p>
<p><strong>算法是一套明确的指令</strong>，来完成具体的任务。可预测、确定性、不易变化。从A到B，不会额外让你绕到C、D等地方。如驾车到某人家，算法是这样的：沿着X公路往南行进160公里到达Y，从Z口出往西南山上开12公里，杂货铺边红绿灯右转，就是M大街N号。</p>
<p><strong>启发式方法则是一种寻求答案的技术</strong>，具有较强的偶然性，仅仅引导你如何寻求解决方法。比如上面例子，启发式是这样解决的：找出之前的信，照着地址来到这个小镇，然后问一下小镇的人们，基本都知道我们，并且应该很乐意帮助你，如果找不到人，直接打电话给我们，我们会出来接你。</p>
<p>算法与启发式方法存在一定的相似，区别有点类似解决问题的间接程度。如果有一些明确改如何解决编程问题的信息，编程当然会更容易，结果也更易预见。但编程还远远没那么先进，或许永远不会那么先进。目前编程最大的挑战依旧是将问题概念化，正因为每一个问题在概念上都是比较独特的，所以要寻找一套能解决所有问题的通用指导就不太现实。那么对于各类问题，能知道大致上如何一般性的解决也就非常有价值来。</p>
<p>隐喻将提高我们对于编程问题和编程过程的洞察力，帮助思考编程过程中的活动，想象出更好做事的方法。</p>
<h3 id="软件的隐喻"><a href="#软件的隐喻" class="headerlink" title="软件的隐喻"></a>软件的隐喻</h3><p><img src="http://image.freefe.cc/Snipaste_2019-06-28_08-45-08.png"></p>
<h4 id="写作代码"><a href="#写作代码" class="headerlink" title="写作代码"></a>写作代码</h4><p>这个隐喻暗示着开发一个程序就好比写一封有缘由的一样，坐下来，拿出纸和笔，从头到尾的进行书写即可，无需做正规的计划，想到什么写出来便是。</p>
<p>对于个人规模的工作，或者小型项目来说，这类写作的模式已经足够了，然而对于其他场合而言，却远远不够 - 没有完整、充分的刻画软件开发工作。书写通常是一个人的活动，而一个软件项目多半会设计许多不同职责的人，写作或许你写完就完成了，但软件开发编码完毕后可能只是完成了一部分工作。对此更重要的是软件构建更注重于复用以往项目的设计思想、代码模块以及测试用例的开发效率，由于写作所要求的更注重原创。</p>
<p>故而以写作隐喻软件开发过程，则太过于单调与呆板。</p>
<h4 id="培植系统"><a href="#培植系统" class="headerlink" title="培植系统"></a>培植系统</h4><p>一些软件开发人员认为，应当将软件开发想象成播种与耕作的形式，一次设计系统的一小部分，编写一小块代码，做一点测试，然后将其成果一点点的添加到系统中去。</p>
<p>而作者认为，该模式中的增量技术是很有价值的，但是将其比喻成播种，耕作就不为恰当。犹如你对系统计划施肥，对设计细节蔬果，通过有效的管理来增加代码产量。问题在于暗示我们无法对于软件开发的过程和方式进行直接控制，你需要一点一点春天播下种子，按照节气处理照料，将在秋天活动丰盛的代码。这显然也不恰当。</p>
<h4 id="养殖系统：系统生长"><a href="#养殖系统：系统生长" class="headerlink" title="养殖系统：系统生长"></a>养殖系统：系统生长</h4><p>该隐喻类似我们如何一次为软件系统增加一个小部分。与生长相关类似词：增量的、迭代的、自适应的以及演进的。以增量方式进行设计、编译和测试，都是目前已知最强有力的软件开发概念。</p>
<p>在增量式开发时，预先做一个尽可能简单的、能运行的版本，不必有真实的输入，也无需对数据进行真正的处理以及真实的输出，仅仅需要构建足够强壮的骨架用以支撑未来的真实系统。对于你标注出的每一项基本功能，可能都仅需调用虚拟的类来进行占位。</p>
<p>骨架形成后，开始一点点的附着肌肉与皮肤，使用真是的类、接受真实的输入与输出、每次更新增加一小部分代码直到一个完整的工作系统。</p>
<p>作为隐喻，增量式开发的优势在于未做过度的承诺，对于耕作来说，将其作不恰当的引申更为困难一些。</p>
<h4 id="软件构建：建造软件"><a href="#软件构建：建造软件" class="headerlink" title="软件构建：建造软件"></a>软件构建：建造软件</h4><p><img src="http://image.freefe.cc/2019-06-28_08-47-13.png"></p>
<p>建造软件这一说法则暗示了软件开发中的诸多阶段，如计划、准备执行等，更具所建造软件的种类不同，各类阶段和程度也可能变化。</p>
<p>如果你要搭一个易拉罐塔，你就需要一双稳健的手，一块平摊的地以及十几个完整的易拉罐就能简单的开干。而你要搭一座100倍的塔，那么100倍的易拉罐就远远不够，需要采用完全不同的计划方法和建造方法，并且不那么执着的话，还有建筑材料。</p>
<p>如果你想盖一个简单的建筑，比如一个狗窝，你要去木材点买一些木材和钉子，找一些使用的工作，或许傍晚时分，你的爱犬就有新窝了。可能狗窝忘了加一个门或者其他的怎么漏子，不过没关系，修改一下或者从头再来，顶多就是一个下午的事情。宽松的设计对于小型项目还算合适，如果你写了1000行代码，发现设计存在问题，你倒是也可以重构或者重新再来，不会损失太多。</p>
<p>如果你是在建造一栋房子，那么建造过程就好复杂的多的多，糟糕的设计也会带来严重的后果。</p>
<ul>
<li>1、你要十分明确的准备建造一个什么类型的房子 - 软件开发中类似问题定义（problem definition）</li>
<li>2、你需要与建筑师探讨总体设计，并且确认。 - 软件的架构设计（architectural design）</li>
<li>3、画出你详细的蓝图，找一个承包人。 - 软件的详细设计</li>
<li>4、你要准备好建造地点，打好地基，搭建框架，砌好墙，盖好屋顶，通好水电煤气等。 - 软件的构建（construction）</li>
<li>5、庭院设计师、油漆匠、装修工来将新房子美化一番。 - 软件的优化（optimization）</li>
<li>6、整个过程会有各类检查者检测工地，地基，框架与布线等各类地方。 - 软件的评审（reviews）和详查（inspections）</li>
</ul>
<p>以上两种活动，更高的复杂度与更大的规模都会带来更多的结论。建材与人力的消耗。推到一堵墙后移半米的代价是相当昂贵的。你只有把房屋详细的设计好，才能不浪费资源去修正本可以避免的麻烦。开发软件，或许原材料是廉价的，但是人力成本甚至是市场的机会成本代价高昂。</p>
<p><strong>两类活动还有其他什么相似之处呢？</strong></p>
<p>建造一个房子的时候，你不会去试着建造那些能买到的一些东西。你会去买洗衣机，烘干机，洗碗机，电冰箱，但你们应该不会去自己动手造这些东西。<br>开发软件也一样。不会自己去处理一些系统层次的代码，回去寻找一些开源的程序，现成的能力，比如一些科学计算函数，用户界面组件，数据库访问等。自己编写那些能买到的现成的代码，通常一般情况下是没有太大意义的。</p>
<p>但是，更高一层来说，如果你想建造一间拥有一流家具的高档住宅。那么你可能需要定制洗碗机，电冰箱等高档家电。就如软件开发中一样，如果你要开发一款一流的软件，你就可能需要要自己编写科学计算函数，以获取更高的速度和更高的精准，自己编写容器内用户界面组件以及数据库访问等，使得你的一流的产品的各个部分都无缝连接，拥有一致的外观和体验。</p>
<p><strong>软件构建 类比 建筑构建</strong></p>
<p>适当的多层次的规划，对于建造建筑物和构建软件，都是有较高的好处的，如果你按照错误的顺序构建软件，那么编码测试和调试都很困难，需要花更长的时间才能完成，甚至整个项目干脆就分奔离析，由于每个人的工作都过于复杂，所有成果组合在一起的时候就会变得混乱不堪。</p>
<p>精心计划，并不是说什么事都巨无细的计划或者过度的计划，类似你在考虑房屋结构的时候，主要考虑结构性支撑的规划就行，没必要即可去考虑你是用地板还是瓷砖铺地。软件开发也一样，规划是否得当，体现在项目在后期改变细节上能力扩展的便捷性。</p>
<p>用建筑房屋来类比，软件构建还有助于解释为什么不同软件项目能从不同开发模式中获益。你去盖一间仓库，或者工具间，是盖一个医院，甚至是核反应堆，你在规划设计及质量保证方面的需求程度都是不一样的，所用的方法也是不一样的。所以说，有时软件开发中通常你只需要用灵活的，轻量级的方法，但有时候你就必须用严格的，重量级的开发方法以达到安全性目标，或者其他什么目标。</p>
<p>最后，建筑这一隐喻，让我们对超大型的软件项目认识更加深刻。超大型的结构一旦出问题，后果是非常严重的，所以有必要对这样的结构进行超出常的规划和建设。建筑人员需要非常小心的定制并核查计划，规划在建筑时留有余地，以保障安全。宁可多花10%的成本买更坚固的材料，也比摩天大楼倒下来划算的多。在美国纽约帝国大厦建造的时候，每辆运料车的运输时间都有会留有15分钟的余地，但如果每辆车在运输的时候没有指定到位，那么整个工期都会延误。</p>
<p>按房屋建造这一隐喻，很多软件开发中的术语都是从建筑中衍生而来的。软件架构、支撑性测试代码、构建、基础类等。</p>
<p>对于隐喻来说，不同的隐喻彼此并不排除，但使用恰当的隐喻能带来更多的优势，比如评估问题处理方式，相关优先级的思考，代码的编写逻辑与质量等。</p>
<h2 id="三思而后行：前期的准备"><a href="#三思而后行：前期的准备" class="headerlink" title="三思而后行：前期的准备"></a>三思而后行：前期的准备</h2><p>准备工作的中心目标是降低分险：一个好的项目规划者能够尽可能早的将主要的风险清除掉，使项目的大部分工作能够尽可能的平稳进行。</p>
<p>软件中最常见的项目风险是糟糕的需求分析和糟糕的项目计划，因此准备工作就倾向于集中改进需求分析和项目规划。</p>
<ul>
<li>1、并不是所有的专业的程序员都知道准备工作的重要性，并且在进入构建活动之前会去检查所有的先决条件是否已满足</li>
<li>2、大部分分配做前期准备活动的开发人员并不具备完成这项任务的专业技能。项目规划，分析全面而准确的需求，创建高质量的架构活动等等，都需要较高的经验与技能。</li>
<li>3、有很大一部分程序员，知道如何进行前期工作，但是并没有去做，因为他们不能够抵抗尽快开始编程的欲望，以及从项目侧的一些排期压力。</li>
</ul>
<p>比如在除了程序员侧各方看来，在项目开发阶段，他们只是关心100个功能每天实现多少，几天可以全部完成。这是从他们角度所关心的，并没有错。而程序员角度上，我们需要关心的则更多，以及如何更简单的或者朦胧的回答我们做的不仅仅是完成功能那么简单。</p>
<p>实现高质量的实践方法是那些能创建高质量代码的程序员的共性，很重要的一点是在项目的前期、中期以及后都强调质量。这也是《代码大全》要讲诉的整体主要内容。</p>
<h3 id="问题定义的先决条件"><a href="#问题定义的先决条件" class="headerlink" title="问题定义的先决条件"></a>问题定义的先决条件</h3><p>首先要满足的一项条件是：对这个系统要解决的问题做出清楚的描述。这个更多偏向于PM对于产品的定位，而程序员也应当明确的知道我们的目标以及面对的问题。</p>
<h3 id="需求的先决条件"><a href="#需求的先决条件" class="headerlink" title="需求的先决条件"></a>需求的先决条件</h3><p>明确需求的意义：</p>
<ul>
<li>1、有助于用户，而非单单程序员驾驭系统的能力。也避免程序员在编程期间自行决定一些含糊不清的需求。</li>
<li>2、有助于避免争论。目前RD与PM之间的摩擦大部分是由于需求在一定角度上不明确产生的。</li>
<li>3、有助于开始编程开发后的系统变更情况。或许代码上的错误，你只需修改几行就能解决，但是如果是需求上的错误，那就有可能需要整体改变设计与架构。</li>
</ul>
<p>众多组织数据显示：大型项目中，在架构阶段检测到需求错误，其修复成本是：需求阶段检测并修复的成本的3倍。编码阶段检测到需求错误，成本是5-10倍。系统测试阶段是10倍。发布阶段是10到100倍。</p>
<p>所有详尽的需求描述，是项目的关键。甚至一些情况可能比有效的架构技术更重要。</p>
<h3 id="需求稳定的神话"><a href="#需求稳定的神话" class="headerlink" title="需求稳定的神话"></a>需求稳定的神话</h3><p>需求稳定是软件开发的圣杯。项目就能有序的、可预测的、平稳的进行，完成架构到设计到编码到测试等一系列工作。早期IBM与其他公司数据显示，开发过程中平均会有25%的需求变更，因变更导致的返工预占比75%以上。这主要是1980年到2000的相关，目前的程序员或许相对来说对于变更更加适应一些或者做好来一些预设的准备，但数据上估计没有太好的改善。</p>
<p>我们如何预备应对需求变更？</p>
<ul>
<li>1、使用需求质量核对表来评估你的需求质量：开车开错的地点，下车检查路线肯定不算是浪费时间。</li>
<li>2、确保相关方明确了解需求变更的代价：提及进度与成本，往往对各方有效，许多必须有可能就变成来最好有。</li>
<li>3、建立变更的控制机制</li>
<li>4、使用能适用变更的开发模式：比如敏捷开发，缩短开发周期，更快速的需求迭代等。</li>
<li>5、放弃项目</li>
<li>6、注意项目商业案例</li>
</ul>
<p><strong>需求核对表</strong></p>
<ul>
<li>功能需求：明确功能的各项细节，包括输入输出，软硬件借口与通讯协议，用户期望功能，以及各项任务的目的等。</li>
<li>非功能需求：用户的操作，体验，安全性等问题考量。系统的可靠性、可维护性，可扩展性等考量。</li>
<li>需求质量：需求间的一致性，清晰详细程度，健壮性与正确性等。测试变更状态等调整的应对。</li>
<li>需求完备性：对于需求产出前的前置依赖，需求不完善或者变更后的可接受程度等。</li>
</ul>
<h3 id="架构的先决条件"><a href="#架构的先决条件" class="headerlink" title="架构的先决条件"></a>架构的先决条件</h3><p>软件架构是软件设计的高层部份，用于支持软件更细节的一些设计与开发工作。离开了良好的架构，可能瞄准来正确的问题方向，但却使用来错误的解决方案，导致来不成功的构建。</p>
<h4 id="架构的细节组成部份"><a href="#架构的细节组成部份" class="headerlink" title="架构的细节组成部份"></a>架构的细节组成部份</h4><ul>
<li>1、程序组织：首先要以概括的形式将有关系的系统做出分解和概述。定义程序的主要的构造块，更具程序规模不同，每一个构造块可以是单个类也可以是子系统等，各自实现一种高层功能，相互协调产生了系统。</li>
<li>2、主要类：应当较为详细的定义主要类。80&#x2F;20法则，对于构成80%行为的20%的类进行详细说明。</li>
<li>3、数据设计：应当描述主要文件与数据表的设计。包括设计某种模式（数据结构与算法）的原因与考虑点等，以方便后期的维护。</li>
<li>4、业务规则：关于业务内特定的业务逻辑，以及对于系统的设计影响。</li>
<li>5、用户界面设计</li>
<li>6、资源管理：对于稀缺资源的管理计划，包括数据库链接、线程、内存等整体的规划。</li>
<li>7、安全性：设计实现设计层面与代码层面的安全性问题。比如处理缓冲区方法，处理未经处理数据（用户输入、cookie、配置数据等）的规则，加密，错误处理程度等事宜。</li>
<li>8、性能：评估数据量，复杂程度以确定系统达到性能目标。</li>
<li>9、可伸缩性：系统增长、扩展在系统各方面满足未来的能力。</li>
<li>10、互用性：系统与其他软硬件的共享数据或者资源。</li>
<li>11、国际化&#x2F;本地化</li>
<li>12、输入与输出：定义数据的读取策略，以及错误检测的处理位置。</li>
<li>13、错误处理：由于错误处理牵扯整个系统，最好在架构层次上对待明确。</li>
<li>14、容错性：定义所期望的所有容错类型，作为增强系统可靠性的方式，包括错误检测以及错误回复等。</li>
<li>15、架构的可行性：关注系统的各项能力是否符合标准，比如性能目标、资源与环境支持度等。</li>
<li>16、过度工程：健壮性表示系统检测到错误后继续容错运行的能力。架构时需要明确，是应该做出最简单的能工作的东西还是为了机身起见宁可过度工程。避免系统中某些类异常健壮，而其他类勉强健壮。系统的强度不是取决于最薄弱的环节，而是所有薄弱环节的乘积。</li>
<li>17、关于买还是造的决策：最激进的构建解决方案就是更不不去构建，直接购买或者使用开源软件。其取决的条件在于我们自己定制的组件，应该在某些方面胜过现成的程序库和组件，并且收益与成本是正向的。</li>
<li>18、复用决策：如何复用软件的加工使之符合其他架构的目标</li>
<li>19、变更策略：应列出有可能的增强性的功能，并且考虑其扩展接入的方式。</li>
<li>20、架构的总体质量：<br>优秀的架构文档特点在于，讨论系统中的类，每个类背后的隐藏信息，各类方案采纳或者被替换的根本理由等。架构应该是带有少许特别附加物的精炼且完整的概念体系。是《人月神话》的中心主题。<br>优秀的软件架构和机器与语言无关，应当明确指出风险并且解释，多个视角看待项目。不应当包含任何对你而言难以理解的东西。</li>
</ul>
<h1 id="创建高质量的代码"><a href="#创建高质量的代码" class="headerlink" title="创建高质量的代码"></a>创建高质量的代码</h1><h2 id="软件构建中的设计"><a href="#软件构建中的设计" class="headerlink" title="软件构建中的设计"></a>软件构建中的设计</h2><p>许多软件构建的设计就是程序员在键盘前完成的，或许用伪类写出一个类的接口，或许编码前画一下几个类的关系图，也可能咨询你下更有经验的程序员。无论何种方式进行，如果能认识到设计在程序员侧也是一项明确的活动，那么我们将受益匪浅。</p>
<p>软件的设计目标是组织良好，干净利落。然而形成的过程却可能了无章法。或许设计时就会犯很多错，但是这正是关键所在，设计阶段的犯错并且加以改正，其代价远远小于编码后发现错误改正的成本。这正是我们所期望的。</p>
<p>软件构建的设计就是确定取舍，调整顺序的过程，并且收到较多的限制，在各类限制条件中寻求方案的过程。是类似启发式，不确定的一个过程，然后自然而然形成的。</p>
<h2 id="关键的设计概念"><a href="#关键的设计概念" class="headerlink" title="关键的设计概念"></a>关键的设计概念</h2><p>软件的首要技术使命：管理复杂度</p>
<p>《没有银弹：软件工程中本质性与偶然性》Fred Brooks（《人月神话》的作者）。</p>
<p><strong>偶然的难题与本质的难题</strong></p>
<p>Fred Brooks 引用了一个哲学的概念来说明：本质属性是一件具体事物必然具备的属性。偶然属性则表示一件事物恰好具备来某些属性。</p>
<p>类似与软件开发，其中大部分偶然性难题在很多已经被解决。比如一些与笨拙语法相关的偶然性难题，基本随着语言的迭代与发展被清晰的解决处理，那么显然这些问题的重要性也会逐渐下降，比如早期低端操作系统的各类问题。但是剩下的本质性问题，相对解决的比较缓慢。</p>
<p>本质上来说，软件开发意味着不断的去发掘复杂的、相互链接的一套系统的所有细节。本质性的困难来自多方面：面对复杂和无序的现实世界、精确并且完整的识别依赖与特例、设计准确性高的解决方案而非一般方案、并且人类对于认识现实世界本身都还有很大困难，那么基于此的软件开发来解决大规模的现实问题，难度可想而知。</p>
<p>但是，不论是偶然性问题还是本质性问题，其触发的根源都在与 复杂度。</p>
<p><strong>管理复杂度的重要性</strong></p>
<p>在做项目失败的原因确认时，很少会将技术原因作为项目失败的主要原因。或许是不尽人意的需求、规划或者管理。但是如果确定是技术原因导致的失败，那么一定是失控的复杂度。软件变得极端复杂，开发者无从知晓模块的功能、逻辑等，完全无法维护的状态，那么项目就估计快停了。</p>
<p>所以说，在作者看来：软件的首要技术使命便是管理复杂度。</p>
<p>类似我们的大脑，软件开发人员不应该尝试在同一时间将整个持续程序塞进去，而是应该试着以某种合理的方式去组织程序，以便在任意一个时刻，我们都是专注于某一个特定的部分，减少时间点上所需要考虑的程序量级。</p>
<p>例如：将系统分解为多个子系统，各项子系统之间减少互相依赖。保持子系统的短小精悍也有助于减少思考的负担。从问题入手而不是直接从底层去实现细节编程，在最抽象的层次工作。</p>
<p><strong>高代价、低效率问题</strong></p>
<ul>
<li>1、复杂的方法解决简单的问题</li>
<li>2、简单但是错误的方法解决复杂问题</li>
<li>3、不恰当的方法解决复杂问题</li>
</ul>
<p>类似编写一个基础函数，开发者应该首先明确这是基于固定场景的，还是基于当前系统基础的，还是准备开源做到较多形式的支持的。都会影响我们对于当前函数、参数、细节实现的复杂度确定。</p>
<p>那么，将同一时间需要处理的本质复杂度降低到最小，并且不要让偶然性的复杂度无所谓的快速增长是一个不错的方式。</p>
<ul>
<li>1、最小的复杂度。设计的主要目标是降低复杂度，避免做出自认为聪明的设计，往往聪明的设计会难以理解。</li>
<li>2、易于维护。开发过程中，应当不断考虑逻辑、细节对于后期维护人员是否会产生负担，更多的产出可自说明的系统。</li>
<li>3、松散耦合。在设计时，让各个组成部份关联最小。通过合理的抽象、封装、隐藏信息等进行优化，减少关联依赖，并且对于强关联的逻辑业务能合理的设计与处理。</li>
<li>4、可扩展性。增强系统能力而无需破坏基础结构，通过改动某一部分而不影响系统其他部份。</li>
<li>5、可重用性。系统的组成部份能在其他系统中复用。</li>
<li>6、高扇入与低扇出。让大量的类使用某个给定的类，意味着很好的利用了较低层次上的工具类。一个类内少量或者适中的使用其他类减小过分依赖与复杂。</li>
<li>7、可移植性。相对于系统能较方便的迁移至其他环节。</li>
<li>8、精简性。系统没有多余的部份来添加成本。</li>
<li>9、层次性。尽量保持系统各个分解层的层次性，使我们可以在各层次上观测系统。</li>
<li>10、标准技术。制定系统的标准化、常用的方法等。如基础技术栈，基础函数库等。</li>
</ul>
<h2 id="设计构造块：启发式方法"><a href="#设计构造块：启发式方法" class="headerlink" title="设计构造块：启发式方法"></a>设计构造块：启发式方法</h2><p><strong>找出现实世界的对象</strong></p>
<p>辨识对象，以及其属性。确定对象可进行的操作以及可对其他对象进行的操作。对象各部分的公有、私有属性。开放的公共接口。</p>
<p><strong>形成一致的抽象</strong></p>
<p>抽象是让你在关注某一概念的同时可以放心的忽略其中一些细节的能力。类似与可以在不同层次处理不同的细节。如我们把一类东西成为房屋，而不是玻璃、木材、钢筋等组合体，就相当于是在抽象的表现来。</p>
<p>基类也是抽象，集中注意力关注一组派生类的共同特性，在此基础上去忽略派生类的其他的一些细节。很大程度上，抽象能让我们在复杂的状态下专注于某些点，忽略无关的细节，降低思考上的复杂度。</p>
<p><strong>封装实现细节</strong></p>
<p>封装是对于抽象的补充，很多抽象不关注的细节，我们就可以使用封装来进行处理，隐藏重要性不高的一些复杂度上的细节。</p>
<p><strong>继承简化设计</strong></p>
<p>继承的好处在于可以很好的支持抽象的概念，继承简化编程工作，你可以写一些子程序拥有基本属性的项，然后另一些处理依赖基本类的特定的类。</p>
<p><strong>信息隐藏</strong></p>
<p>信息隐藏是结构化程序和面向对象设计的基础之一。也是首要技术使命中重要的启发式方法，其强调的就是隐藏复杂度。</p>
<p>设计一个类，一项关键性的决策就是确定类那些特性应该对外可见，哪些特性应该隐藏。好的类接口应该犹如冰山，让类的大部分内容不会暴露。</p>
<p>1、隐藏复杂度，我们一般情况就无需关注细节的复杂度<br>2、隐藏变化源，变化影响限制在固定范围内。</p>
<p><strong>找出容易改变的区域</strong></p>
<p>好的程序设计面临的重要的挑战就是适用变化，目标应该将不稳定区域隔离，将变化带来的影响限制在一个子程序或者一个类的内部。使得系统内你能考虑到的变化的可能性与其影响范围成反比。</p>
<p><strong>保持松散耦合</strong></p>
<p>耦合度表示类或者子程序之间关系的紧密程度。其设计目标是创建出小的，直接的，清晰的类或者子程序，使之间的关系尽量灵活，即松散耦合。</p>
<p>耦合的种类：</p>
<ul>
<li>1、简单数据参数耦合：两个模块通过参数来传递数据，并且参数均为简单数据类型。耦合关系正常，可接受。</li>
<li>2、简单对象耦合：为模块实例化出的一个对象，两者的关系。该耦合关系也是正常的。</li>
<li>3、对象参数耦合：传递数据的参数为对象，那么调用方需要了解参数对象的细节，那么相对来说耦合关系会紧密一些。</li>
<li>4、语义上的耦合：最复杂的耦合关系，两者间不仅使用来语法上的逻辑，还是用了模块内部工作细节。</li>
</ul>
<p>如：</p>
<ul>
<li>1、M1向M2传递一个控制标识，告诉M2来做什么。那么就需要M1对M2内部工作细节有所了解，对于控制标识是如何使用的。</li>
<li>2、M2在M1修改来全局变量或者闭包数据后使用数据。这就需要M2对M1数据的修改都符合M2的需求。</li>
<li>3、M1要求在调用M1.B()时必须先进行初始化 M1.A()，而M2知道内部逻辑，在调用M1.B() 时必然会调用初始化，所有直接调用M1.B()。</li>
</ul>
<p><strong>设计模式</strong></p>
<p>常见的设计模式：适配器、桥接、装饰器、工厂方法、观察者、单例、策略等。</p>
<p>设计模式通过现成的抽象来减少复杂度。将常见的解决方案细节予以制度化来减小出错。并且通过多种设计方案带来启发性的价值。以及将设计对话提升到更高层次上来简化交流。</p>
<p>设计模式潜在的陷阱是：强迫代码适用某个模式，如果对于代码做微笑的调整来符合某种通用的模式，可以使得代码梗易于理解，但是如果做巨大改动，强迫去符合某个标准模式，反而会增加复杂度。</p>
<p>设计模式是一种强大的管理复杂度的工具，但是不要为了模式而模式。</p>
<p><strong>其他启发式方法</strong></p>
<p>高内聚性、构造分层结构、严格描述类说明、分配指责、画一个图、保持设计的模块化等。</p>
<h2 id="可以工作的类"><a href="#可以工作的类" class="headerlink" title="可以工作的类"></a>可以工作的类</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型指一些数据以及这些数据所进行的操作的集合。把其定义为有一组操作的数学模型太过空洞。将链表中添加一个节点，你可以看做表中插入单元格，火车模型添加车厢等形象问题。</p>
<p>比如编写的程序内，可以使用不同的系统字体、字号以及文字属性的功能，如果我们将其作为一个抽象数据类型，那么我们就可以将设置的数据值以及相关的设置操作作为一个抽象数据类型进行考虑可管理。（可以看做如何抽象一个子程序的逻辑）</p>
<p>一般业务逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFont.size = 16;</span><br><span class="line">currentFont.bold = true;</span><br></pre></td></tr></table></figure>

<p>抽象数据类型: 子程序代码或许很短，但是你将字体的各类操作进行了独立与隔离，这样就为其他部分程序提供了更好的抽象。对于字体操作提供一层保护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentFont.setSize(16);</span><br><span class="line">currentFont.setBoldOn();</span><br><span class="line">currentFont.setBoldOff();</span><br></pre></td></tr></table></figure>

<ul>
<li>1、隐藏实现细节</li>
<li>2、该抽象上的改动不影响整个持续</li>
<li>3、关注点更聚焦，提供相关联的依赖接口</li>
<li>4、更易提高性能</li>
<li>5、程序的正确性更显而易见</li>
<li>6、程序更具有自我说明性</li>
<li>7、数据传递与依赖更小化</li>
<li>8、操作实体而无需关心底层实现上的操作</li>
</ul>
<h3 id="良好的类接口"><a href="#良好的类接口" class="headerlink" title="良好的类接口"></a>良好的类接口</h3><p>创建高质量的类，第一步就行创建一个好的接口，通过接口合理的展现和隐藏抽象。主要的评估方法为类所具有的公共子程序所构成的集合，即类的公共接口的合理性。</p>
<ul>
<li>1、类的接口的抽象层次应该是一致的。比如对于雇员列表的雇员添加与删除，获取指定的雇员信息等，对于雇员类来说设计获取其相关信息而非同一层上的抽象。</li>
<li>2、需要明确我们抽象的是什么，需要处理的问题是什么，才能较好的梳理出合理的接口。</li>
<li>3、提供成对的服务，比如字体开启与关闭加粗模式等。</li>
<li>4、接口可编程而非表达语义。每个接口都应该是可编程部份+语义部份组成，可编程部份可做相关的检测判定。</li>
<li>5、注意与接口抽象不一致的公共成员。</li>
<li>6、抽象性和内聚性考虑。</li>
</ul>
<p><strong>良好的封装</strong></p>
<p>封装是一个比抽象更强的概念，如果没有封装，抽象很容易就被打破，无法较好的实现。</p>
<ul>
<li>1、尽可能限制类和成员的可访问性</li>
<li>2、不要公开成员数据</li>
<li>3、避免私有的实现细节放在接口中</li>
<li>4、不要对于使用类的开发者做任何假设</li>
<li>5、让阅读代码比编写代码更容易</li>
<li>6、注意语义上的封装性的破坏</li>
<li>7、注意耦合关系</li>
</ul>
<h3 id="设计与实现的问题"><a href="#设计与实现的问题" class="headerlink" title="设计与实现的问题"></a>设计与实现的问题</h3><p><strong>继承</strong></p>
<p>继承表示一个类是另一个类的一种特化。其目的在于『定义能为两个类或者更多派生类提供共有元素的基类』，来精简代码。</p>
<ul>
<li>1、继承增加程序复杂度，所有必须详细说明或者不使用。</li>
<li>2、确保我们只是继承需要的部分。</li>
<li>3、将公共的接口、数据以及操作放到较高位置。</li>
<li>4、只有一个实例的类和只有一个派生类的基类需要重新评估创建的类必要性。</li>
<li>5、避免继承体系过深，以及多态导致大量的类型检查。</li>
</ul>
<p><strong>继承的规则</strong></p>
<ul>
<li>1、多个类共享数据而非行为，应该创建公共对象。</li>
<li>2、多个类共享行为而非数据或者共享数据以及行为时，应该让类从共同的基类继承而来，基类定义公用的子程序以及数据。</li>
</ul>
<p><strong>构造函数</strong></p>
<ul>
<li>1、如果可以，在构造函数中初始化所有数据成员。</li>
<li>2、优先使用深拷贝，除非论证可行才使用浅拷贝。</li>
</ul>
<h4 id="创建类的原因"><a href="#创建类的原因" class="headerlink" title="创建类的原因"></a>创建类的原因</h4><ul>
<li>1、为现实世界中的对象建模。为现实世界每一个对象类型建模是一个重要的理由。</li>
<li>2、为抽象对象建模。比如经典的 Shape（形状）对象，及其派生的 Circle、Square等。</li>
<li>3、降低复杂度。降低软件首要使命的难度，创建类后隐藏信息和细节，使我们无需再去考虑。</li>
<li>4、隔离复杂度。隔离复杂的算法、大型数据集、复杂的各类协议等容易引发错误的点，分类集中管理。</li>
<li>5、隐藏实现细节。对于软件，我们不可能存入整个细节图，而是分块，分层的处理。</li>
<li>6、限制变动的影响范围。</li>
<li>7、隐藏全局数据。</li>
<li>8、参数传递顺畅。</li>
<li>9、建立中心控制点。</li>
<li>10、代码易于重用。</li>
<li>11、相关操作分类。</li>
</ul>
<h2 id="高质量的子程序"><a href="#高质量的子程序" class="headerlink" title="高质量的子程序"></a>高质量的子程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line"></span><br><span class="line">void Handlestuff(CORP_DATA &amp; inputrec, int crntqtr, EMP_DATA emprec, double &amp; estimrevenue, double ytdrevenue, int screenX, int screenY, COLOR_TYPE &amp; newcolor, COLOR_TYPE &amp; prevcolor, StatusType &amp; status,</span><br><span class="line">int expensetype)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i＝0; i＜100; i++) &#123;</span><br><span class="line">    inputrec.revenue[i] = 0;</span><br><span class="line">    inputrec.expense[i] = corpexpense[ crntqtr ][ i ];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">UpdateCorpDatabase( emprec );</span><br><span class="line">estimrevenu =  ytdrevenue * 4.0 / (double) crntqtr;</span><br><span class="line">newcolor= prevcolor;</span><br><span class="line">status = SUCCESS;</span><br><span class="line">if (expensetype == 1) &#123;</span><br><span class="line">    for(i＝0;i＜12;i++) &#123;</span><br><span class="line">        profit[i] = revenue[i] -expense.type1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">else if (expensetype == 2 )&#123;</span><br><span class="line">    profit[i] = revenue[i] - expense.type2[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (expensetype == 3)&#123;</span><br><span class="line">    profit[i] = revenue[i] - expense.type3[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码有什么样的问题，有一些很明显的问题，还有一些我们没注意，自己也经常犯的问题。</p>
<p>1、命名较差，完全不清楚子程序是干什么的<br>2、没有文档说明<br>3、缩进布局很差<br>4、输入变量 inputrec 被重写<br>5、读写全局变量 profit<br>6、子程序没有单一的目的，初始化重写输入，更新数据库，计算，重写全局变量，完全无相关联系的操作。<br>7、缺少防御性 crntqtr &#x3D; 0 时的问题<br>8、各类神秘数值 100、4.0、12、1、2、3等<br>9、未使用的参数 screenX、screenY<br>10、参数过多，建议上线为7<br>11、参数顺序混乱无注释</p>
<p>创建一个子程序有很多合理的原因，但是完成它的方式却分对错。</p>
<h3 id="创建子程序的理由"><a href="#创建子程序的理由" class="headerlink" title="创建子程序的理由"></a>创建子程序的理由</h3><ul>
<li>1、降低复杂度，因为我们软件工程的首要技术使命就是管理复杂度。</li>
<li>2、引入中间、易懂的抽象，比如哗啦啦写了一堆逻辑处理代码，或者将其放到子程序中，命名：GetLeafName。</li>
<li>3、避免代码重复，这是创建子程序的最普遍的原因。</li>
<li>4、支持子类化，覆盖简短而规整的子程序所需要的代码比冗长邋遢的代码要少，并且减少犯错。</li>
<li>5、隐藏顺序，将细节执行顺序集中隐藏，而非到处散布。</li>
<li>6、隐藏指针操作。</li>
<li>7、提高可移植性。子程序隔离不可移植部份明确移植的兼容开发。</li>
<li>8、简化复杂的布尔判断。为理解程序的流程，通常没有必要去研究那些复杂的布尔判定的细节，将其放到子函数中提高整体可读性。</li>
<li>9、改善性能。子程序可以是我们集中一处单一功能点进行优化，并且使用更高效的算法和更快的语法也更容易调整。</li>
</ul>
<p>编写子程序较大的心理障碍是：不情愿为一个简单目的而写一个简单的子程序，看起来大材小用，并且比较低端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一个简单的 deviceUnits 到 points 单位转换</span><br><span class="line">points = deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() )</span><br><span class="line"></span><br><span class="line">// 封装子程序后</span><br><span class="line">function deviceUnitsToPoints(deviceUnits) &#123;</span><br><span class="line">    return deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() );</span><br><span class="line">&#125;</span><br><span class="line">points = deviceUnitsToPoints(deviceUnits);</span><br></pre></td></tr></table></figure>
<p>封装子程序后，那么很多使用改转化的地方都可以统一使用子程序，进行集中管理。应对以后转化会变得更复杂的情况（比如对于 DeviceUnitsPerInch 的调用判定等 ）。并且子程序的命名是我们可以忽略执行细节让代码具有自我注解的能力。</p>
<h3 id="子程序的设计"><a href="#子程序的设计" class="headerlink" title="子程序的设计"></a>子程序的设计</h3><p>对于子程序而言，内聚性指子程序中各种操作之间联系的紧密程度，目标是让每一个子程序只把一件事情做好。</p>
<p>功能的内聚性：是最强最好的一种内聚性，让一个子程序只执行一项操作。我们可以观察到很多系统底层或者语言底层的基础子程序基本都是功能内聚的。</p>
<p>不够理想的：</p>
<p>顺序上的内聚性：指子程序内包含需要按顺序执行操作多个功能，按步骤共享数据的。建议按功能拆分解耦。</p>
<p>通讯上的内聚性：仅仅是子程序内不同操作使用的想同的数据，但操作不存在任何联系的。</p>
<p>临时的内聚性：一些因为需要同时执行才放到一起的子程序。比如我们在编写完一个大而冗余的代码时，加个init初始化函数，然后一股脑的吧开始需要执行的代码扔进来。临时性的子程序应当看做一系列时间的组织者，init可以包含读取配置文件，初始化数据等操作的管理者。应当明确内部的执行意义。</p>
<p>不可取的：过程上的内聚性，逻辑上的内聚性，巧合的内聚性。</p>
<h3 id="好的子程序名字"><a href="#好的子程序名字" class="headerlink" title="好的子程序名字"></a>好的子程序名字</h3><p>1、描述子程序所做的所有事情。ComputeReportTotals 还不算完整，ComputeReportTotalsAndOpenOutputFile 算是完整，但是太长。如果子程序含有副作用，那么就会产生又笨又长的名字</p>
<p>2、避免无意义、模糊或者表达不清的动词。HandleCalculation, OutputUser, DealWithOutput 这类的是完全无法说明程序做了什么，达不到自我注解的程度。比如将 DealWithOutput 改为 FormatAndPrintOutput 就明了很多。</p>
<p>3、不要通过数字来形成不同的子程序。</p>
<p>4、控制子程序名字的长度，变量名一般建议9-15字符，好的子程序名字可以更长一些，视是否清晰易懂而定。</p>
<p>5、对返回值有所描述。cos(), userID.next(), printer.isReady() 等都是不错的例子。</p>
<p>6、给过程起名格式建议动词+宾语的形式。过程应当反应所做的事情。如printDocument(), checkOrderInfo()等，面向对象中则为 document.print()。</p>
<p>7、使用对账词。add&#x2F;remove, insert&#x2F;delete, open&#x2F;close, show&#x2F;hide, create&#x2F;distroy 等。</p>
<p>8、为常规操作确定规则。统一 employee.id(), employee.get(), employee.getId()等不一致。</p>
<h3 id="子程序长度"><a href="#子程序长度" class="headerlink" title="子程序长度"></a>子程序长度</h3><p>如果一个子程序大于200行，我们可能需要注意，是否会影响我们的维护成本。</p>
<h3 id="子程序参数"><a href="#子程序参数" class="headerlink" title="子程序参数"></a>子程序参数</h3><p>比如使用所有参数，状态或者出错变量放置最后，不要把参数作为工作变量，数量限制在7个以内等。</p>
<h2 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h2><p>主要思想是：子程序不应该因传入错误数据而被破坏，哪怕是其他子程序产生的错误数据。健壮模式应该检查所有外部的数据源以及子程序的参数，并且确定如何处理错误的输入。</p>
<h3 id="错误处理技术"><a href="#错误处理技术" class="headerlink" title="错误处理技术"></a>错误处理技术</h3><ul>
<li>1、返回中立值。处理错误最佳的方式是继续执行操作，简单返回一个无危害的数值。</li>
<li>2、换用下一个正确的数据。比如处理数据流时，继续读取知道正确的数据。</li>
<li>3、警告信息记录日志。</li>
<li>4、返回错误码。指定统一的错误码表进行处理。</li>
<li>5、调用错误处理子程序或者对象。统一标准化处理错误情况。</li>
<li>6、显示出错信息。</li>
<li>7、局部处理错误。这个模式给予程序员很大的灵活度但是也带来很大分险。</li>
<li>8、关闭程序。</li>
</ul>
<p>正确性意味着永远不返回不准确的结果，哪怕不返回结果。健壮性意味着不断的尝试采取措施保障软件继续运行下去，哪怕一些结果不准确。人身安全攸关的更倾向于正确性而非健壮性，比如放射性治疗仪。消费类软件则注重健壮性而非正确性，我们并不期望因为数据的错误直接关闭软件的形式。</p>
<h3 id="防御式编程的姿态"><a href="#防御式编程的姿态" class="headerlink" title="防御式编程的姿态"></a>防御式编程的姿态</h3><p>防御式编程存在一种矛盾，开发阶段希望错误引人注意，而发布阶段尽可能的偃旗息鼓。</p>
<p>保留那些检查重要错误的代码，去除细节错误检查的代码，去除导致崩溃的代码，记录错误信息。</p>
<p>过度防御式编程也会引发问题，如果每一个地方使用所有的方法检测参数数据，那持续将变得臃肿而缓慢以及无止境的提高了程序的复杂度。所有考虑好那些地方需要进行防御以及因地制宜的调整防御式编程的优先级。</p>
<h2 id="伪代码编码过程"><a href="#伪代码编码过程" class="headerlink" title="伪代码编码过程"></a>伪代码编码过程</h2><p><img src="http://image.freefe.cc/Snipaste_2019-06-09_13-48-33.png" alt="image"></p>
<p>创建类的总体设计：定义类的职责，所有需要隐藏的信息，精确的定义类的接口等各类信息。<br>创建类中的子程序：创建需要的子程序，在过程中可能还会引出各类重要的不重要的子程序等。<br>复审并测试整个类：对类进行整体测试以发现在该类层面的问题。</p>
<p>子程序的实现基本都是简单、直接了当的。</p>
<p>伪代码指某种用来描述算法、子程序、类或者完整程序的工作逻辑，非标准的记法。伪代码编程过程通过书写伪代码而更高效的创建程序代码的方法。</p>
<p>1、用英语或者其他语言来精确描述特定操作。<br>2、避免使用特定的语言中的语法，在一个比代码层次略高的层面上设计。<br>3、在基于真正的目的层面上编写伪代码</p>
<p>伪代码逻辑完毕后，我们应该可以基于此来实现生成代码，同时可以将伪代码转化为注释，更好的解释说明代码的用意。</p>
<p>1、这类模式的伪代码使我们项目、代码评审变得更为容易。<br>2、伪代码支持反复的迭代精华思想。<br>3、伪代码是我们变更更加容易。<br>4、使代码的注释工作变得更少。<br>5、比其他形式的设计文档更易于维护。</p>
<h3 id="编写子程序"><a href="#编写子程序" class="headerlink" title="编写子程序"></a>编写子程序</h3><p><img src="http://image.freefe.cc/2019-06-09_14-25-38.png" alt="image"></p>
<p>首先写出子程序接口声明。将首尾语句填充（函数申明，大括号区域等）并且将伪代码变为注释。虽然还没有任何代码，但是通过注释能理解整体的工作流程。而后填充代码以及编码工作。开发过程中，期间不断以及验证工作，最后进行收尾工作。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>利用构建活动来填补需求以及架构中存在的细小间隙问题是一种行之有效的做法。但是将蓝图设计精细到完全展现出细节则是一种低效的做法。构建活动中基础的组成就是变量的使用。变量同时指代对象和内置数据类型。</p>
<p><strong>隐式声明</strong></p>
<p>隐式变量声明对于任何一种语言都是最具危险的特性。关闭隐式声明，声明全部变量是一种避免问题的很好的做法。</p>
<p><strong>变量初始化原则</strong></p>
<p>不可理初始化数据是产生编程问题常见根源之一。</p>
<p>1、在声明时初始化，作为常用的防御式编程便捷有效的方法之一。<br>2、理想情况，在靠近变量第一次使用的位置申明以及初始化。集中申明的方式更容易出错，易于集中管理却并不易于维护。<br>3、尽可能使用final或者const。在一些明确的情况下，明确申明类型能减少维护的复杂度。<br>4、注意计数器与累加器的变量。<br>5、类的构造函数内初始化数据成员。易于管理降低复杂度以及方便底层的内存管理等。<br>6、设置编译器自动初始化以及其警告信息。</p>
<p><strong>作用域</strong></p>
<p>作用域或者可见性指的是变量在程序内的可见与可引用范围。各类语言处理方式肯不太一样。</p>
<p>介于同一变量多个引用点之间的代码，可称为攻击窗口。窗口内的操作就有可能引发变量北重置等问题。</p>
<p>把变量的引用点集中起来能较好的提高程序的可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// e.g. 1</span><br><span class="line">a = 0;</span><br><span class="line">b = 0;</span><br><span class="line">c = 0;</span><br><span class="line">a = b + c; // a跨度2 b跨度1 c跨度0</span><br><span class="line"></span><br><span class="line">// e.g. 2</span><br><span class="line">a = 0;</span><br><span class="line">b = 0;</span><br><span class="line">c = 0;</span><br><span class="line">b = a + 1;</span><br><span class="line">b = b / c; // b平均跨度 0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://image.freefe.cc/2019-06-09_16-14-04.png" alt="image"></p>
<p>与跨度类似，保持较低的存活时间也是我们的目标，原因与最求较小跨度一致，保持短的存活时间主要也是缩短攻击窗口。降低修改代码对其的影响降低。</p>
<p><strong>减小作用域的原则：</strong></p>
<ul>
<li>1、循环开始时初始化循环使用的变量。</li>
<li>2、变量使用之前再申明赋值。</li>
<li>3、将相关语句集中在一起。</li>
<li>4、将相关语句组提取成单独的子程序。</li>
<li>5、开始使用最严格的可见性，然后更具需要扩展变量作用域。</li>
</ul>
<p>有的程序员将很多变量放置到全局中，因为全局变量使用最为方便，无需考虑作用域相关的规则。其他程序员尽可能的使用变量局部化，有助于提高智力上的可管理性。『方便性』和『智力可管理性』两种理念归根结底是侧重写程序还是读程序。当然我们需要侧重的点是显而易见的。</p>
<h3 id="变量名的力量"><a href="#变量名的力量" class="headerlink" title="变量名的力量"></a>变量名的力量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// e.g. 1</span><br><span class="line">x = x - xxx;</span><br><span class="line">xxx = fido + salesTax( fido );</span><br><span class="line">x = x + lateFee( x1, x ) + xxx;</span><br><span class="line">x = x + interest( x1, x );</span><br><span class="line"></span><br><span class="line">// e.g. 2</span><br><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + salesTax( newPurchases );</span><br><span class="line">balance = balance + lateFee( customerID,  balance) + monthlyTotal;</span><br><span class="line">balance = balance + lateFee( customerID,  balance);</span><br></pre></td></tr></table></figure>

<p>很显而易见的一个好的变量名对于可读性、易记性是多么重要。当然变量名需要完全、准确的描述变量所代表的事物。</p>
<p>对于日期，currentDate 和 todaysDate都是较好的名称，直白准确的描述。而current，date其实稍微推敲则并没有明确当前，和日期到底是想描述什么。</p>
<p>一个好的变量名应该是从『what』出发，而不是『how』。一条员工数据可以称作inputRec或者employeeData，inputRec表示一个输入，记录的的计算机概念术语，而employeeData直指问题领域，与计算机无关。</p>
<p><strong>特定类型的数据命名</strong></p>
<p><strong>循环下标命名：</strong><br>i，j，k已经是约定俗成的。如果需要在循环外或者是较复杂的循环，那么就需要使用一个有意义的命名。</p>
<p><strong>状态变量命名：</strong><br>去一个比flag更好的名字。如果你发现你需要去猜测某段代码时，就该考虑变量的重新命名。猜测谋杀案谁是凶手是ok的，但是猜测代码应该是完全没有必要。</p>
<p><strong>临时变量命名：</strong><br>临时变量也不光应该只是 temp，或者x等模糊缺乏描述性的名字。</p>
<p><strong>布尔变量命名：</strong><br>使用有用的标识，done、error、found、success或者ok等明确的布尔标识。并且尽量使用肯定布尔名，反例 notFound，notDone。<br>尽量赋予真假的含义，部份喜欢添加is，isdone、isFound、isComplete等，优点在于可以将模糊不清的名词，isStatus，缺点在于降低了逻辑表达式的可读，if(isFound) 与 if(found)。</p>
<p><strong>非正式的命名规则</strong></p>
<ul>
<li>1、区分变量名与子程序名字</li>
<li>2、区分类与对象</li>
<li>3、标识全局变量</li>
<li>4、表示成员变量</li>
</ul>
<p>按实际变量名命名含有三类信息：变量内容是什么，数据的种类以及变量的作用域。【标准化的前缀，通用的缩写】</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基础数据类型是构建其他所有数据类型的构造块。</p>
<p><strong>整数</strong><br>注意整数除法。7 &#x2F; 10 &#x3D; 0（JS中数值均为浮点型）。注意整数的溢出。注意中间值的溢出。</p>
<p><strong>浮点数</strong><br>主要问题在于十进制小数不能够精确的用数字计算机中的1与0来表示。避免量级差较大数之间的加减运算，避免等量判断等问题。</p>
<p><strong>字符和字符串</strong><br>注意一些特殊字符，了解你的语言是如何支持Unicode，国际化&#x2F;本地化策略的考虑。</p>
<p><strong>布尔变量</strong><br>使用布尔变量对程序加以文档说明，简化判定逻辑代码。</p>
<p><strong>数组</strong><br>数组需要注意下标边界，多维数组的下标使用顺序等</p>
<h3 id="不常见的数据类型"><a href="#不常见的数据类型" class="headerlink" title="不常见的数据类型"></a>不常见的数据类型</h3><p><strong>结构体</strong></p>
<ul>
<li><p>1、用结构体明确数据关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 容易误解的，无组织的</span><br><span class="line">name = inputName</span><br><span class="line">address = inputAddress</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 对象结构体</span><br><span class="line">employee.name = inputName</span><br><span class="line">employee.address = inputAddress</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>2、简化数据块的操作：传递一批相关数据 or 传递一个包含所有数据的结构体 </p>
</li>
<li><p>3、简化参数列表</p>
</li>
<li><p>4、减少维护：后期删除某一字段，如果是结构体内的，相对就会比较便捷</p>
</li>
</ul>
<p><strong>指针</strong></p>
<p>概念上看，指针包含：内存的某处位置和解释改位置中的内容。</p>
<p><strong>全局数据</strong><br>使用全集数据的风险远大于使用局部数据的情况。</p>
<ul>
<li>1、不经意间修改了全局数据</li>
<li>2、全局数据的使用阻碍代码复用</li>
<li>3、全局数据的使用导致模块代码非确定性的初始化</li>
<li>4、破坏了模块化和智力上的可管理性：其将原本的模块化，集中精力管理一点的模式牵扯到来其他模块。</li>
</ul>
<p>避免使用全局变量，不只是因为它很危险，更由于我们可以使用更好的方法来取代。比如访问器子程序。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="直线型代码"><a href="#直线型代码" class="headerlink" title="直线型代码"></a>直线型代码</h3><p>从数据为中心 转到语句为中心的观点上来。直线型代码的原则就是：按照依赖关系进行排列组织代码，使用好的子程序名、参数列表、注释、变量等，将顺序的关系变得明显，并且利用注释 换行等，将我们的直线型代码更可读、分块更明显。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p><strong>if语句</strong></p>
<p>首先书写正常代码路径，再处理不常见的情况。确保等量的边界判定正确。将正常的情况放在if后面，而非else。并且if内逻辑应当有意义。较多的if else判定建议使用switch等其他结构。</p>
<p><strong>case语句</strong></p>
<p>应使用最有效的排序，简化每个case的操作量。default应该只是检查真正的默认情况或者错误情况。</p>
<h3 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h3><p>循环用来指代任意一种迭代控制结构，使用循环是编程中最复杂的方面之一。也是创建高质量软件的一个决定性因素。</p>
<p><strong>循环的种类</strong></p>
<p>-** 计数循环**：逻辑代码执行次数一定，比如发放每位职员的薪资。</p>
<ul>
<li><strong>连续求值循环</strong>：不确定执行次数，每次执行时检测是否执行完毕。使用场景：一些特殊的条件判定循环，实现不知晓执行的次数，状态由动态变量控制。检测位于头部或者尾部。</li>
<li><strong>无限循环</strong>：启动后无限循环。比如心脏起搏器等</li>
<li><strong>迭代器循环</strong>：对于容器内的每一元素执行，比如一些标准或者类库支持点forEach等</li>
</ul>
<p>主要为灵活度的差异与检测是否执行完毕的位置有所差异。两者也决定了使用哪种循环。for循环使用于简单的用途，你在循环头中写完便可以忘却的不需要再关心的可是使用for，而如果存在一个必需是执行从循环中跳出的那边建设使用while。</p>
<p><strong>循环控制</strong></p>
<p>引发错误的情况：</p>
<ul>
<li>1、忽略或者错误的对循环执行初始化</li>
<li>2、忽略了对累加变量或者其他循环有关的变量执行初始化</li>
<li>3、不准确的嵌套和循环中止</li>
<li>4、错误的增加了循环有关的变量值</li>
<li>5、不准确的循环下标访问</li>
</ul>
<p>两种减少循环问题点方式：</p>
<ul>
<li>1、减少影响循环的因素数量，简化、简化、再简化。</li>
<li>2、将循环内部作为子程序。</li>
</ul>
<p><strong>循环三部分</strong></p>
<ul>
<li>进入循环：一个位置进入，初始化位置，for循环or while循环、</li>
<li>循环体：{}隔离，避免空循环，循环内务操作位置，操作目标点唯一性、</li>
<li>退出循环：确认循环停止并且条件明显，退出使用break和continue小心谨慎</li>
</ul>
<p><strong>循环的长度</strong><br>循环应当尽可能短，若接受编写简单代码原则，应该很少产出大于15-20行的循环。<br>嵌套限制在3层，若过长应当提取子程序或者简化控制结构。<br>子程序的应用。</p>
<h2 id="不常见的控制结构"><a href="#不常见的控制结构" class="headerlink" title="不常见的控制结构"></a>不常见的控制结构</h2><p><strong>子程序多出返回</strong><br>半途退出子程序的方式</p>
<p>1、若是增强可读性，则使用<br>2、防御性代码简化复杂错误处理<br>3、建议减少return数量</p>
<p><strong>递归</strong><br>一个子程序自己负责解决某个问题点一部分，并且将问题分成小块，调用自己来解决每一小块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 递归的快排</span><br><span class="line">function QuickSort(array, firstIndex, lastIndex) &#123;</span><br><span class="line">    if (firstIndex &lt; lastIndex) &#123;</span><br><span class="line">        const pointer = division(array, firstIndex, lastIndex);</span><br><span class="line">        QuickSort(array, firstIndex, pointer -1);</span><br><span class="line">        QuickSort(array, pointer + 1, lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归将自身分解为两部分，计算本次的操作，以及切分更小的操作让自身函数继续执行。<br>小范围的问题，递归能带来简单优雅的解决方案，但范围扩大后带来的复杂度甚至是栈溢出等问题也会比较普遍。通常简单的迭代会更易理解。</p>
<p>1、确认递归能停止<br>2、递归限制在一个子程序<br>3、注意栈空间<br>4、避免递归阶乘或者斐波那契数列：速度缓慢，无法预测内存使用，更高的复杂度。</p>
<p><strong>goto</strong></p>
<h3 id="一般控制问题"><a href="#一般控制问题" class="headerlink" title="一般控制问题"></a>一般控制问题</h3><p><strong>布尔表达式</strong><br>除了最简单的顺序执行控制外，所有控制都依赖布尔表达式。</p>
<p>1、使用true和false进行布尔判定，而非0，1等。reportSelected&#x3D;&#x3D;&#x3D;1，1是无法明确到底是什么概念，是真假还是id等。<br>2、隐式的表达</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(!done)</span><br><span class="line">while(a &lt; b)</span><br><span class="line"></span><br><span class="line">// 而非</span><br><span class="line">if(done === false)</span><br><span class="line">while((a &lt;b) === true)</span><br></pre></td></tr></table></figure>
<p>3、将复杂判定条件赋值给变量，或生成布尔函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e)</span><br><span class="line"></span><br><span class="line">// 变量or函数</span><br><span class="line">const done = a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e;</span><br><span class="line">if(done)</span><br></pre></td></tr></table></figure>
<p>4、更偏向于使用肯定到布尔表达式<br>5、使用括号使表达式更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(a &lt; b === c === d)</span><br><span class="line">//或者</span><br><span class="line">if((a &lt; b) === (c === d))</span><br></pre></td></tr></table></figure>
<p>6、理解各语言内，布尔的求值，判定方式。易错的、短路求值等</p>
<p><strong>复合语句，语句块</strong></p>
<p><strong>空语句</strong></p>
<p><strong>深层嵌套</strong></p>
<p>重新设计if esle执行的判断，重构提取子程序基本能解决该问题。<br>1、重复判定的处理<br>2、转换 if else<br>3、转换 case<br>4、将深层嵌套代码提取子程序<br>5、使用状态变量重写<br>6、明确退出，简化逻辑</p>
<p><strong>控制结构与复杂度</strong></p>
<p>控制结构之所以重要，因为其直接影响代码的整体复杂度。程序复杂度是一个衡量指标，为了理解程序，你必须在同一时间记住的智力实体数量。这类智力游戏是编程中最难的方面之一，需要比任何活动都专心。被打断的成本代价很高。</p>
<p>复杂度的重要性：<br>『有能力的程序员会充分的意识到自己大脑容量是多么有限，所以会非常谦卑的处理编程任务』</p>
<p><strong>降低复杂度的原则</strong><br>1、通过脑力练习提升你的脑力水平<br>2、降低你应用程序复杂度</p>
<p>度量复杂度的方法：<br>1、从1开始，往下运行程序<br>2、遇到下列或者相关关键词，加1：if、while、repeat、for、and、or<br>3、case内每一种情况加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((status = SCUESS) &amp;&amp; done || (!done &amp;&amp; (numLines &gt;= maxLines)))</span><br><span class="line">// 1、if +1、&amp;&amp; +1、|| +1、&amp;&amp; +1  5个决策点</span><br></pre></td></tr></table></figure>
<p>0-5 子程序可能还可以<br>6-10 需要简化子程序<br>10+ 需要优化与拆分</p>
<p>其他类型：数据量、控制结构嵌套层次、代码行数、变量跨度和生存期等。</p>
<p><img src="http://image.freefe.cc/2019-06-16_10-28-00.png" alt="image"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">倪颖峰</p>
  <div class="site-description" itemprop="description">曾在果壳、百度蹦哒，目前在B站活跃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">倪颖峰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
