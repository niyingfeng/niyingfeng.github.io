<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freefe.cc","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:type" content="website">
<meta property="og:title" content="NiYingfeng 的博客">
<meta property="og:url" content="http://freefe.cc/index.html">
<meta property="og:site_name" content="NiYingfeng 的博客">
<meta property="og:description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="倪颖峰">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://freefe.cc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>NiYingfeng 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">NiYingfeng 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、生活与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2021/04/01/cognitive-trap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/cognitive-trap/" class="post-title-link" itemprop="url">《认知陷阱》 - 如何理性和科学的去生活</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-02T00:00:00+08:00">2021-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-08-031.png"></p>
<p>《认知陷阱》全书都旨在帮助我们分析理解一个问题：为什么如今高度文明的人类社会，依旧还有那么多毫无科学依据、不理性的医疗和健康观点？</p>
<p>本书是需要我们颇费一定精力去阅读的书，它抛开传统的科普方式，从行为背后的心理学、社会学以及神经生物学出发来剖析现代文明中不科学的行为和信念。比如站在科学的角度，其严谨性使得对于任何问题，永远不可能给出百分之百的结论，只能非常接近绝对，而这一点就与我们人类的惯有的心理与思维背道而驰。</p>
<p>或许你受过高等教育，自认为与那些不科学与不理性的事情毫无关系，那就真的错了。很多影响我们判断的因素深深纂刻在了我们的基因里，并不会因为教育程度高低而改变，教育只是能更好的帮助我们有意识的去感知，理解和接受行为。在作者看来，我们没必要厌恶自己的错误行为，而是去理解它背后的原因，进而慢慢去做改变。</p>
<p>本书整体从阴谋论、卡里斯玛型领袖、确认偏误、因果关系、逃避复杂性以及接受风险几点来详细剖析我们作为人受各种因素影响导致的各类不理性与不科学的行为的真正原因。</p>
<h2 id="阴谋论"><a href="#阴谋论" class="headerlink" title="阴谋论"></a>阴谋论</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-11-39.png"></p>
<p>我们是如何被诱导陷入阴谋论的漩涡中的？</p>
<p>书中表达了一个观点：『阴谋论给了相信它的人某个具体事物，让这些人可以责怪是这东西让自己陷于困境中，而不必归咎于非人为的、抽象的社会力量。』</p>
<p>通俗点来说就是，既想表达对于世俗的不满，有满是借口来规避自身责任去改变。习惯将自身作为受害者，而又要克服无力感的欲望，这就激发了我们内心深处对于阴谋论的认同感。我们喜欢将自己无力控制的事情归咎于强大而又黑暗的幕后力量，使得我们对此的坦然的接受。既满足了情感上的需要又得到了一个自认为合理的解释。</p>
<p>一般来说，我们在判定某一阴谋论是否成立时，会有两种情况：当我们去思考熟悉的阴谋论时，会尝试使用已知事实和科学证据来评估其可信度。而对于陌生的阴谋论时，确主要依赖阴谋论的动机强弱做出判断。</p>
<p>比如，我们普通人对于转基因其实并没有多少了解，但是从利益角度思考是成立的，就理所当然的任务转基因的阴谋论就是成立的。其实从本质上看，将问题从科学可能性转化为了动机的强烈程度，显然就有悖于科学了。</p>
<h2 id="卡里斯玛型领袖"><a href="#卡里斯玛型领袖" class="headerlink" title="卡里斯玛型领袖"></a>卡里斯玛型领袖</h2><p>当我们处在群体中，对我们理解复杂问题的方式、决定信赖什么、判断事物的真伪造成怎样的影响？</p>
<p>《乌合之众》一书也表达了其观点，可能存在一定偏激，不过现实也并没有我们想象的那么理想。作为人类，面对矛盾的容忍度着实不高，而社交动机上又希望表现的与其他人一致，进而导致由于群体引发的诸多问题。</p>
<p>从人脑结构以及其功能来说，人类最基本的情绪源自于大脑中较为原始的部分，比如杏仁核、岛叶以及伏隔核，而理性则来自于我们的前额皮质层。强烈的刺激会导致杏仁核抑制前额皮质，为迅速反应做好准备。而强势的前额皮质也可以用理性来抑制情绪脑，避免做出冲动行为。理性与感性平衡时，则出现了理想的人类：可以很好的体验爱、恐惧、同情等复杂的情绪，也能读、写以及计划等高等的理性思考。所以说，理性与感性，我们更应该学习的是如何平衡，而非去抑制某一端。但平衡仅仅是作为人类的最佳理想情况。</p>
<p>而卡里斯玛型领袖是什么？将原本理性分析的问题，抹上感性的色彩，比如回避科学的数据分析将问题放宽到自由和公正这类普遍关注的问题上来转移我们对核心议题的注意力（怎么感觉就是说的灯塔国。。。）。然后，我们便深信不疑的支持以及推崇。不过我们需要明确，卡里斯玛型领袖并非完全贬义。</p>
<h2 id="确认偏误"><a href="#确认偏误" class="headerlink" title="确认偏误"></a>确认偏误</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-15-24.png"></p>
<p>为什么我们总是各执己见，为坚持自己的言论的而争论不休？</p>
<p>确认偏误指的是作为人类普遍的一种倾向，只关注与我们原本就认为是正确的信息相一致的信息，主动有所选择地去关注那些与我们的假设一致的事物的过程（其本质依旧与我们大脑中的奖惩机制有关）。</p>
<p>确认偏误有不少特点。首先，它容易形成非理性首因效应：我们对初次听到或体验到的信息的信任程度比之后得到的信息要高。其次，确认偏误受情绪影响，比如我们容易被激情冲昏了头脑。最后，为了坚持某一个信念，我们对任何与这个判断有冲突的事情都听不进去。</p>
<p>而科学又是一个持久的过程，在此过程中，一个人将尽自己最大的努力去证明我们相信的每件事都是错的（科学的证伪）。如果这种证伪的尝试严格重复了足够多次之后依然毫无成果，我们才开始相信这个科学理论或许就是真的。</p>
<p>在确认偏误的强大力量面前，我们需要转移我们的注意力，全心全意地对证据进行理性且持续的评估。认识到人对自身信念的执着背后有着深刻的情感方面的理由，在可以预见到的特定脑回路和脑网络活动下，这些理由得到了巩固。</p>
<h2 id="因果关系和知识空白"><a href="#因果关系和知识空白" class="headerlink" title="因果关系和知识空白"></a>因果关系和知识空白</h2><p>你觉得什么是因果关系？仅仅是总能观察到B在A之后发生，先后的连续性，便能断定A就是B的因么？</p>
<p>哲学家、科学家和经济学家千年来都在争论是什么构成了因果关系，至今可能都没有一个出色的答案。</p>
<p>因果关系最早源于亚里士多德的四因说（质料因、形式因、动力因、目的因），他提出：除非我们知道某事物的原因，否则就不算掌握了关于该事物的知识。</p>
<p>哲学家休谟对于因果关系的话题，其更感兴趣的是确立我们感知因果关系的模式，而不是其真实概念。我们对因果关系的感知方式取决于因果两者在时序上有先后且在空间上相邻，这是不是真正可靠的建立因果关系的办法？</p>
<p>在波普尔看来，证明因果关系存在这个目标是错的。归纳推理的目的不是“证明”，而是“证伪”。</p>
<p>那么十分现实的问题是：一方面是专业科学家带着健康的怀疑主义精神寻求建立因果关系，另一方面是亚里士多德指出的人类追求因果机制的天性。</p>
<p>比如有50个实验与他们的信念相冲突，而唯独有一个实验似乎与之相符，这些人当然就会抓住那一个实验大肆宣传，同时还要对科学家们加以控诉，说后者始终知道内情，只是一直在掩盖真相。这种做法通常被称为“精选数据”。</p>
<h2 id="逃避复杂性"><a href="#逃避复杂性" class="headerlink" title="逃避复杂性"></a>逃避复杂性</h2><p><img src="http://image.freefe.cc/Snipaste_2021-04-02_09-17-58.png"></p>
<p>近些年比较火爆的观点是将我们的思维分成两种类型，快思考和慢思考，反思系统和反射系统等。</p>
<p>情绪脑，人类进化过程中保留的大脑中相对原始的、哺乳动物都有的部分，深植在哺乳动物大脑中称为边缘皮质的区域内。用于做出迅速的、情绪化的决定来保证原始环境自身的生存几率。</p>
<p>而相对的大脑中进化程度最高的部分-前额皮质，我们称之为理性脑。它能调节常规信念处理过程的三个组成部分：</p>
<ul>
<li>在理性思考时对一种信念刻意做假装它可能不成立的“信念抑制”；</li>
<li>用直觉对一种信念的成立“感觉其正确性”；</li>
<li>用直觉对超乎寻常的信念内容“感觉其错误性”，或提高警惕。</li>
</ul>
<p>不过理性思维的困难在于运用前额皮质并做出理性选择消耗的能量非常之高，令人极度疲惫。这也是为什么我们习惯于不假思索，逃避花费时间与精力去理性思考。</p>
<h2 id="接受风险"><a href="#接受风险" class="headerlink" title="接受风险"></a>接受风险</h2><p>为什么我们忽视了与每天都发生的活动——如淋浴和驾驶——联系在一起的风险，却不停地为小到近乎不存在的可能性——如对疫苗有不良反应，核电站、高压电线的伤害？</p>
<p>答案就隐藏在人类心理对风险的感知中：当涉及健康问题时，人们无法容忍由感觉上控制不了的危害产生的风险，却可以心满意足地接受觉得在自己控制之下的风险，即使这两种感觉是不准确的。</p>
<p>几个能导致我们对风险做出判断的关键定性特征。除了对自我感觉无法控制的风险难以容忍，我们还不能忍受可能造成灾难的风险、有致死后果的风险，或者自己所在的人群承担风险而好处却被别的人群拿走。</p>
<p>核武器和核电站高度满足上述全部特征，即：</p>
<ul>
<li>（1）我们不能控制发生在核电站里的事情；</li>
<li>（2）假如真的发生与核能相关的事故，那将是致命的；</li>
<li>（3）我们总有办法发电的，所以从核电站得到电力这种做法怎么值得冒险尝试呢？</li>
</ul>
<p>从专业角度看，心理学家、行为经济学家以及神经科学家把人们高估小的可能性而低估大的可能性的倾向称为“非线性可能性估算”。</p>
<p>我们不认为火车是高风险事物，哪怕刚看到一起被大肆报道的火车事故的新闻，但核反应堆的一起小事故就会引发显而易见的社会震荡和强烈忧虑，以及排斥核技术的反应。风险研究者提出，我们心中对这两类事故产生区别对待的依据是我们对发生事故的系统的熟悉程度。</p>
<p>我们大脑的一种常见的经验法则：熟悉就是好且安全的；不熟悉就是坏且危险的。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>整本书都在主张，在拒绝接受科学证据这种行为背后有着复杂的心理学、社会学以及神经生物学基础。作者也提出了，此类倾向中有很多在各个方面都是适应性行为，很正常，也很符合人类的本性。</p>
<p>告诉人们不要感情用事不仅无济于事，压抑人脑的这一面不符合任何人的最大利益。所以，不过我们可以使用一种多要素方法来帮助人们，引导他们直面证据，同时又不会忽略人性中重要的那一部分。最后，我们不希望人们在本应关注数据的时候争先恐后地寻觅逸事。</p>
<p>以下是作者的几条指导原则：</p>
<ol>
<li>不是只有未受过教育的人才会做出不理性的医疗健康类决策。</li>
<li>不是“信息匮乏”这么简单，不能忽视了心理学、情绪及社交方面的本能。</li>
<li>同情心与进化优势有时与理性思维有冲突。</li>
<li>假设检验无力发表绝对肯定的主张，人们对此感到不自在。</li>
<li>人们对情感的回应比对数据的回应热烈，但卡里斯玛型领袖利用情感，而科学家利用数据。</li>
<li>人们要改变想法是很难的。</li>
<li>人们很难理解概率与风险。</li>
</ol>
<p>如果我们不把心理学、情感和社会动力纳入对话中，就永远不能在反对危险的、不科学的理念的斗争中取得任何进展。</p>
<p>人们为什么会坚持毫无科学依据的、不理性的医疗和健康观点——的答案其实就这么简单：因为我们是人类，我们是有同理心而且社交动机强烈的人类，具有复杂的心理与情感，以及高层次的社交因素。</p>
<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>本书真真实实的加强了自身对于自我认知的理解。自以为作为现代社会受教育程度和学习力还可以的人，缺也是没法绕开人类与社会等影响。</p>
<p>作者通过非常多强有力的事实证据来从多个角度阐明了『为什么如此发达的现代文明中，仍有如此之多的人去坚信毫无科学依据、不理性的医疗以及健康观点』。</p>
<p>答案很简单，因为我们是人类，我们是有同理心而且有构建社群的强烈动机的人类，复杂的心理学、社会学以及神经生物学等非常多之因素在影响我们的判断与分析。</p>
<p>在各类复杂因素的相互作用下出现了阴谋论、卡里斯玛型领袖、确认偏误、因果误判、逃避复杂性、错误的分险与可能性等，让我们沉溺于不科学与非理性之中，难以自拔。</p>
<p>而从科学的角度，其弱势就是我们永远不能给出百分之百的结论，只能非常接近绝对肯定，这又与人类惯有的思维背道而驰。</p>
<p>这是一本需要颇耗心力去阅读与理解的书，给我最大的触动并非作者将认知陷阱这个问题分析的如此之透彻，而是作者并不否定任何一种行为，而从更深层次的角度去剖析与认可该行为背后的原因。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2021/02/17/2020-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/2020-summary/" class="post-title-link" itemprop="url">2020年度总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-18T00:00:00+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当前已是21年2月，最近被一些事情所触动，决定重新拿起键盘去记录一些东西，让自己保持反思与思考的习惯，那么暂且从这2020的年度总结开始。</p>
<p>写作对于自己而言，从来不是一件容易的事情，毕竟就连当年的高考作文，离800字的合格线也还差了两行。自认为就语言方面而言，可能有点欠缺&amp;#x1f613;！</p>
<p>新的一年，希望自己能坚持持续性的做一些沉淀，反思，以写作的形式做一些有意义的输出。</p>
<h2 id="回想过往"><a href="#回想过往" class="headerlink" title="回想过往"></a>回想过往</h2><p>9年前的那个春节，拿着三千块独自去了北京，住在生命科学园的村子里，每天挤着昌平线，而那时的自己是充实而又纯粹，地铁上捧着红宝书的自己或许是这辈子最努力的样子。自身没啥过人的天赋，只是感谢曾经努力的自己，为着纯粹的做一个前端开发的理想。</p>
<p>在此也发自内心的感谢东哥、洪梅姐、百分点的那波玩伴，俊阁，许总以及果壳的那一大家子人，成了一个南方人，在北京的故事。（由于个人性格关系，后期联系较少，也请见谅）。</p>
<p>北漂的日子，简单，充实，也瞬息万变。让我从一个跨专业到计算机行业就业的学生，慢慢成为了一个算是合格前端工程师。</p>
<p>6年前的那个春节，离开了呆了3年的北京，那个带给自己很多故事的地方，满怀期望来到了上海，自己向往已久的公司 - 百度，开始了作为人生第二段的职业故事。</p>
<p>自己走上前端的道路，纯粹因大三的计算机网络选修课上，那位老师说百度的校招生，基本月薪1万起，11年时的我们确实单纯而又世俗&amp;#x1f602;。算是回到了梦最初的地方。</p>
<p>上海的生活，便是逐渐走向平稳。在百度，眨眼间就是5年多，可能因为自身开始缺乏目标性的原因，感觉慢慢的走向舒适，而也变得有一定焦虑。</p>
<h2 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h2><p>2020年，沈逸老师用『百年未有之大变局』来描述世界格局的变化。</p>
<p>而对于自己人生来说也是如此，小满哥的到来，媳妇的被隔离，从百度的离开，在B站的融入，在上海的看房买房，与房东的斗智斗勇…，确实也可以写成一部短篇小说。</p>
<p>2020年里，做了很多抉择，学会了更加全面的看待自己，成长确实不多，但还是有幸能时常的去反思自己，开始学习去构建自己的知识体系，有规划的完备一些技术与非技术储备，学会去接受本不完美的自己。</p>
<p>而2020年的遗憾也不少，计划执行力下降明显，读书计划惨不忍睹，每日使用自家APP时长过长&amp;#x1f625;（少刷视频多看书），懒癌晚期患者~，两个自我的斗争中，明显败的挺惨。</p>
<h2 id="关于2021"><a href="#关于2021" class="headerlink" title="关于2021"></a>关于2021</h2><p>2021年，收拾行囊，重新出发。</p>
<p>今年，希望自己在专注、靠谱、情绪管理以及沟通方面能有一定成长，以及继续完善自己的知识体系，产出一些自己的心得体会。</p>
<p>在专注力上，能有自己的行为方式与习惯，提高自身各方面效能，加强自身的核心竞争力。</p>
<p>在靠谱度上，重新找回年轻的心态和斗志，认真有态度的去做到每一件自己认可的、承诺的事情。</p>
<p>在情绪管理方面，期望能控制短时间内的冲动，多角度，多立场的看待与解决问题，作为情绪的管理者而非奴隶。</p>
<p>沟通方面，能较好的快速获取对方的观点，简洁的表达自身观点，以及权衡双方矛盾等，需要继续有待学习与提升。</p>
<p>学习方面，不断完善自身的知识体系，学习沉淀对于技术与非技术的有效认知，以体系的形式去看待与解决问题。</p>
<p>2021年以及未来，学会接受各种磨砺与挫折，能正向的面对。有句话听过好多次，有点过，但是很不错：『世界以痛吻我，我要报之以歌！』。希望自己能以更宽广包容的心态去拥抱这个世界！</p>
<blockquote>
<p>尚未佩妥剑，<br>转眼便江湖。<br>愿历尽千帆，<br>归来仍少年。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2020/04/10/fe-engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/fe-engineering/" class="post-title-link" itemprop="url">浅谈前端工程化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-11T00:00:00+08:00">2020-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://image.freefe.cc/202004111008.jpeg" alt="image"></p>
<p>在前端开发的角度看工程化，相对来说缺乏一定的经验标准。在此简单聊聊自身前端工程化的概念和理解。若有错误，欢迎指正。</p>
<h2 id="软件危机与软件工程"><a href="#软件危机与软件工程" class="headerlink" title="软件危机与软件工程"></a>软件危机与软件工程</h2><p>简单的了解下早期由于软件问题引发的真实案例。</p>
<blockquote>
<p><strong>Therac-25医疗事故：</strong><br>加拿大原子能公司生产的放射线疗法机器，其软件系统由于未处理好多进程时序的冲突问题，导致多起医疗事故。患者接受了高出正常剂量的百倍辐射，造成多起死亡或严重灼伤事件。</p>
</blockquote>
<blockquote>
<p><strong>美国银行信托软件系统开发：</strong><br>82年美国银行规划发展信托软件系统，原计划预算2千万美元，耗时9个月，于84年底前完成。实际至87年3月，期间投入6千万美元，最终因系统不稳定而放弃。导致被迫转移340亿美元信托资金，失去6亿美元的信托商机。</p>
</blockquote>
<blockquote>
<p><strong>阿丽亚娜-5运载火箭爆炸事件：</strong><br>96年6月，阿丽亚娜-5运载火箭首次测试发射，在发射后37秒被迫自行引爆，原因由于64位的运算错误地变为16位的运算，造成程序崩溃，火箭感测角度失常，从而触发自毁装置的启动。</p>
</blockquote>
<p>以上软件问题均出现在计算机诞生早期，而在如今互联网崛起的时代，问题似乎越发严峻。单以安全为例，不管我们的防御如何的升级与完善，相关的事件问题确越来越多。</p>
<blockquote>
<p>Google遭受黑客入侵的极光运动、索尼PlayStation和索尼影视黑客事件、Adobe攻击事件、Carbanak组织入侵银行、乌克兰电网入侵、雅虎数据泄露、万豪酒店数据泄露等。</p>
</blockquote>
<p>或许你会觉得，以上软件问题和网络安全事件，与工程化或者说软件工程又有什么关系呢？</p>
<p>其实很简单，所有的各类软件或网络安全问题，本质上都指向了一个根本原因：<strong>日益庞大的软件系统，其复杂度已经远超我们人脑可以直接控制的程度。</strong></p>
<p>于是北大西洋公约组织，在1968年创造了软件危机一词，来定义软件项目开发中的预算、周期以及质量引发的问题。同时召集了数十位业界顶尖的编程人员、计算机科学家和工业届巨头，讨论制定摆脱软件危机的对策，也是首次提出软件工程）的概念。</p>
<h3 id="软件危机（Software-crisis）"><a href="#软件危机（Software-crisis）" class="headerlink" title="软件危机（Software crisis）"></a>软件危机（Software crisis）</h3><p><img src="http://image.freefe.cc/202004111002.jpeg" alt="image"></p>
<p>软件危机的概念：在软件开发与维护过程中暴露出来的一系列的严重问题，导致直接影响软件的使用寿命甚至夭折。</p>
<p>对应具体问题主要有以下类型：</p>
<ul>
<li>项目超出预算。</li>
<li>项目超过排期。</li>
<li>软件质量低落。</li>
<li>软件不符合需求。</li>
<li>项目无法管理，代码难以维护。</li>
</ul>
<p>是不是与我们现在项目中遇到的问题大同小异？</p>
<h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><blockquote>
<p>软件工程：研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科 - 维基百科。</p>
</blockquote>
<p>因软件危机而生的软件工程，主要由以下两个构面：（深入了解学习具体可参见《代码大全》学习）</p>
<ul>
<li>软件开发技术：开发方法、工具、开发环境</li>
<li>软件项目管理：软件度量、项目估算、进度控制、人员组织、配置管理、项目计划</li>
</ul>
<p>简单说完软件危机和软件工程，那边开始简单说说前端工程化的概念。</p>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>随着互联网的飞速的迭代，前端也从早期的页面项目形态到日趋复杂的软件形态，项目复杂度呈指数级上升，也就给前端开发者带来了不可避免的软件危机的问题。</p>
<ul>
<li>接手的项目代码质量是不是想口吐芬芳？</li>
<li>多人协作开发是不是混乱不堪？</li>
<li>公共方法、函数、样式、组件等是不是使维护无从下手？</li>
<li>提交、测试、上线流程是不是存在各类安全分险问题？</li>
<li>…</li>
</ul>
<p>作为一线开发者，我们肯定遇到过以上类似情况，这也是目前软件开发赤裸裸的实现。那么对于前端工程化，就是希望能更好的解决类似的问题。</p>
<ul>
<li>如何保证项目的协作开发效率？</li>
<li>如何保证项目的代码质量与迭代开发质量？</li>
<li>如何保证项目的可复用性、可维护性和可扩展性？</li>
<li>如何保证项目重复工作的效率与准确性？</li>
<li>如何保证项目开发、上线流程的低风险？</li>
<li>……</li>
</ul>
<p>结合工程化的概念来说，<strong>前端工程化的定义就是借助软件工程的技术、方法和思想，来优化前端侧的流程、效率和规范等，使用系统性、规范化、可定量的前端工程实践，结合项目自身，构建出相对较优的工程实践方案</strong>。</p>
<p>参考网上将前端工程化分四个能力点：规范化、模块化、组件化、自动化，个人还是比较认同。</p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p><img src="http://image.freefe.cc/202004111018.jpeg" alt="image"></p>
<p>无规矩不成方圆，对于编程这件事情，我们需要建立许多的规范标准，有效的执行才能确保我们项目各方面质量。而之所以将规范列为首要条件，不仅仅因为规范是最重要的一点也是最难做好的一点。</p>
<p>框架层面不管我们使用的是React、VUE或者是jQuery，样式上不管是用Sass、Less还是原生css，只要在早期的基础架构上，积极的制定好初步的规范，持之以恒去坚持和完善，那么我们的项目就可以具有生生不息的生命力。而遵守规范也是作为一个合格程序员最基础的条件。唯一的准则是你可以去质疑或者优化规范，但是没有打破之前，你不能不遵守规范。</p>
<p>以下简单梳理下个人能考虑到的一些关于开发规范方面的点：</p>
<h4 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h4><p>分支规范是处理多人协同开发的关键点，没有绝对的正确答案，具体依照项目自身复杂程度以及基础环境，来评估最佳的分支实践。</p>
<p>目前大致有以下类型分支形态：</p>
<ul>
<li>1、主干开发工作流：主干开发主干发布。</li>
<li>2、功能分支工作流：功能分支开发，主干发布。</li>
<li>3、分支开发分支发布工作流：功能分支开发，功能分支发布，合入主干。</li>
<li>4、GitFlow：Master、Develop、Feature、Release、Hotfix 多功能分支动态协作方式。</li>
<li>5、Github Flow：Master 与 Feature 分支的简单模型。</li>
<li>6、GitLab Flow：与Github Flow类似，添加Pre-Production 和 Production 分支进行环境部署处理</li>
</ul>
<blockquote>
<p>注意分支规范等同时，需要遵守标签的规范。</p>
</blockquote>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><p>编码规范的目的就是提高代码的可读性和可维护性，确保自己或者他人维护或者扩展代码的统一性，降低复杂度，也避免语言上的一些细节问题等。前端侧包含但不仅限于 HTML规范、CSS规范、JS规范、VUE&amp;React规范、TS规范等。</p>
<h4 id="架构规范"><a href="#架构规范" class="headerlink" title="架构规范"></a>架构规范</h4><p>前期保证简单易扩展的基础架构模式，开发人员需严格遵守现有的结构、组织以及构建模式。在需要升级优化架构时，进行基础评估以及各使用方确认，在保证兼容，不降低质量的前提下进行架构升级以满足业务的复杂度。</p>
<h4 id="提交与CR规范"><a href="#提交与CR规范" class="headerlink" title="提交与CR规范"></a>提交与CR规范</h4><p>代码的提交前置检测与CR，是我们确保项目代码质量最重要的环节。代码规范是否统一，是否可能含有隐性的逻辑问题，代码质量是否符合标准等各方面的质量控制均在这两个环节进行把控。自动化风格检测，自评与他评等，是作为我们开发者自身去确保代码质量最基础的标准。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他方面还包括对于自身项目设计评审规范、单测标准规范、提测流程规范、上线流程规范等标准化的建立与执行等。</p>
<p>所有环节均以标准化、规范化进行执行，方能确保我们的项目不至于快速陷入项目的软件危机之中。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><img src="http://image.freefe.cc/202004111032.jpg" alt="image"></p>
<p>万物皆模块！在前端工程化的不断进化中，我们逐渐将前端侧所接触的一切内容，行为以及资源，均作为模块的概念进行抽象与管理，达到我们统一管理项目资源的目的。</p>
<p>对项目进行逻辑细化、管理拆分是模块化概念不变的主题，旨在降低我们大脑的思维逻辑在同一时间需要思考的复杂度级别，从而提高项目的简单可维护性。管理复杂度是我们最终目标。</p>
<h4 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h4><p>随着ES规范的不断完善，JS的模块化历程也逐渐的统一。从早期的AMD、CMD转化到了ES6 Module，从标准规范转到了ES6规范，成为了语言的特性。</p>
<p>CommonJS：主要用于Node侧，每个文件均为独立的模块，均含有自身的作用域，通过require来引入内置、自定义以及第三方模块。由于偏向服务端侧规范，以同步模式进行引入，相对来说不适用于浏览器侧模式。</p>
<p>AMD：RequireJS的模块化规范产出，非同步模块的加载，以回调函数方式执行。define来定义模块以及require来加载模块使用模块。需提前加载所有依赖而非按需加载，依赖前置，提前执行。</p>
<p>CMD：依赖就近，延迟执行。主要为SeaJS推广的模块定义规范，集成了CommonJS与AMD的一些特新，同时支持同步与异步加载。</p>
<p>ES6 Module：作为JS内置的语言特性，相对于CommonJS</p>
<ul>
<li>CommonJS为运行时加载，ES6 Module为编译时输出接口</li>
<li>CommonJS加载整个模块的所有接口，ES6 Module可以独立输出其中一个接口</li>
<li>CommonJS输出值的拷贝，ES6 Module输出值的引用</li>
</ul>
<p>当然，借助于强大的Webpack我们能很好的将不同类型的模块化规范的JS文件进行结合构建，共存使用。</p>
<p>JS的模块化历程也算是前端模块化历程的缩影，不断的尝试以及最后的统一，感谢ESMA，当然也感谢WebPack。</p>
<h4 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h4><p>借助于CSS预编译工具的广泛使用，如Sass、Less、Stylus等，前端侧相对较为死板的CSS也变得无比灵活，在支持变量、嵌套、混合等高级的能力支持，使得CSS的细化拆分变得容易，从而使得前端开发者能更好的以模块化的思维来对项目的CSS进行统筹管理。极大简化了项目CSS的开发与维护复杂度。</p>
<p>但是以上的工具纯粹解决的只是样式模块化复用，编程能力弱的问题，缺无法解决以下问题：</p>
<ul>
<li>样式全局污染，以及各类权重覆盖问题</li>
<li>命名混乱的冲突</li>
<li>CSS模块引入相互影响，作用域问题无法解决</li>
<li>压缩侧对于冗长的样式名等无能为力</li>
</ul>
<p>于是乎，BEM风格解决方案、CSS Modules 模块化方案等开始应运而生，各类方案各有利弊，依据项目与团队本身进行评估选择。</p>
<p>BEM风格：Block、Element和Modifier通过命名规范来规避以上问题，前提是在各方开发者遵守既定规范的前提下。</p>
<p>CSS Modules：类似的仍是基于命名层面处理，对应组件内模块化样式进行特定规范标识，从而解决上述问题。</p>
<p>当然，没有银弹，我们要做好的就是以最合适的方案解决我们项目的问题。</p>
<h4 id="资源模块化"><a href="#资源模块化" class="headerlink" title="资源模块化"></a>资源模块化</h4><p>万物皆模块的基本表达，不管是图片、数据还是其他各类资源，借助于WebPack的强大能力，将所有项目相关资源视为模块进行管理。</p>
<blockquote>
<p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
</blockquote>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><img src="http://image.freefe.cc/202004111023.jpeg" alt="image"></p>
<p>组件化相对于模块化来说，是一个更高纬度的颗粒化，而在前端侧，组件化主要指的UI组件化。如果说各类构建工具推动了前端模块化的支持与发展，那边前端流程的框架便推动了前端组件化概念思维的大爆发。</p>
<p>组件化的目标与模块化类似，主旨便是降低复杂度。将特定的逻辑、模板以及样式独立封装，具有可复用性和低耦合性的基础UI模块。简单来说无非就是隐藏自身内部逻辑，减小编程开发中时间点所需要思考的复杂度。</p>
<p>对于项目来说，一般对于组件的划分模式较多，自己喜欢将其划分为基础UI组件，业务逻辑组件以及页面组件。</p>
<ul>
<li><p><strong>基础UI组件：</strong> 相对项目来说最底层支持配置的组件，具有统一的业务逻辑和行为等，比如项目自定义Button、Input等，广泛使用的一些基础UI组件库（Ant Design、ElementUI等）。在编写基础UI组件时，需要明确与具体业务逻辑剥离，专注于所定义的基础组件的逻辑、交互和行为，按需进行配置化支持。基础组件更偏向于复用性。</p>
</li>
<li><p><strong>业务逻辑组件：</strong> 在基于基础组件的前提下，结合项目业务进行组件化，对于页面级别进行拆分和组件化，目标仍是封住逻辑，降低项目内页面开发复杂度。相对而言，业务组件更偏向于逻辑封装和管理。</p>
</li>
<li><p><strong>页面组件：</strong> 页面级别对于基础组件与业务逻辑组件的统筹管理，在页面级别则不在深入具体的细节交互逻辑。</p>
</li>
</ul>
<p>当然组件类型的拆分编程思维，万千世界各有不同，每位开发者对于组件化思维的考虑均有不同，以符合项目自身出发。</p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><img src="http://image.freefe.cc/202004111033.jpg" alt="image"></p>
<p>前端自动化主要指前端工程上各阶段使用自动化工具来提高效率与准确性的方式。如代码风格与质量检测，构建、部署、测试、发布等大量重复性和大数量级工作的处理，实现自动化检测、评估与运行。</p>
<p>自动化概念设计到开发者整个开发流程的各阶段，具有非常重要的席位，下面简单介绍一些实用的自动化工具：</p>
<ul>
<li>自动化代码检测：不用说，强大的套餐，ESLint、StyleLint、HTMLHint等，以项目代码规范进行静态资源检测配置，进行代码前置检测。</li>
<li>自动化构建工具：毫无疑问，目前WebPack算是一统天下，并且其加载器、插件几乎集成了所有基础的自动化处理工具的能力。grunt -&gt; gulp -&gt; webpack 也算是前端构建历史的迭代历程了。 </li>
<li>自动化测试工具：除了大量流程的测试框架如mocha、jest等，还有如测试平台karma、断言工具库chai，以及无头浏览器PhantomJS，真实浏览器工具puppeteer等。</li>
<li>自动化部署：此处工具依赖各开发者公司的几次发布平台，一般均有固定的支持的模式。（如jenkins支持等）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结来说一下，前端工程化所需要解决的问题，也无非就是软件工程所要解决的难点。软件工程中没有银弹，也没有绝对的好与坏，只有是否适用和正收益。</p>
<p>前端工程化问题无非从软件规范、开发思维以及开发工具，认真做好每一步，尽量减弱破坏项目规则的每一个可能的点来加强我们项目的健壮性。当然对于非常多的项目，实现以上所有的点太过于理想化，所以要评估我们项目工程化程度的前提是，我们是否确定已经评估我们所需要项目的健壮程度，而后在进行评估做到怎样程度的工程化。</p>
<p>最后结合百度工程化的一些评估要求，简单产出相对可量化评估的偏前端工程化Map：</p>
<ul>
<li>需求阶段：迭代管理、需求管理、BUG管理</li>
<li>开发阶段：设计评审、分支管理、项目规范、编码规范、提交规范、需求关联</li>
<li>准入阶段：CodeReview、单元测试、增量代码扫描、集成构建方式、核心功能准入测试</li>
<li>测试阶段：手动测试用例、自动化测试用例、全量代码扫描、性能评估、功能回归</li>
<li>发布阶段：部署产物规范、资源缓存规范、页面监控检测</li>
</ul>
<p>最最后，我们需要记住任何行为，均有其正面与反面意义，我们需要评估的是其正收益是什么！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/06/07/coding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/07/coding/" class="post-title-link" itemprop="url">如何优雅的编程 - 来自《代码大全》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-08T00:00:00+08:00">2019-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>来自《代码大全》内容信息整理，豆瓣评分9.3。</p>
<blockquote>
<p>Write Programs for People Frist, Computers Second.<br>首先为人写程序，其次才是机器。</p>
</blockquote>
<h2 id="软件构建的世界"><a href="#软件构建的世界" class="headerlink" title="软件构建的世界"></a>软件构建的世界</h2><h3 id="什么是软件构建"><a href="#什么是软件构建" class="headerlink" title="什么是软件构建"></a>什么是软件构建</h3><p>软件开发中的各类不同活动：定义问题、需求分析、规划构建、软件架构、详细设计、编码与调试、单元测试、集成测试、集成、系统测试、保障维护、</p>
<p>软件构建一般也会被认为编码 coding，或者编程 programming。而构建感觉就不显得那么机械化，而需可观的创造力与判断力。构建活动主要集中于编码与调试，但也牵涉来除定义问题以外的所有活动。</p>
<p><img src="http://image.freefe.cc/2019-06-28_08-41-55%20%281%29.png"></p>
<h3 id="软件构建为何如此重要"><a href="#软件构建为何如此重要" class="headerlink" title="软件构建为何如此重要"></a>软件构建为何如此重要</h3><ul>
<li>构建活动是软件开发的<strong>主要组成部份</strong>。根据项目的不同，一般占据项目的 30% - 80% 的总开发时间。</li>
<li>构建活动是软件开发的<strong>核心活动</strong>。需求分析与架构设计都是项目的基础工作，使得我们更有效的构建。测试则为构建活动的后续工作，用以验证构建的正确性。</li>
<li>将主要精力集中于构建活动，可以大大<strong>提高程序员的生产效率</strong>。不同程序员的生产效率差异可达10-20倍（1968）。后续该结果被大量研究所验证。</li>
<li>构建活动产物-源代码-往往是<strong>对软件的唯一精确描述</strong>。很多项目，程序员唯一的到的文档就是源代码本书，因此，源代码就比必须有尽可能高的质量，利用各类技术来改善源代码从而得到一个详细、正确且信息丰富的程序。</li>
<li>构建活动是<strong>唯一一项确保会完成的工作</strong>。不管项目如何紧急，不管舍弃哪一环节，构建活动是不可或缺的环节，所以构建活动进行改进，是对改进软件开发过程一种有效的途径。构建活动的质量对于软件的质量有着实质性的影响。</li>
</ul>
<h2 id="隐喻，更充分的理解软件开发"><a href="#隐喻，更充分的理解软件开发" class="headerlink" title="隐喻，更充分的理解软件开发"></a>隐喻，更充分的理解软件开发</h2><p>计算机科学领域中有着丰富的语言，<strong>病毒、木马、蠕虫（worm），臭虫（bug）、崩溃（crash）、错误</strong>等。这些隐喻描述了软件领域中的各类特定的现象和事物，让我们更深刻的理解软件开发的过程。</p>
<h3 id="隐喻的重要性"><a href="#隐喻的重要性" class="headerlink" title="隐喻的重要性"></a>隐喻的重要性</h3><blockquote>
<p>通过把你不太理解的东西和一些较为理解、十分类似的东西做比较，你便可以对不理解的的东西产生更深刻的理解，这类形式的隐喻则为『建模』。</p>
</blockquote>
<p>化学家库勒梦见咬着自己尾巴的蛇，从而提出来环状分子结构，解释了苯环的各种特性。还有比如气体分子的运动理论、钟摆的思考、地心说，日心说等。隐喻都发挥着十分重要的力量。</p>
<p>在软件方面，隐喻好比是一个探照灯，不会告诉你去哪里寻找答案，而是告诉你如何寻找答案。隐喻的作用更像启示，启发式方法，而非算法。</p>
<p><img src="http://image.freefe.cc/2019-06-28_09-19-35%20%281%29.png"></p>
<p><strong>算法是一套明确的指令</strong>，来完成具体的任务。可预测、确定性、不易变化。从A到B，不会额外让你绕到C、D等地方。如驾车到某人家，算法是这样的：沿着X公路往南行进160公里到达Y，从Z口出往西南山上开12公里，杂货铺边红绿灯右转，就是M大街N号。</p>
<p><strong>启发式方法则是一种寻求答案的技术</strong>，具有较强的偶然性，仅仅引导你如何寻求解决方法。比如上面例子，启发式是这样解决的：找出之前的信，照着地址来到这个小镇，然后问一下小镇的人们，基本都知道我们，并且应该很乐意帮助你，如果找不到人，直接打电话给我们，我们会出来接你。</p>
<p>算法与启发式方法存在一定的相似，区别有点类似解决问题的间接程度。如果有一些明确改如何解决编程问题的信息，编程当然会更容易，结果也更易预见。但编程还远远没那么先进，或许永远不会那么先进。目前编程最大的挑战依旧是将问题概念化，正因为每一个问题在概念上都是比较独特的，所以要寻找一套能解决所有问题的通用指导就不太现实。那么对于各类问题，能知道大致上如何一般性的解决也就非常有价值来。</p>
<p>隐喻将提高我们对于编程问题和编程过程的洞察力，帮助思考编程过程中的活动，想象出更好做事的方法。</p>
<h3 id="软件的隐喻"><a href="#软件的隐喻" class="headerlink" title="软件的隐喻"></a>软件的隐喻</h3><p><img src="http://image.freefe.cc/Snipaste_2019-06-28_08-45-08.png"></p>
<h4 id="写作代码"><a href="#写作代码" class="headerlink" title="写作代码"></a>写作代码</h4><p>这个隐喻暗示着开发一个程序就好比写一封有缘由的一样，坐下来，拿出纸和笔，从头到尾的进行书写即可，无需做正规的计划，想到什么写出来便是。</p>
<p>对于个人规模的工作，或者小型项目来说，这类写作的模式已经足够了，然而对于其他场合而言，却远远不够 - 没有完整、充分的刻画软件开发工作。书写通常是一个人的活动，而一个软件项目多半会设计许多不同职责的人，写作或许你写完就完成了，但软件开发编码完毕后可能只是完成了一部分工作。对此更重要的是软件构建更注重于复用以往项目的设计思想、代码模块以及测试用例的开发效率，由于写作所要求的更注重原创。</p>
<p>故而以写作隐喻软件开发过程，则太过于单调与呆板。</p>
<h4 id="培植系统"><a href="#培植系统" class="headerlink" title="培植系统"></a>培植系统</h4><p>一些软件开发人员认为，应当将软件开发想象成播种与耕作的形式，一次设计系统的一小部分，编写一小块代码，做一点测试，然后将其成果一点点的添加到系统中去。</p>
<p>而作者认为，该模式中的增量技术是很有价值的，但是将其比喻成播种，耕作就不为恰当。犹如你对系统计划施肥，对设计细节蔬果，通过有效的管理来增加代码产量。问题在于暗示我们无法对于软件开发的过程和方式进行直接控制，你需要一点一点春天播下种子，按照节气处理照料，将在秋天活动丰盛的代码。这显然也不恰当。</p>
<h4 id="养殖系统：系统生长"><a href="#养殖系统：系统生长" class="headerlink" title="养殖系统：系统生长"></a>养殖系统：系统生长</h4><p>该隐喻类似我们如何一次为软件系统增加一个小部分。与生长相关类似词：增量的、迭代的、自适应的以及演进的。以增量方式进行设计、编译和测试，都是目前已知最强有力的软件开发概念。</p>
<p>在增量式开发时，预先做一个尽可能简单的、能运行的版本，不必有真实的输入，也无需对数据进行真正的处理以及真实的输出，仅仅需要构建足够强壮的骨架用以支撑未来的真实系统。对于你标注出的每一项基本功能，可能都仅需调用虚拟的类来进行占位。</p>
<p>骨架形成后，开始一点点的附着肌肉与皮肤，使用真是的类、接受真实的输入与输出、每次更新增加一小部分代码直到一个完整的工作系统。</p>
<p>作为隐喻，增量式开发的优势在于未做过度的承诺，对于耕作来说，将其作不恰当的引申更为困难一些。</p>
<h4 id="软件构建：建造软件"><a href="#软件构建：建造软件" class="headerlink" title="软件构建：建造软件"></a>软件构建：建造软件</h4><p><img src="http://image.freefe.cc/2019-06-28_08-47-13.png"></p>
<p>建造软件这一说法则暗示了软件开发中的诸多阶段，如计划、准备执行等，更具所建造软件的种类不同，各类阶段和程度也可能变化。</p>
<p>如果你要搭一个易拉罐塔，你就需要一双稳健的手，一块平摊的地以及十几个完整的易拉罐就能简单的开干。而你要搭一座100倍的塔，那么100倍的易拉罐就远远不够，需要采用完全不同的计划方法和建造方法，并且不那么执着的话，还有建筑材料。</p>
<p>如果你想盖一个简单的建筑，比如一个狗窝，你要去木材点买一些木材和钉子，找一些使用的工作，或许傍晚时分，你的爱犬就有新窝了。可能狗窝忘了加一个门或者其他的怎么漏子，不过没关系，修改一下或者从头再来，顶多就是一个下午的事情。宽松的设计对于小型项目还算合适，如果你写了1000行代码，发现设计存在问题，你倒是也可以重构或者重新再来，不会损失太多。</p>
<p>如果你是在建造一栋房子，那么建造过程就好复杂的多的多，糟糕的设计也会带来严重的后果。</p>
<ul>
<li>1、你要十分明确的准备建造一个什么类型的房子 - 软件开发中类似问题定义（problem definition）</li>
<li>2、你需要与建筑师探讨总体设计，并且确认。 - 软件的架构设计（architectural design）</li>
<li>3、画出你详细的蓝图，找一个承包人。 - 软件的详细设计</li>
<li>4、你要准备好建造地点，打好地基，搭建框架，砌好墙，盖好屋顶，通好水电煤气等。 - 软件的构建（construction）</li>
<li>5、庭院设计师、油漆匠、装修工来将新房子美化一番。 - 软件的优化（optimization）</li>
<li>6、整个过程会有各类检查者检测工地，地基，框架与布线等各类地方。 - 软件的评审（reviews）和详查（inspections）</li>
</ul>
<p>以上两种活动，更高的复杂度与更大的规模都会带来更多的结论。建材与人力的消耗。推到一堵墙后移半米的代价是相当昂贵的。你只有把房屋详细的设计好，才能不浪费资源去修正本可以避免的麻烦。开发软件，或许原材料是廉价的，但是人力成本甚至是市场的机会成本代价高昂。</p>
<p><strong>两类活动还有其他什么相似之处呢？</strong></p>
<p>建造一个房子的时候，你不会去试着建造那些能买到的一些东西。你会去买洗衣机，烘干机，洗碗机，电冰箱，但你们应该不会去自己动手造这些东西。<br>开发软件也一样。不会自己去处理一些系统层次的代码，回去寻找一些开源的程序，现成的能力，比如一些科学计算函数，用户界面组件，数据库访问等。自己编写那些能买到的现成的代码，通常一般情况下是没有太大意义的。</p>
<p>但是，更高一层来说，如果你想建造一间拥有一流家具的高档住宅。那么你可能需要定制洗碗机，电冰箱等高档家电。就如软件开发中一样，如果你要开发一款一流的软件，你就可能需要要自己编写科学计算函数，以获取更高的速度和更高的精准，自己编写容器内用户界面组件以及数据库访问等，使得你的一流的产品的各个部分都无缝连接，拥有一致的外观和体验。</p>
<p><strong>软件构建 类比 建筑构建</strong></p>
<p>适当的多层次的规划，对于建造建筑物和构建软件，都是有较高的好处的，如果你按照错误的顺序构建软件，那么编码测试和调试都很困难，需要花更长的时间才能完成，甚至整个项目干脆就分奔离析，由于每个人的工作都过于复杂，所有成果组合在一起的时候就会变得混乱不堪。</p>
<p>精心计划，并不是说什么事都巨无细的计划或者过度的计划，类似你在考虑房屋结构的时候，主要考虑结构性支撑的规划就行，没必要即可去考虑你是用地板还是瓷砖铺地。软件开发也一样，规划是否得当，体现在项目在后期改变细节上能力扩展的便捷性。</p>
<p>用建筑房屋来类比，软件构建还有助于解释为什么不同软件项目能从不同开发模式中获益。你去盖一间仓库，或者工具间，是盖一个医院，甚至是核反应堆，你在规划设计及质量保证方面的需求程度都是不一样的，所用的方法也是不一样的。所以说，有时软件开发中通常你只需要用灵活的，轻量级的方法，但有时候你就必须用严格的，重量级的开发方法以达到安全性目标，或者其他什么目标。</p>
<p>最后，建筑这一隐喻，让我们对超大型的软件项目认识更加深刻。超大型的结构一旦出问题，后果是非常严重的，所以有必要对这样的结构进行超出常的规划和建设。建筑人员需要非常小心的定制并核查计划，规划在建筑时留有余地，以保障安全。宁可多花10%的成本买更坚固的材料，也比摩天大楼倒下来划算的多。在美国纽约帝国大厦建造的时候，每辆运料车的运输时间都有会留有15分钟的余地，但如果每辆车在运输的时候没有指定到位，那么整个工期都会延误。</p>
<p>按房屋建造这一隐喻，很多软件开发中的术语都是从建筑中衍生而来的。软件架构、支撑性测试代码、构建、基础类等。</p>
<p>对于隐喻来说，不同的隐喻彼此并不排除，但使用恰当的隐喻能带来更多的优势，比如评估问题处理方式，相关优先级的思考，代码的编写逻辑与质量等。</p>
<h2 id="三思而后行：前期的准备"><a href="#三思而后行：前期的准备" class="headerlink" title="三思而后行：前期的准备"></a>三思而后行：前期的准备</h2><p>准备工作的中心目标是降低分险：一个好的项目规划者能够尽可能早的将主要的风险清除掉，使项目的大部分工作能够尽可能的平稳进行。</p>
<p>软件中最常见的项目风险是糟糕的需求分析和糟糕的项目计划，因此准备工作就倾向于集中改进需求分析和项目规划。</p>
<ul>
<li>1、并不是所有的专业的程序员都知道准备工作的重要性，并且在进入构建活动之前会去检查所有的先决条件是否已满足</li>
<li>2、大部分分配做前期准备活动的开发人员并不具备完成这项任务的专业技能。项目规划，分析全面而准确的需求，创建高质量的架构活动等等，都需要较高的经验与技能。</li>
<li>3、有很大一部分程序员，知道如何进行前期工作，但是并没有去做，因为他们不能够抵抗尽快开始编程的欲望，以及从项目侧的一些排期压力。</li>
</ul>
<p>比如在除了程序员侧各方看来，在项目开发阶段，他们只是关心100个功能每天实现多少，几天可以全部完成。这是从他们角度所关心的，并没有错。而程序员角度上，我们需要关心的则更多，以及如何更简单的或者朦胧的回答我们做的不仅仅是完成功能那么简单。</p>
<p>实现高质量的实践方法是那些能创建高质量代码的程序员的共性，很重要的一点是在项目的前期、中期以及后都强调质量。这也是《代码大全》要讲诉的整体主要内容。</p>
<h3 id="问题定义的先决条件"><a href="#问题定义的先决条件" class="headerlink" title="问题定义的先决条件"></a>问题定义的先决条件</h3><p>首先要满足的一项条件是：对这个系统要解决的问题做出清楚的描述。这个更多偏向于PM对于产品的定位，而程序员也应当明确的知道我们的目标以及面对的问题。</p>
<h3 id="需求的先决条件"><a href="#需求的先决条件" class="headerlink" title="需求的先决条件"></a>需求的先决条件</h3><p>明确需求的意义：</p>
<ul>
<li>1、有助于用户，而非单单程序员驾驭系统的能力。也避免程序员在编程期间自行决定一些含糊不清的需求。</li>
<li>2、有助于避免争论。目前RD与PM之间的摩擦大部分是由于需求在一定角度上不明确产生的。</li>
<li>3、有助于开始编程开发后的系统变更情况。或许代码上的错误，你只需修改几行就能解决，但是如果是需求上的错误，那就有可能需要整体改变设计与架构。</li>
</ul>
<p>众多组织数据显示：大型项目中，在架构阶段检测到需求错误，其修复成本是：需求阶段检测并修复的成本的3倍。编码阶段检测到需求错误，成本是5-10倍。系统测试阶段是10倍。发布阶段是10到100倍。</p>
<p>所有详尽的需求描述，是项目的关键。甚至一些情况可能比有效的架构技术更重要。</p>
<h3 id="需求稳定的神话"><a href="#需求稳定的神话" class="headerlink" title="需求稳定的神话"></a>需求稳定的神话</h3><p>需求稳定是软件开发的圣杯。项目就能有序的、可预测的、平稳的进行，完成架构到设计到编码到测试等一系列工作。早期IBM与其他公司数据显示，开发过程中平均会有25%的需求变更，因变更导致的返工预占比75%以上。这主要是1980年到2000的相关，目前的程序员或许相对来说对于变更更加适应一些或者做好来一些预设的准备，但数据上估计没有太好的改善。</p>
<p>我们如何预备应对需求变更？</p>
<ul>
<li>1、使用需求质量核对表来评估你的需求质量：开车开错的地点，下车检查路线肯定不算是浪费时间。</li>
<li>2、确保相关方明确了解需求变更的代价：提及进度与成本，往往对各方有效，许多必须有可能就变成来最好有。</li>
<li>3、建立变更的控制机制</li>
<li>4、使用能适用变更的开发模式：比如敏捷开发，缩短开发周期，更快速的需求迭代等。</li>
<li>5、放弃项目</li>
<li>6、注意项目商业案例</li>
</ul>
<p><strong>需求核对表</strong></p>
<ul>
<li>功能需求：明确功能的各项细节，包括输入输出，软硬件借口与通讯协议，用户期望功能，以及各项任务的目的等。</li>
<li>非功能需求：用户的操作，体验，安全性等问题考量。系统的可靠性、可维护性，可扩展性等考量。</li>
<li>需求质量：需求间的一致性，清晰详细程度，健壮性与正确性等。测试变更状态等调整的应对。</li>
<li>需求完备性：对于需求产出前的前置依赖，需求不完善或者变更后的可接受程度等。</li>
</ul>
<h3 id="架构的先决条件"><a href="#架构的先决条件" class="headerlink" title="架构的先决条件"></a>架构的先决条件</h3><p>软件架构是软件设计的高层部份，用于支持软件更细节的一些设计与开发工作。离开了良好的架构，可能瞄准来正确的问题方向，但却使用来错误的解决方案，导致来不成功的构建。</p>
<h4 id="架构的细节组成部份"><a href="#架构的细节组成部份" class="headerlink" title="架构的细节组成部份"></a>架构的细节组成部份</h4><ul>
<li>1、程序组织：首先要以概括的形式将有关系的系统做出分解和概述。定义程序的主要的构造块，更具程序规模不同，每一个构造块可以是单个类也可以是子系统等，各自实现一种高层功能，相互协调产生了系统。</li>
<li>2、主要类：应当较为详细的定义主要类。80&#x2F;20法则，对于构成80%行为的20%的类进行详细说明。</li>
<li>3、数据设计：应当描述主要文件与数据表的设计。包括设计某种模式（数据结构与算法）的原因与考虑点等，以方便后期的维护。</li>
<li>4、业务规则：关于业务内特定的业务逻辑，以及对于系统的设计影响。</li>
<li>5、用户界面设计</li>
<li>6、资源管理：对于稀缺资源的管理计划，包括数据库链接、线程、内存等整体的规划。</li>
<li>7、安全性：设计实现设计层面与代码层面的安全性问题。比如处理缓冲区方法，处理未经处理数据（用户输入、cookie、配置数据等）的规则，加密，错误处理程度等事宜。</li>
<li>8、性能：评估数据量，复杂程度以确定系统达到性能目标。</li>
<li>9、可伸缩性：系统增长、扩展在系统各方面满足未来的能力。</li>
<li>10、互用性：系统与其他软硬件的共享数据或者资源。</li>
<li>11、国际化&#x2F;本地化</li>
<li>12、输入与输出：定义数据的读取策略，以及错误检测的处理位置。</li>
<li>13、错误处理：由于错误处理牵扯整个系统，最好在架构层次上对待明确。</li>
<li>14、容错性：定义所期望的所有容错类型，作为增强系统可靠性的方式，包括错误检测以及错误回复等。</li>
<li>15、架构的可行性：关注系统的各项能力是否符合标准，比如性能目标、资源与环境支持度等。</li>
<li>16、过度工程：健壮性表示系统检测到错误后继续容错运行的能力。架构时需要明确，是应该做出最简单的能工作的东西还是为了机身起见宁可过度工程。避免系统中某些类异常健壮，而其他类勉强健壮。系统的强度不是取决于最薄弱的环节，而是所有薄弱环节的乘积。</li>
<li>17、关于买还是造的决策：最激进的构建解决方案就是更不不去构建，直接购买或者使用开源软件。其取决的条件在于我们自己定制的组件，应该在某些方面胜过现成的程序库和组件，并且收益与成本是正向的。</li>
<li>18、复用决策：如何复用软件的加工使之符合其他架构的目标</li>
<li>19、变更策略：应列出有可能的增强性的功能，并且考虑其扩展接入的方式。</li>
<li>20、架构的总体质量：<br>优秀的架构文档特点在于，讨论系统中的类，每个类背后的隐藏信息，各类方案采纳或者被替换的根本理由等。架构应该是带有少许特别附加物的精炼且完整的概念体系。是《人月神话》的中心主题。<br>优秀的软件架构和机器与语言无关，应当明确指出风险并且解释，多个视角看待项目。不应当包含任何对你而言难以理解的东西。</li>
</ul>
<h1 id="创建高质量的代码"><a href="#创建高质量的代码" class="headerlink" title="创建高质量的代码"></a>创建高质量的代码</h1><h2 id="软件构建中的设计"><a href="#软件构建中的设计" class="headerlink" title="软件构建中的设计"></a>软件构建中的设计</h2><p>许多软件构建的设计就是程序员在键盘前完成的，或许用伪类写出一个类的接口，或许编码前画一下几个类的关系图，也可能咨询你下更有经验的程序员。无论何种方式进行，如果能认识到设计在程序员侧也是一项明确的活动，那么我们将受益匪浅。</p>
<p>软件的设计目标是组织良好，干净利落。然而形成的过程却可能了无章法。或许设计时就会犯很多错，但是这正是关键所在，设计阶段的犯错并且加以改正，其代价远远小于编码后发现错误改正的成本。这正是我们所期望的。</p>
<p>软件构建的设计就是确定取舍，调整顺序的过程，并且收到较多的限制，在各类限制条件中寻求方案的过程。是类似启发式，不确定的一个过程，然后自然而然形成的。</p>
<h2 id="关键的设计概念"><a href="#关键的设计概念" class="headerlink" title="关键的设计概念"></a>关键的设计概念</h2><p>软件的首要技术使命：管理复杂度</p>
<p>《没有银弹：软件工程中本质性与偶然性》Fred Brooks（《人月神话》的作者）。</p>
<p><strong>偶然的难题与本质的难题</strong></p>
<p>Fred Brooks 引用了一个哲学的概念来说明：本质属性是一件具体事物必然具备的属性。偶然属性则表示一件事物恰好具备来某些属性。</p>
<p>类似与软件开发，其中大部分偶然性难题在很多已经被解决。比如一些与笨拙语法相关的偶然性难题，基本随着语言的迭代与发展被清晰的解决处理，那么显然这些问题的重要性也会逐渐下降，比如早期低端操作系统的各类问题。但是剩下的本质性问题，相对解决的比较缓慢。</p>
<p>本质上来说，软件开发意味着不断的去发掘复杂的、相互链接的一套系统的所有细节。本质性的困难来自多方面：面对复杂和无序的现实世界、精确并且完整的识别依赖与特例、设计准确性高的解决方案而非一般方案、并且人类对于认识现实世界本身都还有很大困难，那么基于此的软件开发来解决大规模的现实问题，难度可想而知。</p>
<p>但是，不论是偶然性问题还是本质性问题，其触发的根源都在与 复杂度。</p>
<p><strong>管理复杂度的重要性</strong></p>
<p>在做项目失败的原因确认时，很少会将技术原因作为项目失败的主要原因。或许是不尽人意的需求、规划或者管理。但是如果确定是技术原因导致的失败，那么一定是失控的复杂度。软件变得极端复杂，开发者无从知晓模块的功能、逻辑等，完全无法维护的状态，那么项目就估计快停了。</p>
<p>所以说，在作者看来：软件的首要技术使命便是管理复杂度。</p>
<p>类似我们的大脑，软件开发人员不应该尝试在同一时间将整个持续程序塞进去，而是应该试着以某种合理的方式去组织程序，以便在任意一个时刻，我们都是专注于某一个特定的部分，减少时间点上所需要考虑的程序量级。</p>
<p>例如：将系统分解为多个子系统，各项子系统之间减少互相依赖。保持子系统的短小精悍也有助于减少思考的负担。从问题入手而不是直接从底层去实现细节编程，在最抽象的层次工作。</p>
<p><strong>高代价、低效率问题</strong></p>
<ul>
<li>1、复杂的方法解决简单的问题</li>
<li>2、简单但是错误的方法解决复杂问题</li>
<li>3、不恰当的方法解决复杂问题</li>
</ul>
<p>类似编写一个基础函数，开发者应该首先明确这是基于固定场景的，还是基于当前系统基础的，还是准备开源做到较多形式的支持的。都会影响我们对于当前函数、参数、细节实现的复杂度确定。</p>
<p>那么，将同一时间需要处理的本质复杂度降低到最小，并且不要让偶然性的复杂度无所谓的快速增长是一个不错的方式。</p>
<ul>
<li>1、最小的复杂度。设计的主要目标是降低复杂度，避免做出自认为聪明的设计，往往聪明的设计会难以理解。</li>
<li>2、易于维护。开发过程中，应当不断考虑逻辑、细节对于后期维护人员是否会产生负担，更多的产出可自说明的系统。</li>
<li>3、松散耦合。在设计时，让各个组成部份关联最小。通过合理的抽象、封装、隐藏信息等进行优化，减少关联依赖，并且对于强关联的逻辑业务能合理的设计与处理。</li>
<li>4、可扩展性。增强系统能力而无需破坏基础结构，通过改动某一部分而不影响系统其他部份。</li>
<li>5、可重用性。系统的组成部份能在其他系统中复用。</li>
<li>6、高扇入与低扇出。让大量的类使用某个给定的类，意味着很好的利用了较低层次上的工具类。一个类内少量或者适中的使用其他类减小过分依赖与复杂。</li>
<li>7、可移植性。相对于系统能较方便的迁移至其他环节。</li>
<li>8、精简性。系统没有多余的部份来添加成本。</li>
<li>9、层次性。尽量保持系统各个分解层的层次性，使我们可以在各层次上观测系统。</li>
<li>10、标准技术。制定系统的标准化、常用的方法等。如基础技术栈，基础函数库等。</li>
</ul>
<h2 id="设计构造块：启发式方法"><a href="#设计构造块：启发式方法" class="headerlink" title="设计构造块：启发式方法"></a>设计构造块：启发式方法</h2><p><strong>找出现实世界的对象</strong></p>
<p>辨识对象，以及其属性。确定对象可进行的操作以及可对其他对象进行的操作。对象各部分的公有、私有属性。开放的公共接口。</p>
<p><strong>形成一致的抽象</strong></p>
<p>抽象是让你在关注某一概念的同时可以放心的忽略其中一些细节的能力。类似与可以在不同层次处理不同的细节。如我们把一类东西成为房屋，而不是玻璃、木材、钢筋等组合体，就相当于是在抽象的表现来。</p>
<p>基类也是抽象，集中注意力关注一组派生类的共同特性，在此基础上去忽略派生类的其他的一些细节。很大程度上，抽象能让我们在复杂的状态下专注于某些点，忽略无关的细节，降低思考上的复杂度。</p>
<p><strong>封装实现细节</strong></p>
<p>封装是对于抽象的补充，很多抽象不关注的细节，我们就可以使用封装来进行处理，隐藏重要性不高的一些复杂度上的细节。</p>
<p><strong>继承简化设计</strong></p>
<p>继承的好处在于可以很好的支持抽象的概念，继承简化编程工作，你可以写一些子程序拥有基本属性的项，然后另一些处理依赖基本类的特定的类。</p>
<p><strong>信息隐藏</strong></p>
<p>信息隐藏是结构化程序和面向对象设计的基础之一。也是首要技术使命中重要的启发式方法，其强调的就是隐藏复杂度。</p>
<p>设计一个类，一项关键性的决策就是确定类那些特性应该对外可见，哪些特性应该隐藏。好的类接口应该犹如冰山，让类的大部分内容不会暴露。</p>
<p>1、隐藏复杂度，我们一般情况就无需关注细节的复杂度<br>2、隐藏变化源，变化影响限制在固定范围内。</p>
<p><strong>找出容易改变的区域</strong></p>
<p>好的程序设计面临的重要的挑战就是适用变化，目标应该将不稳定区域隔离，将变化带来的影响限制在一个子程序或者一个类的内部。使得系统内你能考虑到的变化的可能性与其影响范围成反比。</p>
<p><strong>保持松散耦合</strong></p>
<p>耦合度表示类或者子程序之间关系的紧密程度。其设计目标是创建出小的，直接的，清晰的类或者子程序，使之间的关系尽量灵活，即松散耦合。</p>
<p>耦合的种类：</p>
<ul>
<li>1、简单数据参数耦合：两个模块通过参数来传递数据，并且参数均为简单数据类型。耦合关系正常，可接受。</li>
<li>2、简单对象耦合：为模块实例化出的一个对象，两者的关系。该耦合关系也是正常的。</li>
<li>3、对象参数耦合：传递数据的参数为对象，那么调用方需要了解参数对象的细节，那么相对来说耦合关系会紧密一些。</li>
<li>4、语义上的耦合：最复杂的耦合关系，两者间不仅使用来语法上的逻辑，还是用了模块内部工作细节。</li>
</ul>
<p>如：</p>
<ul>
<li>1、M1向M2传递一个控制标识，告诉M2来做什么。那么就需要M1对M2内部工作细节有所了解，对于控制标识是如何使用的。</li>
<li>2、M2在M1修改来全局变量或者闭包数据后使用数据。这就需要M2对M1数据的修改都符合M2的需求。</li>
<li>3、M1要求在调用M1.B()时必须先进行初始化 M1.A()，而M2知道内部逻辑，在调用M1.B() 时必然会调用初始化，所有直接调用M1.B()。</li>
</ul>
<p><strong>设计模式</strong></p>
<p>常见的设计模式：适配器、桥接、装饰器、工厂方法、观察者、单例、策略等。</p>
<p>设计模式通过现成的抽象来减少复杂度。将常见的解决方案细节予以制度化来减小出错。并且通过多种设计方案带来启发性的价值。以及将设计对话提升到更高层次上来简化交流。</p>
<p>设计模式潜在的陷阱是：强迫代码适用某个模式，如果对于代码做微笑的调整来符合某种通用的模式，可以使得代码梗易于理解，但是如果做巨大改动，强迫去符合某个标准模式，反而会增加复杂度。</p>
<p>设计模式是一种强大的管理复杂度的工具，但是不要为了模式而模式。</p>
<p><strong>其他启发式方法</strong></p>
<p>高内聚性、构造分层结构、严格描述类说明、分配指责、画一个图、保持设计的模块化等。</p>
<h2 id="可以工作的类"><a href="#可以工作的类" class="headerlink" title="可以工作的类"></a>可以工作的类</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型指一些数据以及这些数据所进行的操作的集合。把其定义为有一组操作的数学模型太过空洞。将链表中添加一个节点，你可以看做表中插入单元格，火车模型添加车厢等形象问题。</p>
<p>比如编写的程序内，可以使用不同的系统字体、字号以及文字属性的功能，如果我们将其作为一个抽象数据类型，那么我们就可以将设置的数据值以及相关的设置操作作为一个抽象数据类型进行考虑可管理。（可以看做如何抽象一个子程序的逻辑）</p>
<p>一般业务逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFont.size = 16;</span><br><span class="line">currentFont.bold = true;</span><br></pre></td></tr></table></figure>

<p>抽象数据类型: 子程序代码或许很短，但是你将字体的各类操作进行了独立与隔离，这样就为其他部分程序提供了更好的抽象。对于字体操作提供一层保护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentFont.setSize(16);</span><br><span class="line">currentFont.setBoldOn();</span><br><span class="line">currentFont.setBoldOff();</span><br></pre></td></tr></table></figure>

<ul>
<li>1、隐藏实现细节</li>
<li>2、该抽象上的改动不影响整个持续</li>
<li>3、关注点更聚焦，提供相关联的依赖接口</li>
<li>4、更易提高性能</li>
<li>5、程序的正确性更显而易见</li>
<li>6、程序更具有自我说明性</li>
<li>7、数据传递与依赖更小化</li>
<li>8、操作实体而无需关心底层实现上的操作</li>
</ul>
<h3 id="良好的类接口"><a href="#良好的类接口" class="headerlink" title="良好的类接口"></a>良好的类接口</h3><p>创建高质量的类，第一步就行创建一个好的接口，通过接口合理的展现和隐藏抽象。主要的评估方法为类所具有的公共子程序所构成的集合，即类的公共接口的合理性。</p>
<ul>
<li>1、类的接口的抽象层次应该是一致的。比如对于雇员列表的雇员添加与删除，获取指定的雇员信息等，对于雇员类来说设计获取其相关信息而非同一层上的抽象。</li>
<li>2、需要明确我们抽象的是什么，需要处理的问题是什么，才能较好的梳理出合理的接口。</li>
<li>3、提供成对的服务，比如字体开启与关闭加粗模式等。</li>
<li>4、接口可编程而非表达语义。每个接口都应该是可编程部份+语义部份组成，可编程部份可做相关的检测判定。</li>
<li>5、注意与接口抽象不一致的公共成员。</li>
<li>6、抽象性和内聚性考虑。</li>
</ul>
<p><strong>良好的封装</strong></p>
<p>封装是一个比抽象更强的概念，如果没有封装，抽象很容易就被打破，无法较好的实现。</p>
<ul>
<li>1、尽可能限制类和成员的可访问性</li>
<li>2、不要公开成员数据</li>
<li>3、避免私有的实现细节放在接口中</li>
<li>4、不要对于使用类的开发者做任何假设</li>
<li>5、让阅读代码比编写代码更容易</li>
<li>6、注意语义上的封装性的破坏</li>
<li>7、注意耦合关系</li>
</ul>
<h3 id="设计与实现的问题"><a href="#设计与实现的问题" class="headerlink" title="设计与实现的问题"></a>设计与实现的问题</h3><p><strong>继承</strong></p>
<p>继承表示一个类是另一个类的一种特化。其目的在于『定义能为两个类或者更多派生类提供共有元素的基类』，来精简代码。</p>
<ul>
<li>1、继承增加程序复杂度，所有必须详细说明或者不使用。</li>
<li>2、确保我们只是继承需要的部分。</li>
<li>3、将公共的接口、数据以及操作放到较高位置。</li>
<li>4、只有一个实例的类和只有一个派生类的基类需要重新评估创建的类必要性。</li>
<li>5、避免继承体系过深，以及多态导致大量的类型检查。</li>
</ul>
<p><strong>继承的规则</strong></p>
<ul>
<li>1、多个类共享数据而非行为，应该创建公共对象。</li>
<li>2、多个类共享行为而非数据或者共享数据以及行为时，应该让类从共同的基类继承而来，基类定义公用的子程序以及数据。</li>
</ul>
<p><strong>构造函数</strong></p>
<ul>
<li>1、如果可以，在构造函数中初始化所有数据成员。</li>
<li>2、优先使用深拷贝，除非论证可行才使用浅拷贝。</li>
</ul>
<h4 id="创建类的原因"><a href="#创建类的原因" class="headerlink" title="创建类的原因"></a>创建类的原因</h4><ul>
<li>1、为现实世界中的对象建模。为现实世界每一个对象类型建模是一个重要的理由。</li>
<li>2、为抽象对象建模。比如经典的 Shape（形状）对象，及其派生的 Circle、Square等。</li>
<li>3、降低复杂度。降低软件首要使命的难度，创建类后隐藏信息和细节，使我们无需再去考虑。</li>
<li>4、隔离复杂度。隔离复杂的算法、大型数据集、复杂的各类协议等容易引发错误的点，分类集中管理。</li>
<li>5、隐藏实现细节。对于软件，我们不可能存入整个细节图，而是分块，分层的处理。</li>
<li>6、限制变动的影响范围。</li>
<li>7、隐藏全局数据。</li>
<li>8、参数传递顺畅。</li>
<li>9、建立中心控制点。</li>
<li>10、代码易于重用。</li>
<li>11、相关操作分类。</li>
</ul>
<h2 id="高质量的子程序"><a href="#高质量的子程序" class="headerlink" title="高质量的子程序"></a>高质量的子程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line"></span><br><span class="line">void Handlestuff(CORP_DATA &amp; inputrec, int crntqtr, EMP_DATA emprec, double &amp; estimrevenue, double ytdrevenue, int screenX, int screenY, COLOR_TYPE &amp; newcolor, COLOR_TYPE &amp; prevcolor, StatusType &amp; status,</span><br><span class="line">int expensetype)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i＝0; i＜100; i++) &#123;</span><br><span class="line">    inputrec.revenue[i] = 0;</span><br><span class="line">    inputrec.expense[i] = corpexpense[ crntqtr ][ i ];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">UpdateCorpDatabase( emprec );</span><br><span class="line">estimrevenu =  ytdrevenue * 4.0 / (double) crntqtr;</span><br><span class="line">newcolor= prevcolor;</span><br><span class="line">status = SUCCESS;</span><br><span class="line">if (expensetype == 1) &#123;</span><br><span class="line">    for(i＝0;i＜12;i++) &#123;</span><br><span class="line">        profit[i] = revenue[i] -expense.type1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">else if (expensetype == 2 )&#123;</span><br><span class="line">    profit[i] = revenue[i] - expense.type2[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (expensetype == 3)&#123;</span><br><span class="line">    profit[i] = revenue[i] - expense.type3[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码有什么样的问题，有一些很明显的问题，还有一些我们没注意，自己也经常犯的问题。</p>
<p>1、命名较差，完全不清楚子程序是干什么的<br>2、没有文档说明<br>3、缩进布局很差<br>4、输入变量 inputrec 被重写<br>5、读写全局变量 profit<br>6、子程序没有单一的目的，初始化重写输入，更新数据库，计算，重写全局变量，完全无相关联系的操作。<br>7、缺少防御性 crntqtr &#x3D; 0 时的问题<br>8、各类神秘数值 100、4.0、12、1、2、3等<br>9、未使用的参数 screenX、screenY<br>10、参数过多，建议上线为7<br>11、参数顺序混乱无注释</p>
<p>创建一个子程序有很多合理的原因，但是完成它的方式却分对错。</p>
<h3 id="创建子程序的理由"><a href="#创建子程序的理由" class="headerlink" title="创建子程序的理由"></a>创建子程序的理由</h3><ul>
<li>1、降低复杂度，因为我们软件工程的首要技术使命就是管理复杂度。</li>
<li>2、引入中间、易懂的抽象，比如哗啦啦写了一堆逻辑处理代码，或者将其放到子程序中，命名：GetLeafName。</li>
<li>3、避免代码重复，这是创建子程序的最普遍的原因。</li>
<li>4、支持子类化，覆盖简短而规整的子程序所需要的代码比冗长邋遢的代码要少，并且减少犯错。</li>
<li>5、隐藏顺序，将细节执行顺序集中隐藏，而非到处散布。</li>
<li>6、隐藏指针操作。</li>
<li>7、提高可移植性。子程序隔离不可移植部份明确移植的兼容开发。</li>
<li>8、简化复杂的布尔判断。为理解程序的流程，通常没有必要去研究那些复杂的布尔判定的细节，将其放到子函数中提高整体可读性。</li>
<li>9、改善性能。子程序可以是我们集中一处单一功能点进行优化，并且使用更高效的算法和更快的语法也更容易调整。</li>
</ul>
<p>编写子程序较大的心理障碍是：不情愿为一个简单目的而写一个简单的子程序，看起来大材小用，并且比较低端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一个简单的 deviceUnits 到 points 单位转换</span><br><span class="line">points = deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() )</span><br><span class="line"></span><br><span class="line">// 封装子程序后</span><br><span class="line">function deviceUnitsToPoints(deviceUnits) &#123;</span><br><span class="line">    return deviceUnits * ( POINTS_PER_INCH / DeviceUnitsPerInch() );</span><br><span class="line">&#125;</span><br><span class="line">points = deviceUnitsToPoints(deviceUnits);</span><br></pre></td></tr></table></figure>
<p>封装子程序后，那么很多使用改转化的地方都可以统一使用子程序，进行集中管理。应对以后转化会变得更复杂的情况（比如对于 DeviceUnitsPerInch 的调用判定等 ）。并且子程序的命名是我们可以忽略执行细节让代码具有自我注解的能力。</p>
<h3 id="子程序的设计"><a href="#子程序的设计" class="headerlink" title="子程序的设计"></a>子程序的设计</h3><p>对于子程序而言，内聚性指子程序中各种操作之间联系的紧密程度，目标是让每一个子程序只把一件事情做好。</p>
<p>功能的内聚性：是最强最好的一种内聚性，让一个子程序只执行一项操作。我们可以观察到很多系统底层或者语言底层的基础子程序基本都是功能内聚的。</p>
<p>不够理想的：</p>
<p>顺序上的内聚性：指子程序内包含需要按顺序执行操作多个功能，按步骤共享数据的。建议按功能拆分解耦。</p>
<p>通讯上的内聚性：仅仅是子程序内不同操作使用的想同的数据，但操作不存在任何联系的。</p>
<p>临时的内聚性：一些因为需要同时执行才放到一起的子程序。比如我们在编写完一个大而冗余的代码时，加个init初始化函数，然后一股脑的吧开始需要执行的代码扔进来。临时性的子程序应当看做一系列时间的组织者，init可以包含读取配置文件，初始化数据等操作的管理者。应当明确内部的执行意义。</p>
<p>不可取的：过程上的内聚性，逻辑上的内聚性，巧合的内聚性。</p>
<h3 id="好的子程序名字"><a href="#好的子程序名字" class="headerlink" title="好的子程序名字"></a>好的子程序名字</h3><p>1、描述子程序所做的所有事情。ComputeReportTotals 还不算完整，ComputeReportTotalsAndOpenOutputFile 算是完整，但是太长。如果子程序含有副作用，那么就会产生又笨又长的名字</p>
<p>2、避免无意义、模糊或者表达不清的动词。HandleCalculation, OutputUser, DealWithOutput 这类的是完全无法说明程序做了什么，达不到自我注解的程度。比如将 DealWithOutput 改为 FormatAndPrintOutput 就明了很多。</p>
<p>3、不要通过数字来形成不同的子程序。</p>
<p>4、控制子程序名字的长度，变量名一般建议9-15字符，好的子程序名字可以更长一些，视是否清晰易懂而定。</p>
<p>5、对返回值有所描述。cos(), userID.next(), printer.isReady() 等都是不错的例子。</p>
<p>6、给过程起名格式建议动词+宾语的形式。过程应当反应所做的事情。如printDocument(), checkOrderInfo()等，面向对象中则为 document.print()。</p>
<p>7、使用对账词。add&#x2F;remove, insert&#x2F;delete, open&#x2F;close, show&#x2F;hide, create&#x2F;distroy 等。</p>
<p>8、为常规操作确定规则。统一 employee.id(), employee.get(), employee.getId()等不一致。</p>
<h3 id="子程序长度"><a href="#子程序长度" class="headerlink" title="子程序长度"></a>子程序长度</h3><p>如果一个子程序大于200行，我们可能需要注意，是否会影响我们的维护成本。</p>
<h3 id="子程序参数"><a href="#子程序参数" class="headerlink" title="子程序参数"></a>子程序参数</h3><p>比如使用所有参数，状态或者出错变量放置最后，不要把参数作为工作变量，数量限制在7个以内等。</p>
<h2 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h2><p>主要思想是：子程序不应该因传入错误数据而被破坏，哪怕是其他子程序产生的错误数据。健壮模式应该检查所有外部的数据源以及子程序的参数，并且确定如何处理错误的输入。</p>
<h3 id="错误处理技术"><a href="#错误处理技术" class="headerlink" title="错误处理技术"></a>错误处理技术</h3><ul>
<li>1、返回中立值。处理错误最佳的方式是继续执行操作，简单返回一个无危害的数值。</li>
<li>2、换用下一个正确的数据。比如处理数据流时，继续读取知道正确的数据。</li>
<li>3、警告信息记录日志。</li>
<li>4、返回错误码。指定统一的错误码表进行处理。</li>
<li>5、调用错误处理子程序或者对象。统一标准化处理错误情况。</li>
<li>6、显示出错信息。</li>
<li>7、局部处理错误。这个模式给予程序员很大的灵活度但是也带来很大分险。</li>
<li>8、关闭程序。</li>
</ul>
<p>正确性意味着永远不返回不准确的结果，哪怕不返回结果。健壮性意味着不断的尝试采取措施保障软件继续运行下去，哪怕一些结果不准确。人身安全攸关的更倾向于正确性而非健壮性，比如放射性治疗仪。消费类软件则注重健壮性而非正确性，我们并不期望因为数据的错误直接关闭软件的形式。</p>
<h3 id="防御式编程的姿态"><a href="#防御式编程的姿态" class="headerlink" title="防御式编程的姿态"></a>防御式编程的姿态</h3><p>防御式编程存在一种矛盾，开发阶段希望错误引人注意，而发布阶段尽可能的偃旗息鼓。</p>
<p>保留那些检查重要错误的代码，去除细节错误检查的代码，去除导致崩溃的代码，记录错误信息。</p>
<p>过度防御式编程也会引发问题，如果每一个地方使用所有的方法检测参数数据，那持续将变得臃肿而缓慢以及无止境的提高了程序的复杂度。所有考虑好那些地方需要进行防御以及因地制宜的调整防御式编程的优先级。</p>
<h2 id="伪代码编码过程"><a href="#伪代码编码过程" class="headerlink" title="伪代码编码过程"></a>伪代码编码过程</h2><p><img src="http://image.freefe.cc/Snipaste_2019-06-09_13-48-33.png" alt="image"></p>
<p>创建类的总体设计：定义类的职责，所有需要隐藏的信息，精确的定义类的接口等各类信息。<br>创建类中的子程序：创建需要的子程序，在过程中可能还会引出各类重要的不重要的子程序等。<br>复审并测试整个类：对类进行整体测试以发现在该类层面的问题。</p>
<p>子程序的实现基本都是简单、直接了当的。</p>
<p>伪代码指某种用来描述算法、子程序、类或者完整程序的工作逻辑，非标准的记法。伪代码编程过程通过书写伪代码而更高效的创建程序代码的方法。</p>
<p>1、用英语或者其他语言来精确描述特定操作。<br>2、避免使用特定的语言中的语法，在一个比代码层次略高的层面上设计。<br>3、在基于真正的目的层面上编写伪代码</p>
<p>伪代码逻辑完毕后，我们应该可以基于此来实现生成代码，同时可以将伪代码转化为注释，更好的解释说明代码的用意。</p>
<p>1、这类模式的伪代码使我们项目、代码评审变得更为容易。<br>2、伪代码支持反复的迭代精华思想。<br>3、伪代码是我们变更更加容易。<br>4、使代码的注释工作变得更少。<br>5、比其他形式的设计文档更易于维护。</p>
<h3 id="编写子程序"><a href="#编写子程序" class="headerlink" title="编写子程序"></a>编写子程序</h3><p><img src="http://image.freefe.cc/2019-06-09_14-25-38.png" alt="image"></p>
<p>首先写出子程序接口声明。将首尾语句填充（函数申明，大括号区域等）并且将伪代码变为注释。虽然还没有任何代码，但是通过注释能理解整体的工作流程。而后填充代码以及编码工作。开发过程中，期间不断以及验证工作，最后进行收尾工作。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>利用构建活动来填补需求以及架构中存在的细小间隙问题是一种行之有效的做法。但是将蓝图设计精细到完全展现出细节则是一种低效的做法。构建活动中基础的组成就是变量的使用。变量同时指代对象和内置数据类型。</p>
<p><strong>隐式声明</strong></p>
<p>隐式变量声明对于任何一种语言都是最具危险的特性。关闭隐式声明，声明全部变量是一种避免问题的很好的做法。</p>
<p><strong>变量初始化原则</strong></p>
<p>不可理初始化数据是产生编程问题常见根源之一。</p>
<p>1、在声明时初始化，作为常用的防御式编程便捷有效的方法之一。<br>2、理想情况，在靠近变量第一次使用的位置申明以及初始化。集中申明的方式更容易出错，易于集中管理却并不易于维护。<br>3、尽可能使用final或者const。在一些明确的情况下，明确申明类型能减少维护的复杂度。<br>4、注意计数器与累加器的变量。<br>5、类的构造函数内初始化数据成员。易于管理降低复杂度以及方便底层的内存管理等。<br>6、设置编译器自动初始化以及其警告信息。</p>
<p><strong>作用域</strong></p>
<p>作用域或者可见性指的是变量在程序内的可见与可引用范围。各类语言处理方式肯不太一样。</p>
<p>介于同一变量多个引用点之间的代码，可称为攻击窗口。窗口内的操作就有可能引发变量北重置等问题。</p>
<p>把变量的引用点集中起来能较好的提高程序的可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// e.g. 1</span><br><span class="line">a = 0;</span><br><span class="line">b = 0;</span><br><span class="line">c = 0;</span><br><span class="line">a = b + c; // a跨度2 b跨度1 c跨度0</span><br><span class="line"></span><br><span class="line">// e.g. 2</span><br><span class="line">a = 0;</span><br><span class="line">b = 0;</span><br><span class="line">c = 0;</span><br><span class="line">b = a + 1;</span><br><span class="line">b = b / c; // b平均跨度 0.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://image.freefe.cc/2019-06-09_16-14-04.png" alt="image"></p>
<p>与跨度类似，保持较低的存活时间也是我们的目标，原因与最求较小跨度一致，保持短的存活时间主要也是缩短攻击窗口。降低修改代码对其的影响降低。</p>
<p><strong>减小作用域的原则：</strong></p>
<ul>
<li>1、循环开始时初始化循环使用的变量。</li>
<li>2、变量使用之前再申明赋值。</li>
<li>3、将相关语句集中在一起。</li>
<li>4、将相关语句组提取成单独的子程序。</li>
<li>5、开始使用最严格的可见性，然后更具需要扩展变量作用域。</li>
</ul>
<p>有的程序员将很多变量放置到全局中，因为全局变量使用最为方便，无需考虑作用域相关的规则。其他程序员尽可能的使用变量局部化，有助于提高智力上的可管理性。『方便性』和『智力可管理性』两种理念归根结底是侧重写程序还是读程序。当然我们需要侧重的点是显而易见的。</p>
<h3 id="变量名的力量"><a href="#变量名的力量" class="headerlink" title="变量名的力量"></a>变量名的力量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// e.g. 1</span><br><span class="line">x = x - xxx;</span><br><span class="line">xxx = fido + salesTax( fido );</span><br><span class="line">x = x + lateFee( x1, x ) + xxx;</span><br><span class="line">x = x + interest( x1, x );</span><br><span class="line"></span><br><span class="line">// e.g. 2</span><br><span class="line">balance = balance - lastPayment;</span><br><span class="line">monthlyTotal = newPurchases + salesTax( newPurchases );</span><br><span class="line">balance = balance + lateFee( customerID,  balance) + monthlyTotal;</span><br><span class="line">balance = balance + lateFee( customerID,  balance);</span><br></pre></td></tr></table></figure>

<p>很显而易见的一个好的变量名对于可读性、易记性是多么重要。当然变量名需要完全、准确的描述变量所代表的事物。</p>
<p>对于日期，currentDate 和 todaysDate都是较好的名称，直白准确的描述。而current，date其实稍微推敲则并没有明确当前，和日期到底是想描述什么。</p>
<p>一个好的变量名应该是从『what』出发，而不是『how』。一条员工数据可以称作inputRec或者employeeData，inputRec表示一个输入，记录的的计算机概念术语，而employeeData直指问题领域，与计算机无关。</p>
<p><strong>特定类型的数据命名</strong></p>
<p><strong>循环下标命名：</strong><br>i，j，k已经是约定俗成的。如果需要在循环外或者是较复杂的循环，那么就需要使用一个有意义的命名。</p>
<p><strong>状态变量命名：</strong><br>去一个比flag更好的名字。如果你发现你需要去猜测某段代码时，就该考虑变量的重新命名。猜测谋杀案谁是凶手是ok的，但是猜测代码应该是完全没有必要。</p>
<p><strong>临时变量命名：</strong><br>临时变量也不光应该只是 temp，或者x等模糊缺乏描述性的名字。</p>
<p><strong>布尔变量命名：</strong><br>使用有用的标识，done、error、found、success或者ok等明确的布尔标识。并且尽量使用肯定布尔名，反例 notFound，notDone。<br>尽量赋予真假的含义，部份喜欢添加is，isdone、isFound、isComplete等，优点在于可以将模糊不清的名词，isStatus，缺点在于降低了逻辑表达式的可读，if(isFound) 与 if(found)。</p>
<p><strong>非正式的命名规则</strong></p>
<ul>
<li>1、区分变量名与子程序名字</li>
<li>2、区分类与对象</li>
<li>3、标识全局变量</li>
<li>4、表示成员变量</li>
</ul>
<p>按实际变量名命名含有三类信息：变量内容是什么，数据的种类以及变量的作用域。【标准化的前缀，通用的缩写】</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基础数据类型是构建其他所有数据类型的构造块。</p>
<p><strong>整数</strong><br>注意整数除法。7 &#x2F; 10 &#x3D; 0（JS中数值均为浮点型）。注意整数的溢出。注意中间值的溢出。</p>
<p><strong>浮点数</strong><br>主要问题在于十进制小数不能够精确的用数字计算机中的1与0来表示。避免量级差较大数之间的加减运算，避免等量判断等问题。</p>
<p><strong>字符和字符串</strong><br>注意一些特殊字符，了解你的语言是如何支持Unicode，国际化&#x2F;本地化策略的考虑。</p>
<p><strong>布尔变量</strong><br>使用布尔变量对程序加以文档说明，简化判定逻辑代码。</p>
<p><strong>数组</strong><br>数组需要注意下标边界，多维数组的下标使用顺序等</p>
<h3 id="不常见的数据类型"><a href="#不常见的数据类型" class="headerlink" title="不常见的数据类型"></a>不常见的数据类型</h3><p><strong>结构体</strong></p>
<ul>
<li><p>1、用结构体明确数据关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 容易误解的，无组织的</span><br><span class="line">name = inputName</span><br><span class="line">address = inputAddress</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 对象结构体</span><br><span class="line">employee.name = inputName</span><br><span class="line">employee.address = inputAddress</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>2、简化数据块的操作：传递一批相关数据 or 传递一个包含所有数据的结构体 </p>
</li>
<li><p>3、简化参数列表</p>
</li>
<li><p>4、减少维护：后期删除某一字段，如果是结构体内的，相对就会比较便捷</p>
</li>
</ul>
<p><strong>指针</strong></p>
<p>概念上看，指针包含：内存的某处位置和解释改位置中的内容。</p>
<p><strong>全局数据</strong><br>使用全集数据的风险远大于使用局部数据的情况。</p>
<ul>
<li>1、不经意间修改了全局数据</li>
<li>2、全局数据的使用阻碍代码复用</li>
<li>3、全局数据的使用导致模块代码非确定性的初始化</li>
<li>4、破坏了模块化和智力上的可管理性：其将原本的模块化，集中精力管理一点的模式牵扯到来其他模块。</li>
</ul>
<p>避免使用全局变量，不只是因为它很危险，更由于我们可以使用更好的方法来取代。比如访问器子程序。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="直线型代码"><a href="#直线型代码" class="headerlink" title="直线型代码"></a>直线型代码</h3><p>从数据为中心 转到语句为中心的观点上来。直线型代码的原则就是：按照依赖关系进行排列组织代码，使用好的子程序名、参数列表、注释、变量等，将顺序的关系变得明显，并且利用注释 换行等，将我们的直线型代码更可读、分块更明显。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p><strong>if语句</strong></p>
<p>首先书写正常代码路径，再处理不常见的情况。确保等量的边界判定正确。将正常的情况放在if后面，而非else。并且if内逻辑应当有意义。较多的if else判定建议使用switch等其他结构。</p>
<p><strong>case语句</strong></p>
<p>应使用最有效的排序，简化每个case的操作量。default应该只是检查真正的默认情况或者错误情况。</p>
<h3 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h3><p>循环用来指代任意一种迭代控制结构，使用循环是编程中最复杂的方面之一。也是创建高质量软件的一个决定性因素。</p>
<p><strong>循环的种类</strong></p>
<p>-** 计数循环**：逻辑代码执行次数一定，比如发放每位职员的薪资。</p>
<ul>
<li><strong>连续求值循环</strong>：不确定执行次数，每次执行时检测是否执行完毕。使用场景：一些特殊的条件判定循环，实现不知晓执行的次数，状态由动态变量控制。检测位于头部或者尾部。</li>
<li><strong>无限循环</strong>：启动后无限循环。比如心脏起搏器等</li>
<li><strong>迭代器循环</strong>：对于容器内的每一元素执行，比如一些标准或者类库支持点forEach等</li>
</ul>
<p>主要为灵活度的差异与检测是否执行完毕的位置有所差异。两者也决定了使用哪种循环。for循环使用于简单的用途，你在循环头中写完便可以忘却的不需要再关心的可是使用for，而如果存在一个必需是执行从循环中跳出的那边建设使用while。</p>
<p><strong>循环控制</strong></p>
<p>引发错误的情况：</p>
<ul>
<li>1、忽略或者错误的对循环执行初始化</li>
<li>2、忽略了对累加变量或者其他循环有关的变量执行初始化</li>
<li>3、不准确的嵌套和循环中止</li>
<li>4、错误的增加了循环有关的变量值</li>
<li>5、不准确的循环下标访问</li>
</ul>
<p>两种减少循环问题点方式：</p>
<ul>
<li>1、减少影响循环的因素数量，简化、简化、再简化。</li>
<li>2、将循环内部作为子程序。</li>
</ul>
<p><strong>循环三部分</strong></p>
<ul>
<li>进入循环：一个位置进入，初始化位置，for循环or while循环、</li>
<li>循环体：{}隔离，避免空循环，循环内务操作位置，操作目标点唯一性、</li>
<li>退出循环：确认循环停止并且条件明显，退出使用break和continue小心谨慎</li>
</ul>
<p><strong>循环的长度</strong><br>循环应当尽可能短，若接受编写简单代码原则，应该很少产出大于15-20行的循环。<br>嵌套限制在3层，若过长应当提取子程序或者简化控制结构。<br>子程序的应用。</p>
<h2 id="不常见的控制结构"><a href="#不常见的控制结构" class="headerlink" title="不常见的控制结构"></a>不常见的控制结构</h2><p><strong>子程序多出返回</strong><br>半途退出子程序的方式</p>
<p>1、若是增强可读性，则使用<br>2、防御性代码简化复杂错误处理<br>3、建议减少return数量</p>
<p><strong>递归</strong><br>一个子程序自己负责解决某个问题点一部分，并且将问题分成小块，调用自己来解决每一小块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 递归的快排</span><br><span class="line">function QuickSort(array, firstIndex, lastIndex) &#123;</span><br><span class="line">    if (firstIndex &lt; lastIndex) &#123;</span><br><span class="line">        const pointer = division(array, firstIndex, lastIndex);</span><br><span class="line">        QuickSort(array, firstIndex, pointer -1);</span><br><span class="line">        QuickSort(array, pointer + 1, lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归将自身分解为两部分，计算本次的操作，以及切分更小的操作让自身函数继续执行。<br>小范围的问题，递归能带来简单优雅的解决方案，但范围扩大后带来的复杂度甚至是栈溢出等问题也会比较普遍。通常简单的迭代会更易理解。</p>
<p>1、确认递归能停止<br>2、递归限制在一个子程序<br>3、注意栈空间<br>4、避免递归阶乘或者斐波那契数列：速度缓慢，无法预测内存使用，更高的复杂度。</p>
<p><strong>goto</strong></p>
<h3 id="一般控制问题"><a href="#一般控制问题" class="headerlink" title="一般控制问题"></a>一般控制问题</h3><p><strong>布尔表达式</strong><br>除了最简单的顺序执行控制外，所有控制都依赖布尔表达式。</p>
<p>1、使用true和false进行布尔判定，而非0，1等。reportSelected&#x3D;&#x3D;&#x3D;1，1是无法明确到底是什么概念，是真假还是id等。<br>2、隐式的表达</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(!done)</span><br><span class="line">while(a &lt; b)</span><br><span class="line"></span><br><span class="line">// 而非</span><br><span class="line">if(done === false)</span><br><span class="line">while((a &lt;b) === true)</span><br></pre></td></tr></table></figure>
<p>3、将复杂判定条件赋值给变量，或生成布尔函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e)</span><br><span class="line"></span><br><span class="line">// 变量or函数</span><br><span class="line">const done = a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e;</span><br><span class="line">if(done)</span><br></pre></td></tr></table></figure>
<p>4、更偏向于使用肯定到布尔表达式<br>5、使用括号使表达式更清晰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(a &lt; b === c === d)</span><br><span class="line">//或者</span><br><span class="line">if((a &lt; b) === (c === d))</span><br></pre></td></tr></table></figure>
<p>6、理解各语言内，布尔的求值，判定方式。易错的、短路求值等</p>
<p><strong>复合语句，语句块</strong></p>
<p><strong>空语句</strong></p>
<p><strong>深层嵌套</strong></p>
<p>重新设计if esle执行的判断，重构提取子程序基本能解决该问题。<br>1、重复判定的处理<br>2、转换 if else<br>3、转换 case<br>4、将深层嵌套代码提取子程序<br>5、使用状态变量重写<br>6、明确退出，简化逻辑</p>
<p><strong>控制结构与复杂度</strong></p>
<p>控制结构之所以重要，因为其直接影响代码的整体复杂度。程序复杂度是一个衡量指标，为了理解程序，你必须在同一时间记住的智力实体数量。这类智力游戏是编程中最难的方面之一，需要比任何活动都专心。被打断的成本代价很高。</p>
<p>复杂度的重要性：<br>『有能力的程序员会充分的意识到自己大脑容量是多么有限，所以会非常谦卑的处理编程任务』</p>
<p><strong>降低复杂度的原则</strong><br>1、通过脑力练习提升你的脑力水平<br>2、降低你应用程序复杂度</p>
<p>度量复杂度的方法：<br>1、从1开始，往下运行程序<br>2、遇到下列或者相关关键词，加1：if、while、repeat、for、and、or<br>3、case内每一种情况加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((status = SCUESS) &amp;&amp; done || (!done &amp;&amp; (numLines &gt;= maxLines)))</span><br><span class="line">// 1、if +1、&amp;&amp; +1、|| +1、&amp;&amp; +1  5个决策点</span><br></pre></td></tr></table></figure>
<p>0-5 子程序可能还可以<br>6-10 需要简化子程序<br>10+ 需要优化与拆分</p>
<p>其他类型：数据量、控制结构嵌套层次、代码行数、变量跨度和生存期等。</p>
<p><img src="http://image.freefe.cc/2019-06-16_10-28-00.png" alt="image"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/05/08/imgs-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/imgs-type/" class="post-title-link" itemprop="url">图片类型汇总介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-09T00:00:00+08:00">2019-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>图片按照生成类型可分为点阵图与矢量图两种大体的模式，压缩方式按照质量损耗分有损与无损压缩。</p>
</blockquote>
<h2 id="WebP格式"><a href="#WebP格式" class="headerlink" title="WebP格式"></a>WebP格式</h2><p>WebP是Google推出的相对较新的图片压缩技术，旨在加速网络传输图片的加载速度。支持无损和有损的压缩模式、Alpha透明以及动画等特性。该格式主要基于VP8的图片压缩技术，并且利用预测编码和轻量级的容器模式-仅需给图片增加20字节即可，压缩后大概仅有jpeg的三分之二，不过缺点为其编码占用更多的计算资源，即存在编码时间较长问题。</p>
<h2 id="BMP格式"><a href="#BMP格式" class="headerlink" title="BMP格式"></a>BMP格式</h2><p>即所说的位图，为一种与设备无关的图像格式，为windows操作系统中的标准图像文件格式。图像文件主要由三部分组成：位图头数据结构，包含类型、显示内容等各类信息信息；位图信息数据结构，包含图像的宽、高、压缩方法，以及位图的具体数据以及可选的调色板。由于为无损的数据格式，所以大小相对较大，不支持Alpha透明，网络中使用相对较少。</p>
<h2 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h2><p>图形交换格式，为CompuServe公司在87年开发的图像文件格式。是一种基于LZW算法的连续色调的无损压缩格式。压缩率一般在50%左右，它不属于任何应用程序。LZW算法基本原理：提取原始文本文件数据中的不同字符，基于此创建编译表，然后使用编译表对应的索引来替换相对应对字符从而减少图片数据存储大小。</p>
<p>其主要为无损压缩，并且支持透明度以及动画等优点。不过只支持8bit的索引色，就只支持256个色值。不过其相对解码较快，大致流程为：以隔行存储的方式分成四遍扫描。第一遍扫描显示图像的八分之一，第二遍的扫描后显示1&#x2F;4，基本显示出大致轮廓。为隔行存放的优点，但是GIF不支持Alpha透明通道。</p>
<h2 id="JPEG格式"><a href="#JPEG格式" class="headerlink" title="JPEG格式"></a>JPEG格式</h2><p>JPEG也是最常用的图像文件格式之一，其压缩算法将图像中重复或不重要信息舍弃，为有损压缩。不过压缩技术十分先进，去除冗余的图像数据，在获得极高的压缩率的同时能展现十分丰富生动的图像，换句话说，就是可以用最少的磁盘空间得到较好的图像品质。其后缀名为 jpeg 或者 jpg。</p>
<h3 id="渐进式jpeg"><a href="#渐进式jpeg" class="headerlink" title="渐进式jpeg"></a>渐进式jpeg</h3><p>标准模式的jpeg，图片数据从上到下逐行显示。而渐进式jpeg则优化了显示模式，打开文件过程中会从整体模糊轮廓开始到具体呈现细节。具体可见 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e1b9d9aa9fc0">渐进式jpeg（Progressive JPEGs )解析</a>。</p>
<h2 id="SVG格式"><a href="#SVG格式" class="headerlink" title="SVG格式"></a>SVG格式</h2><p>可缩放矢量图形（Scalable Vector Graphics）。它是基于XML（标准通用标记语言的子集），由万维网联盟进行开发的，当下极为火爆的图片格式。一种开放标准的矢量图形语言，可任意放大图形显示，边缘异常清晰，文字在SVG图像中保留可编辑和可搜寻的状态，没有字体的限制，生成的文件很小，下载很快，十分适合用于设计高分辨率的Web图形页面。其优点在于：</p>
<ul>
<li>可被各类的工具读取和修改</li>
<li>相对 jpeg、png来说尺寸更小，可压缩性更强。</li>
<li>是可伸缩的、任何尺寸下都能高质量呈现</li>
<li>图像中的文本是可选的、可搜索的</li>
<li>可与 JS 一起运行</li>
<li>是开放的标准、文件是纯粹的 XML</li>
</ul>
<h2 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h2><p>便携式网络图形（外语简称PNG、外语全称：Portable Network Graphics），为较新的无损压缩图像文件格式。能够提供比GIF更小的无损压缩图像。提供 24位和48位真彩色图像。由于PNG相对较新，所以存在小部分兼容支持问题。支持 alpha 通道透明度但是不支持动画。</p>
<p>优点在于：更优化的网络传输、支持透明效果、并且无锯齿问题、渐进的显示与流式的读写等。</p>
<h2 id="APNG格式"><a href="#APNG格式" class="headerlink" title="APNG格式"></a>APNG格式</h2><p>APNG 是一个基于 PNG 格式的位图动画格式图片，因为对于一直以来的特点就是以动态显示为主的 GIF，为了更好地在网络上传播，它需要牺牲质量来降低体积，图像信息比较多的情况下，颗粒感很明显。APNG 是普通png的升级版，它的后缀依然是.png，包含动态的情况下体积会比普通静态 png 打出数倍，可以做到无损的情况展示动态。其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。</p>
<p>具体可参见 <a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/11/07/apng/index.html">APNG 那些事</a></p>
<h2 id="ICO格式"><a href="#ICO格式" class="headerlink" title="ICO格式"></a>ICO格式</h2><p>图标文件格式。它是Windows的图标文件格式的一种，可以存储单个图案、多尺寸、多色板的图标文件。图标是具有明确指代含义的计算机图形。其中桌面图标是软件标识，界面中的图标是功能标识。</p>
<h2 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h2><h3 id="Lottie动画"><a href="#Lottie动画" class="headerlink" title="Lottie动画"></a>Lottie动画</h3><p>一套跨平台的动画解决方案，将设计好的动画导出为JSON格式，支持在iOS、Android、Web等统一使用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b62e2bae51d4534c34a65e3">Lottie - 轻松实现复杂的动画效果</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/55315505">如何看待 Airbnb 新发布的 Lottie？</a></li>
</ul>
<h3 id="压缩工具"><a href="#压缩工具" class="headerlink" title="压缩工具"></a>压缩工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://tinypng.com/">熊猫TinyPNG</a></li>
<li><a target="_blank" rel="noopener" href="http://zhitu.isux.us/">PNG&#x2F;JPEG 转 wepb</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%AF%94%E8%BE%83">图形文件格式比较 - 维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F">图片格式_百度百科</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/04/26/justice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/26/justice/" class="post-title-link" itemprop="url">《公正，该如何做是好》- 我们如何公正的看这个世界</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-27T00:00:00+08:00">2019-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://image.freefe.cc/blur-close-up-court-531970.jpg" alt="image"></p>
<blockquote>
<p>公正指对于同一事件对于所有的人平等对待。公正包括程序公正和社会公正。</p>
<p>程序公正追求规则对于所有人和机构的平等，追求起点的平等。社会公正追求结果的平等，不问人们的起点、运气和努力。 现代社会以程序公正为基础，也兼顾社会的公正。</p>
<p>因为社会公正关系人们的利他主义的良心。但如果社会过分追求社会的公正，会动摇程序公正，也会影响自由，还会削弱社会的竞争，也由于社会完全承担对于弱者的救助减弱个人对于弱者的关注。 - 维基百科</p>
</blockquote>
<h2 id="什么是公正？"><a href="#什么是公正？" class="headerlink" title="什么是公正？"></a>什么是公正？</h2><p><img src="http://image.freefe.cc/boat-clouds-cloudy-skies-753619.jpg" alt="image"></p>
<blockquote>
<p>2004年，飓风『查理』横扫佛罗里达，造成严重的灾难。以及引发了一场关于价格欺诈的争论。现实就是灾后物价的飞涨，2美元的冰袋涨到10美元，250美元的发电机涨到2000美元…，这些天灾背后的物价引发了灾区民众的极度愤怒，认为这是一场市场的『价格欺诈』，你觉得你又如何看待？</p>
</blockquote>
<p><strong>我们自认为什么是公正？</strong></p>
<p>公正即正义，即法律得以正确执行，即有罪与无罪的合理审判。站在法律的角度，似乎确实这是一个违背法律，违背道德的状态，即不公正的，它给灾区受害者照成来很大的幸福感损失。但是拥护自由市场的经济学家索维尔认为，所谓的『价格欺诈』正是会让灾民受惠的，正是因为高价格才能刺激吸引周边资源丰富的区域以最快的速度向灾区就行资源调配，如果限价，那灾区的物质缺乏状态将得不到第一时间的缓解，就只能指望着政府的救援。</p>
<p>故而书中提出来一个疑问句：<strong>一个公正的社会是否应当努力推进其公民的德性？或者说法律是否应当在各种德性观念中保持中立，以使公民自由的为自己选择最佳的生活方式么？</strong></p>
<p>哲学角度上来说，对此问题的回答，传统意义上就代表了古代与现代的两种政治思考。</p>
<p>亚里士多德教导我们：<strong>公正意味着给予人所应得的，如果不首先反思哪种人们最想要的生活方式，就不能弄明白什么是公正的宪法，法律不可能中立与良善生活的各种问题。</strong></p>
<p>而现代哲学家们，康德、罗尔斯认为：<strong>那界定我们各种权利的公正原则应当不依赖与任何特殊的德性观念或者最佳生活方式，相反一个公正的社会应当尊重每个人选择他自己关于良善生活观念的自由。</strong></p>
<h2 id="功利主义-最大幸福原则"><a href="#功利主义-最大幸福原则" class="headerlink" title="功利主义 - 最大幸福原则"></a>功利主义 - 最大幸福原则</h2><blockquote>
<p>四名遭遇海难的船员，被困大西洋上，在食物消耗殆净后，杀死了其中最弱小的船员，在20多天后，三名船员得以获救。对此又该如何评判公正？</p>
</blockquote>
<p>杰里米.边沁在功利主义上的立场就非常明确：<strong>道德的最高原则就是使幸福最大化，使快乐总体上超过痛苦。</strong>那于此来看，是否上面的事件又感觉合乎常理呢，但以目前社会公正的角度看这肯定存在一定问题。</p>
<p>引发来对于公正的两种思考角度：</p>
<ul>
<li>1、一种行为之道德与否仅仅取决于它所带来的后果；正当的行为就是人们经过考虑后所做出的任何能够使事情达到最佳状态的行为。</li>
<li>2、在道德方面，结果并不是我们应当关注的全部。某些义务和权利应当受到我们的尊重，而这样做的原因并不依赖于社会性的后果。</li>
</ul>
<p>对边沁的反驳也很多，最主要立场在于：</p>
<ul>
<li>1、未尊重个体权利 </li>
<li>2、将幸福与痛苦作为社会通用的价值货币</li>
</ul>
<h2 id="市场与道德-雇佣帮助"><a href="#市场与道德-雇佣帮助" class="headerlink" title="市场与道德 - 雇佣帮助"></a>市场与道德 - 雇佣帮助</h2><blockquote>
<p>美国的征兵制，是强制性征兵还是允许出价雇佣士兵？你觉得哪一种最为正当呢？</p>
</blockquote>
<ul>
<li>1、征兵制</li>
<li>2、允许有偿的征兵制</li>
<li>3、市场体制的志愿兵模式</li>
</ul>
<p>很明显，就自由主义者而言，征兵制是具有强迫性，是一种奴役的表现，甚至暗示了政府拥有公民以及可以随意对待公民的权利，意味着是自由的枷锁。当然他也限制了我们的选择，减少了总体的幸福感。这样看来确实征兵制有较大的不合理性。</p>
<p>那么为何我们不能简单的通过市场来进行招募呢？设定工资和报酬来吸引士兵以及其质量与数量。</p>
<p>作者认为，将公民的义务转变成一种可在市场上出售的商品，也并没有增加自由，而是暗中破坏了自由。当我们将征兵这类义务作为商品贩卖的时候，穷人与富人的处境就变得完全不一样，所谓的志愿兵中并没有想象中的那么公平。富人、有特权的人，完全可以避免被征兵的情况，而战场上的大多都是受其他条件逼迫而战斗的士兵。那么控制着政府上层的特权人士对于战争的态度，也有可能存在弱化的思想，反正与其无关，至少是家庭成员上。</p>
<p>若是仅仅是更具功利来评定所有事务，就贬低了那些适合更高的规范的事务与行为：比如孩子、怀孕，对子女的养育等。</p>
<p>那么对于更高规范的判定，我们始于这种观念：正当的评价事物和社会行为的方式取决于这些行为所满足的目的。犹如亚里士多德的公正理论：我们视图抓住这些行为的本质性目的或意图，以此来鉴别出那些适合于这些社会行为的各种规范。</p>
<h2 id="伊曼纽尔-康德-重要的是动机"><a href="#伊曼纽尔-康德-重要的是动机" class="headerlink" title="伊曼纽尔.康德 - 重要的是动机"></a>伊曼纽尔.康德 - 重要的是动机</h2><p>如果权利不依赖与功利来进行公正的判断，那又是什么来衡量它们的道德基础呢？</p>
<p>自由主义者提出来一种可能的答案：<strong>人民不应当被仅仅当做促进他人福利的手段而加以利用，这样侵犯了根本性的自我所有权，它不应当可以被社会随意处置。</strong></p>
<p>康德在道德形而上学基础中，也对功利主义发出了强烈的批判：<strong>道德跟使幸福最大化以及任何其他目的无关，而在于人作为目的加以尊重。</strong></p>
<p>对于自由主义，我们日常的所认为的市场自由或者消费自由也并非真正的自由，它仅仅满足了我们事先并没有选择的各种欲望罢了。</p>
<blockquote>
<p>康德认为什么才是自由：当我们像动物一样最求快乐或者避免痛苦时，我们不是真正自由的行动，而是作为欲望和渴求的奴隶而行动。</p>
<p>自由的行动就是自律的行动，自律的行动就是根据我给自己所立的法则而行动，而不是听从本性或者社会传统的指令。</p>
</blockquote>
<h2 id="约翰-罗尔斯-平等的理由"><a href="#约翰-罗尔斯-平等的理由" class="headerlink" title="约翰.罗尔斯 - 平等的理由"></a>约翰.罗尔斯 - 平等的理由</h2><p>罗尔斯提醒我们：</p>
<ul>
<li>1、首先公正通常具有表示敬意的一面</li>
<li>2、只有当社会确立了自己的使命时，优点才会产出。而对于复杂情形下又具有较大局限性。</li>
</ul>
<p>将公正的论点关于荣誉、德性以及善的意义联系在一起时，就能去解决复杂情形遇到的一些悖论问题。</p>
<h2 id="亚里士多德-谁应得什么？"><a href="#亚里士多德-谁应得什么？" class="headerlink" title="亚里士多德 - 谁应得什么？"></a>亚里士多德 - 谁应得什么？</h2><p>亚里士多德的政治哲学有两个主要观点：</p>
<ul>
<li>1、公正是目的论的，对于权利的界定要求我们弄明白所讨论的社会行为的目的。</li>
<li>2、公正是荣誉性的，为了推理行为的目的，我们至少要确认它应当尊敬或者奖励什么样的德性。</li>
</ul>
<p>公正意味着给予人们所应得的东西，将世界上最好的长笛给予最佳的长笛演奏者不仅仅是能带来最好的音乐有利于大众。亚里士多德认为，这才是这个最好的长笛存在的意义 - 被更好的吹奏。</p>
<p>关于公正和权利的争论，常常无法避免和社会制度的目的，社会资源的分配以及尊敬与奖励的德性的争论，很多时候我们的法律也尽可能的保持中立，但是如果我们对其的讨论不涉及良善生活的本质，就好依旧很难阐述清楚何为公正！</p>
<h2 id="公正与共同善"><a href="#公正与共同善" class="headerlink" title="公正与共同善"></a>公正与共同善</h2><p>康德认为我们应当超脱自生的欲望，主宰自己的意识。对于他与罗尔斯而言，权利优先于善，那些界定我们各种义务与权利的公正应该中立于各种良善生活的观念。</p>
<p>亚里士多德则表示，我们应当将良善生活融入到公正的评判中去，才能解决很多复杂情况的问题，产生公正。</p>
<p>康德认为，亚里士多德的角度，忽略了自由。一种试图培养好的良善生活的思想有可能将其价值观强加于其他人。没有将人作为独立自主的自我，能自主的选择自己的目的而加以尊重。</p>
<p>作者本书内讨论的三种关于公正的法则</p>
<p><strong>公正意味着使功利与幸福最大化，为了大多数人的幸福</strong></p>
<p>缺陷：使得公正和权利变为一种算计而非原则的东西。单一的，整齐的衡量标准难以适用，具有很大矛盾冲突。</p>
<p><strong>公正意味着尊重人们选着自由，或者自由市场，或者是无知之幕下的选择</strong></p>
<p>缺陷：我们不可能仅仅通过使得功利最大化，或者保障自由来实现一个真正的公正的社会，必须要推理共同的良善生活的意义来兼容各种文化以及分歧。</p>
<p><strong>公正涉及培养德性和推理共同善</strong></p>
<p>肯尼迪说：即使我们努力消除无知匮乏，我们也还面临另一个更加艰巨的任务，那就是对于满意度的匮乏，让我们所有人都异常苦恼。</p>
<p><img src="http://image.freefe.cc/adult-balloon-beautiful-1236678.jpg" alt="image"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/03/15/how-to-read/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/15/how-to-read/" class="post-title-link" itemprop="url">《如何阅读一本书》- 不再泛泛而读，以正确的姿态读书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-16T00:00:00+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="我们如何阅读"><a href="#我们如何阅读" class="headerlink" title="我们如何阅读"></a>我们如何阅读</h2><p>近两年，自己开始习惯的去阅读任何自己感兴趣的书籍。原本一直以为读书么，就是不断的去看去了解，终有一天会由量变转为质变，也终有一天我们能很好的得到我们所谓的睿智。</p>
<p><img src="http://image.freefe.cc/bookcase-books-bookshop-220326.jpg" alt="image"></p>
<p>《如何阅读一本书》让我发现这可能是存在问题的。问题不在于我们盲目的去读很多很多的书，而在于我们在读任何一本书的过程中到底改变了自己什么。盲目在于我们所谓的读书仅仅是那匆匆一撇，放下书后却依旧过着原有的生活。</p>
<p>将读书的习惯分层次，分方式，或许我们会花费比匆匆阅读更多一点的时间，去了解书的整体架构，中心思想（有点像回到了语文课堂的感觉），去了解作者想要告诉我们的故事与情感等。但这不正是我们读书最最原始的初衷么。很多时候我们可能是不是已经舍本求末了，比如读书。</p>
<p><img src="http://image.freefe.cc/blur-book-close-up-1485114.jpg" alt="image"></p>
<h2 id="阅读的层次"><a href="#阅读的层次" class="headerlink" title="阅读的层次"></a>阅读的层次</h2><p>作者在本书中阐述了阅读对于人类社会的重要性，基本是涉及我们所处的所有的领域。也正是由于人类基于阅读才得以传承的历史信息引发了人类社会的如此繁荣。</p>
<p>本书中作者将阅读分成来四个主要的层次，基础阅读、检视阅读、分析阅读以及主题阅读。每一层次的阅读都是上一层次的升华与质变。使我们能很好的深入的去了解一本书其存在的真正意义，作者将其发版的内心考量。</p>
<h3 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h3><p>回归内容，简单的说基础阅读就是我们阅读的基础能力，包括识字解意。即时是基础，我们也需要不断提升我们对于内容的理解力，单词，单句等所表达以及蕴含的意义。设计词汇量、词义的了解量等。</p>
<p>与此相对的我们小学，初中那么多年，便是在此阶段上的学习提升。不过很可惜的是，作者认为我们绝大多数人的阅读能力也就仅限于次，不再往上提升了。</p>
<p><img src="http://image.freefe.cc/abc-alphabet-blackboard-265076.jpg" alt="image"></p>
<h3 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h3><p>检视阅读则为在具有基础阅读能力上，去了解一本书的初级阶段。包括系统性略读与粗浅的阅读两种方式。</p>
<p>从一本书现有的信息来描绘整个骨架，包括从封面、目录、前序后序和重要章节等。在对于一本书有了基本的了解后，我们便能很好的去判定我们是否有去读此书的必要。而粗浅的阅读主要针对于较难的一些理论性书籍，以最快的方式去尽可能熟悉，是对这一类难书最好的阅读办法。</p>
<p>这个步骤其实对于阅读前期是一个非常有意义的步骤。了解这边书到底想要表达什么思想，解决什么样的问题，我是不是有需要等等。能让我们在读书前期花很小的成本来对要读的书快速做出一个自我的判定。</p>
<p><img src="http://image.freefe.cc/fish-fish-bones-museum-9365.jpg" alt="image"></p>
<h3 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h3><p>在很好的基础阅读能力上，以及了解书的灵魂与骨骼后，分析阅读则为其描绘上血与肉。</p>
<p>在作者看来，我们又可以将分析阅读拆分为三层的渐进式过程。包括进一步梳理结构，诠释内容与做出评价。在原有的大致的骨骼上梳理除一块块肌肉集群，从而细化我们对于此书的结构化都理解。找出书中关键或者经典的语句与词汇，强化对于各个内容重点的深入了解。最后对于书内思想作为自己的感悟与评判。</p>
<p>分析阅读是从普通的阅读层次向高层次阅读进阶的一个过程。从理解学习到吸收与评价。从作为书的第三者到将书融入自己思想的一个阶段。</p>
<p>作者认为，读完一本书，我们最起码需要能回答以下四个问题：</p>
<ul>
<li>1、这本书主要的内容是什么？</li>
<li>2、作者的中心思想是什么？</li>
<li>3、你觉得这边的说的是否有道理？</li>
<li>4、这本书对于你的意义是什么？</li>
</ul>
<p>四个问题本身就是在基于基础阅读上的检视阅读与分析阅读的真正的目标。当你正在读一本书，或者读完一本书时，试着问一下自己以上的问题。所以，我们真的在较好的读书么？</p>
<p><img src="http://image.freefe.cc/ben-white-197680-unsplash.jpg" alt="image"></p>
<h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>如果说分析阅读是自身对于一本书内容的深入学习与自我升华，那么主题阅读则是对一种思想在大量书籍中的提取，学习以及演化为自己的一种思维模式。其难度可见一斑，很多学者终其一生也很难做好哪怕一次主题阅读吧。</p>
<p>此生如果特别喜爱某些思想或者文化，尽可能还是需要去努力的做一次真正的主题阅读把。</p>
<p><img src="http://image.freefe.cc/michal-parzuchowski-567121-unsplash.jpg" alt="image"></p>
<h2 id="我们又该如何阅读"><a href="#我们又该如何阅读" class="headerlink" title="我们又该如何阅读"></a>我们又该如何阅读</h2><p>那么了解了四个步骤之后，我们到底搞如何来阅读呢。</p>
<ul>
<li>1、不断扩展阅读的基础能力。（甚至互联网文化、古文基础等）</li>
<li>2、拿到书后，不应该急于去阅读，可以多了解选作者的信息，本书的背景等，包括前言、序、后言等。</li>
<li>3、根据目录信息来简单联想下整本书的内容，阅读一些自认为重要的或者感兴趣的章节来以点切入书籍去初步了解与学习。</li>
<li>4、在对于本书骨架有了明确的认识之后，做出判定，我们是否有必要在当下阅读它。</li>
<li>5、在明确开始阅读后，了解细化每章节的主旨与意义，划出重要段落、语句甚至词汇。</li>
<li>6、依据全书的骨架、血肉与各个思想点，整理与回答四个问题。</li>
</ul>
<p>最后，有一段话觉得不错：我们只有一生的时光，但通过阅读，我们的生命得到了最大程度的扩展，仿佛度过了无数个不同的人生。献给这世界坚持读书的生命。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2019/02/26/2018-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/26/2018-summary/" class="post-title-link" itemprop="url">2018延期的总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-27T00:00:00+08:00">2019-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>19年已开始近两月，才开始下定决心写个18年的回顾。也突然间发现自己已经散漫的连自己都害怕，对于19年的自己，希望能以<strong>自律</strong>为主题吧。</p>
<blockquote>
<p>当我们像动物一样追求快乐或避免痛苦时，我们并不是真正自由地行动，而是作为欲望和渴求的奴隶而行动。自由地行动就是自律地行动，自律地行动就是根据我给自己所立的法则而行动——而不是听从于本性或社会传统的指令。 - 康德</p>
</blockquote>
<p>那么关于总结，想到啥些啥把！权作为对于生命的一次回首把。</p>
<h2 id="2018年回顾"><a href="#2018年回顾" class="headerlink" title="2018年回顾"></a>2018年回顾</h2><p>18年，生活整体已开始趋向于没有太大变化了，对于家庭可能就此决定定居上海，关于最重要的买房事宜，反正没资格，慢慢来吧。在此也感谢媳妇的开明，哈哈！</p>
<p>18年对于自身最有意义的一件事是读书开始变成自己生命中不可或缺的一个习惯。心理学、经济学、传记、软素质等各类数据不断的阅读，不断的了解新的思想，是一件非常有意义的事情。好比我们在自己的生命中看尽无数书中的生命故事一般，欲罢不能。当然周末的懒散也是一直谴责自己的一个理由了。</p>
<p>今年年初的一本书《如何阅读一本书》对自己读书习惯影响非常大，一直想着只要自己不断的阅读不断的去扩展自己的思想就是非常有意义的，我只要多读就行。而在本书中才发现我们读书应该以正确的方式去吸收学习一些东西，提升我们的思想，使读书变得真正对于我们人生是有强意义的，而非泛泛而谈。读书是一种信仰，这是一个培训机构的广告词，我觉得非常好。</p>
<p>关于技术上的书18年还是读的比较少，有幸刷了一遍半的《代码大全》，在此非常强烈的推荐，如果对于编程没帮助，那估计是你不是学编程的！此书很早年果壳的Leader让我们人手一本，但是没好好的去阅读，但真不愧是计算机业内的经典之作，对于个人编程的习惯、思维上都有非常大的帮助，包括如何定义变量，编写函数与类，如何定义子程序等从根本层面来说明why，how与what。</p>
<p>深入的了解函数式编程也改变与优化了自身的编程思维，前端侧也非常推荐《Javascript函数式编程》，让你看到函数的纯粹性的强大，主要体现在函数式编程对于问题的分析与解决吧，以及对于后期项目多可维护性，可扩展性层面的帮助。</p>
<p>18年整体工作上算是比较顺利，除了部门的不断调整使得稳定性一度成为问题，不过早已习惯的我们也无所畏惧了。整体自身也开始从基础的业务开发转变为团队的技术管理层面，开始学习从团队以及更高的角度看待与分析问题，也算是18年自己为数不多的一个成长吧。</p>
<h2 id="2019年展望"><a href="#2019年展望" class="headerlink" title="2019年展望"></a>2019年展望</h2><p>简单的立一些flag吧！</p>
<ul>
<li>1、在每个工作日早晨读书的同时，每个周末起码阅读4小时，不断的高质量阅读。</li>
<li>2、坚持每周的3-4次KEEP锻炼，加强身体素质。减肥就不用了，自身太瘦。</li>
<li>3、提高工作质量，加强工作的注意力，加强技术层面的学习与思考。</li>
<li>4、带媳妇多去一些地方旅游。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2018/07/14/communicate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/14/communicate/" class="post-title-link" itemprop="url">《非暴力沟通》- 以同理心的姿态，和这个世界好好谈谈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-15T00:00:00+08:00">2018-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h2><p>读书会上初次接触《非暴力沟通》，本以为又是一部教人如何隐忍或者假装胸怀的书，谈谈所谓的心胸、同理心的名词罢了。</p>
<p>而意想不到的是，阅读过程中却感慨万千。本书表达了对于我们的任何开心、舒适、愤怒、沮丧等万千情感，都只是我们自身的需求对于社会的一种反应而已。不以物喜，不以己悲，或许就是这一类的境界。以平和的视角去看这个世界，这个世界就会变的平和。</p>
<h2 id="曾经的认知"><a href="#曾经的认知" class="headerlink" title="曾经的认知"></a>曾经的认知</h2><p>所有人这辈子都说听过很多道理，却依旧过不好这一生。同理心这个词，被作为当今社会沟通的完美解决方案，却鲜有人真的深入的了解。生活中却依旧按照旧方式去表达着对这个世界的的不满、气愤、悲允。其实，最根本的原因是由于我们基本还没有明白自己，没有明白什么样的生活，才是我们最想要的。</p>
<p>简单的说，对于情绪的直接性的表达，从生理层面讲是大脑的杏仁体分泌的情绪化合物质控制了我们的理性，导致对于外界刺激我们展现出原始人类的那种情绪表达。去直接展现愤怒，悲伤等。当然不能说这类形式不好，生物演化过程中，这是一种类似于自我保护的条件反射。在此推荐一下戈尔曼教授的《情商》，堪称情绪分析的经典。</p>
<p>而很多情况，我们却对此需要加以控制，在人与人吵架过程中，可能最初我们还有意识的理性分析，不过当另一方一直大吼大叫的情况下，我们也就可能想，凭啥他能对我大吼大叫，凭啥我要委曲求全，然后一场全面的战争就爆发。 </p>
<h2 id="非暴力沟通的认知角度"><a href="#非暴力沟通的认知角度" class="headerlink" title="非暴力沟通的认知角度"></a>非暴力沟通的认知角度</h2><p>非暴力沟通提出了4个基本要素。首先留意发生的事情，清晰的表达观察结果而不带任何的判断或者评估。然后表达感受，感到受伤、害怕、或者气愤等。然后说出什么样的需求导致的这些感受。真诚的表达自己。最后提出你的具体请求。</p>
<p>比如一位母亲对于处于青春期的儿子如下说：『你的袜子又是导出乱扔，每次都需要到处给你收拾，你想累死我啊，真的被你气死了。赶紧收拾一下，不然我就收拾你』。</p>
<p>又或者：『看到你没有收拾好袜子，到处乱扔，我不太开心，因为我注重家庭的整洁，现在你是否愿意把你的袜子都放到洗衣机里』。</p>
<p>以上两种说话方式，或者说沟通方式，你觉得如何。当然目前你可能只是觉得第二种稍好一点罢了，但是略显啰嗦，不干脆。甚至可能觉得，第二种方式会凸现不出你的家庭身份，你的威严。那家庭中我们是更在乎和谐还是更在乎具体某人的家庭地位呢？</p>
<p>本书中含有大量内容丰富的真实示例，来表达如何通过沟通去化解悲伤，敌对，惶恐等情绪。你在读完每一个实例后，你可能会说：『哇塞，沟通原来可以这样，真实与直接』。</p>
<h3 id="什么蒙蔽了爱"><a href="#什么蒙蔽了爱" class="headerlink" title="什么蒙蔽了爱"></a>什么蒙蔽了爱</h3><p>现代人习惯了带有道德评判，比较，回避责任，强人所难的方式去说话。『这人真是自私』，『他对别人有成见』，『自己真是不如别人』，『我不得不这么做』，『你今天必须要处理好』。</p>
<p>人性本善，乐于互助。而上述异化的沟通方式使得我们难以体会心中的爱与善。道德评判将不符合我们价值观的人看做不道德或者是邪恶的，进行比较也是一种评判，蒙蔽对人对己的善。这样的沟通淡化了我们自己的思想、情感和行为责任意识。强人所难照成了心灵的隔阂。</p>
<h3 id="如何用心的去观察"><a href="#如何用心的去观察" class="headerlink" title="如何用心的去观察"></a>如何用心的去观察</h3><p>仔细观察正在发生的事情，并且清楚的阐述观察结果，虽然并不要求我们保持完全客观的不做任何评价，但是强调区分观察与评论的重要性。不能将观察与评论混为一谈，因为人会倾向于听到批评而产生逆反心理。</p>
<p>文中有一首小诗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">我从未见过懒惰的人；</span><br><span class="line">我见过</span><br><span class="line">有个人有时在下午睡觉，</span><br><span class="line">在雨天不出门，</span><br><span class="line">但他不是个懒惰的人。</span><br><span class="line">请在说我胡言乱语之前，</span><br><span class="line">想一想，他是个懒惰的人，还是</span><br><span class="line">他的行为被我们称为『懒惰』？</span><br><span class="line"></span><br><span class="line">我从未见过愚蠢的孩子，</span><br><span class="line">我见过有个孩子有时候做的事</span><br><span class="line">我不理解</span><br><span class="line">或不按我的吩咐做事情；</span><br><span class="line">但他不是愚蠢的孩子。</span><br><span class="line">请你在说他愚蠢之前，</span><br><span class="line">想一想，他是个愚蠢的还在，还是</span><br><span class="line">他懂的事情与你不一样？</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不带评论的观察是人类智力的最高形式  - 克里希那穆提</p>
</blockquote>
<p>非暴力沟通的第一个要素：观察，将观察和评论混为一谈别人就会倾向于听到批评，而原始的心理让其进入自我保护的反驳状态。主张沟通是动态的语言，而非绝对化的结论。</p>
<h3 id="如何真实的去感受"><a href="#如何真实的去感受" class="headerlink" title="如何真实的去感受"></a>如何真实的去感受</h3><p>常常，我把并不是在表达我们的感受，而是表达想法。</p>
<p>我觉得这个项目有问题、我觉得这样的形式不公平、我觉得你应该懂得更多。</p>
<p>亦或是：</p>
<p>因为这个项目存在一些隐性的问题还没有解决好，我有点担心公司的利益会收到影响。<br>我感到有点不开心，因为我觉得这样形式的配置对于我来说有点不公平。<br>对于你现阶段展现出来的能力范围，我有点失落，我觉得你可以学习更多，展现的更强。</p>
<p>非暴力沟通的第二个要素：感受。通过建立表达感受的词汇表，更清楚的表达感受，并且示弱有助于解决冲突。</p>
<h3 id="感受中的真实需求"><a href="#感受中的真实需求" class="headerlink" title="感受中的真实需求"></a>感受中的真实需求</h3><p>感受的根源，在于我们自身。我们的需要与期待，以及他人的言行与看法导致了我们的感受。</p>
<p>当遇到不中听的话，我们会有以下的选择：</p>
<ol>
<li>认为自己犯了错</li>
<li>指责对方</li>
<li>了解我们的感受和需要</li>
<li>用心体会他人的感受与需要</li>
</ol>
<p>对他人的指责，批评、评论以及分析反应来我们自生的需求与价值观。如果我们通过批评来提出主张，那么极容易遭到申辩或者反驳。反之，如果我们直接的说出我们的需求，那么他人就可能做出积极的反应。</p>
<p>非暴力沟通的第三个要素：感受源于我们自身的需求。</p>
<h3 id="关于自身的需求"><a href="#关于自身的需求" class="headerlink" title="关于自身的需求"></a>关于自身的需求</h3><p>许多人感到沮丧或者灰心，很大程度是由于自己都不清楚对他人究竟是什么样的期待。</p>
<p>非暴力沟通的第四个要素：请求。</p>
<p>我们告诉别人，为了改善生活，我们希望他们做什么，不抽象的具体描述。我们将自己的需求讲的越清楚，就越有可能得到想要的回应，集中发言中，更需要清楚清楚的表明自己的期待。</p>
<h2 id="如何去倾听"><a href="#如何去倾听" class="headerlink" title="如何去倾听"></a>如何去倾听</h2><p>当他人遭遇不幸时，我们常常急于给出建议与安慰，或者表达我们的态度与感受。为了倾听，我们首先要放下已有的想法与判断，全身心的去体会对方。并且不管别人如何的描述我们，我们也可以用心体会他的的观察、感受、需求与请求。</p>
<p>方式：</p>
<ol>
<li>体会他人的感受和需求</li>
<li>给他人反馈</li>
<li>保持关注</li>
</ol>
<p>倾听使我们敢于面对自己的弱点，帮助我们预防潜在的暴力，使谈话生动有趣。深入了解真正内心的需求与感受。</p>
<h2 id="如何表达愤怒"><a href="#如何表达愤怒" class="headerlink" title="如何表达愤怒"></a>如何表达愤怒</h2><p>生气时，批评和指责他人都无法真正传达我们的心声。如果想表达愤怒，我们就不能归咎他人，而是把注意力放在自己的感受和需求上。</p>
<p>表达愤怒的步骤：</p>
<ol>
<li>停下来深呼吸</li>
<li>留意我们的指责</li>
<li>体会我们的需要 </li>
<li>表达感受和尚未满足的需要</li>
</ol>
<h2 id="如何表达感谢"><a href="#如何表达感谢" class="headerlink" title="如何表达感谢"></a>如何表达感谢</h2><p>不自大，不虚假，谦虚真实。</p>
<p>表达感激：</p>
<ol>
<li>对方做了什么事情使我们的生活得到了改善</li>
<li>我们的哪些需要得到了满足</li>
<li>我们的心情怎么样</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2018/05/22/code-style/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/22/code-style/" class="post-title-link" itemprop="url">编写可维护性的前端代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-23T00:00:00+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编写可维护的-JavaScript-读书笔记"><a href="#编写可维护的-JavaScript-读书笔记" class="headerlink" title="编写可维护的 JavaScript 读书笔记"></a>编写可维护的 JavaScript 读书笔记</h1><p><strong>尼古拉斯（作者）</strong>： 前端大牛工程师，目前在 Box 公司任职，之前是在雅虎将近工作 5 年。在雅虎期间，他是雅虎首页的前端技术主管，并且是 YUI 库的贡献者。 Nicholas 编写的技术书有：《Maintainable JavaScript | 编写可维护的 JavaScript》、《Professional JavaScript for Web Developers | JavaScript高级程序设计》、《High Performance JavaScript | 高性能JavaScript》、《Professional Ajax》。</p>
<p><strong>任何开发者都不在乎某个文件的作者是谁，也没有必要花费额外的精力去理解代码的逻辑并且重新排版，因为所有代码的排版风格都是非常一致的，因为风格不一致会导致我们打开代码文件的第一件事情不是立即工作，而是进行缩进的排版整理。</strong></p>
<p><strong>能很容易的辨别出有问题的代码并且发现错误，如果所有的代码风格很像，当看到一段与众不同的代码时，很肯能问题就出在这里。</strong></p>
<blockquote>
<p>  “程序是写给人读的，只是偶尔让计算机执行一下” - Donald Knuth</p>
</blockquote>
<h2 id="基本的格式化"><a href="#基本的格式化" class="headerlink" title="基本的格式化"></a>基本的格式化</h2><p><strong>1.1 缩进层级</strong><br>建议4个空格，或在编辑器中设置一个 制表符 替换为 4个空格。</p>
<p><strong>1.2 语句结尾</strong><br>强制规定，语句结束插入分号。</p>
<p><strong>1.3 行的长度</strong><br>很多语言都建议行的字数不超过 80 字</p>
<p><strong>1.4 换行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 百度代码规范</span><br><span class="line">// good</span><br><span class="line">if (user.isAuthenticated()</span><br><span class="line">    &amp;&amp; user.isInRole(&#x27;admin&#x27;)</span><br><span class="line">    &amp;&amp; user.hasAuthority(&#x27;add-admin&#x27;)</span><br><span class="line">    || user.hasAuthority(&#x27;delete-admin&#x27;)</span><br><span class="line">) &#123;</span><br><span class="line">    // Code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = number1 + number2 + number3</span><br><span class="line">    + number4 + number5;</span><br></pre></td></tr></table></figure>

<p><strong>1.5 空行</strong>  </p>
<p>如何通过空行让代码感觉更透气</p>
<pre><code>1. 方法之间  
2. 方法中局部变量和第一条语句之间。  
3. 多行或者单行注释之前。  
4. 在方法内的逻辑片段之前。
</code></pre>
<p><strong>空行常常被忽略，但是空行也是提高代码可读性的强大武器。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line">    for(var i=0; i&lt;wl.length; i++)&#123;</span><br><span class="line">        p = wl[i];</span><br><span class="line">        type=Y.Lang.type(wl[i]);</span><br><span class="line">        if(a)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line"></span><br><span class="line">    // 循环的业务逻辑注释</span><br><span class="line">    for(var i=0; i&lt;wl.length; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        // 赋值逻辑注释</span><br><span class="line">        p = wl[i];</span><br><span class="line">        type=Y.Lang.type(wl[i]);</span><br><span class="line">        </span><br><span class="line">        // 条件判定逻辑注释</span><br><span class="line">        if(a)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.6 命名</strong></p>
<p>1 变量和函数<br>变量名总是应该遵循驼峰大小写命名法，并且命名的前缀应当是名词，使得可以将变量和函数区分开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 以下OK</span><br><span class="line">var count = 10;</span><br><span class="line">var myName = &quot;Ni&quot;;</span><br><span class="line">var found = true;</span><br><span class="line"></span><br><span class="line">// 以下就需要重新命名</span><br><span class="line">var getCount = 10;</span><br><span class="line">var isFound = true;</span><br><span class="line"></span><br><span class="line">//函数应当以动词开头</span><br><span class="line">var getName  = function()&#123;</span><br><span class="line">    return myName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一点示范  </p>
<pre><code>can        函数返回布尔值
has        函数返回布尔值
is         函数返回布尔值
get        函数返回非布尔值
set        函数用来保存值
</code></pre>
<p>2 常量<br>使用大写字母并且使用下划线命名</p>
<p>3 构造函数<br>大驼峰命名法</p>
<p>1.7 直接量</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>2.1 单行注释</strong>  </p>
<pre><code>1. 独占一行，用来解释下一行，并且这行注释之前总有一行空行，缩进的层级与下一行代码保持一致。  
2. 在代码行的尾部注释。代码与注释之间至少有一个缩进。注释包括之前本行的代码不应该超过最大字符数限制。  
3. 注释掉大块代码。  
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 好的注释方法</span><br><span class="line">if ( condition ) &#123;</span><br><span class="line">    </span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( condition ) &#123;</span><br><span class="line">    func(); // 解释该代码功能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( condition ) &#123;</span><br><span class="line"></span><br><span class="line">    // 多行解释代码</span><br><span class="line">    // 多行解释代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2 多行注释</strong></p>
<p><strong>2.3 使用注释</strong>   </p>
<pre><code>1. 当代码不够清晰的时候使用注释，当代码很明了的时候不应当添加注释。  
2. 注释不应该只是解释变量名称或者函数名称式的那种废话。  
3. 当代码很难理解或者代码可能被误认为错误的代码的时候，需要添加注释。  
</code></pre>
<p><strong>2.4 文档注释</strong>   </p>
<p>技术角度来说，文档注释并不是JS的组成部分，但是是一种普遍的实践。  </p>
<pre><code>1. 应当对所有的方法和可能的返回值添加描述。  
2. 对自定义的构造函数类型和期望的参数添加描述。  
3. 对于包含对象或者方法的对象进行描述。
</code></pre>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p><strong>3.1 花括号对齐方式</strong></p>
<p><strong>3.2 块语句间隔</strong>  </p>
<p>语句块间隔有3中形式：  </p>
<pre><code>1. 语句名 圆括号 左花括号间没有空格间隔。  
2. 左圆括号之前 右圆括号之后添加一个空格。  
3. 左圆括号 右圆括号前后都添加一个空格。 
</code></pre>
<p><strong>3.3 switch 语句 缩进&amp;case语句的连续执行（贯穿）</strong><br>JS的switch缩进一致是有争议的话题。</p>
<pre><code>1. 每个case相对于switch都有一个缩进层。  
2. 第二个case开始之前都有一个空行。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">    case &quot;a&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break；</span><br><span class="line"></span><br><span class="line">    case &quot;b&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default :</span><br><span class="line">        // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种 Crockford 和Dojo编程风格为  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">    //代码</span><br><span class="line">    break；</span><br><span class="line">case &quot;b&quot;:</span><br><span class="line">    //代码</span><br><span class="line">    break;</span><br><span class="line">default :</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">    case &quot;a&quot;:</span><br><span class="line">    case &quot;b&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default :</span><br><span class="line">        // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Douglas 在 Crockford中禁止出现贯穿现象，但是Nichlas认为只要程序逻辑很清楚，贯穿完全是一个可以接受的编程方式。Jquery 编程风格中也是允许的。</p>
<p><strong>3.4 with</strong></p>
<p><strong>3.5 for 循环</strong>  </p>
<p>对于for循环中的break和return会改变循环的方向，尽量避免使用，但是不禁止。</p>
<p><strong>3.6 for-in 循环</strong>  </p>
<p>for-in循环建议与 hasOwnProperty 一起检测属性，除非你需要检查原型。</p>
<h2 id="变量，函数和运算符"><a href="#变量，函数和运算符" class="headerlink" title="变量，函数和运算符"></a>变量，函数和运算符</h2><p><strong>4.1 变量声明</strong>  </p>
<p>变量声明是通过 var 语句来完成的。变量声明不管是在何处声明，所有的 var 语句都会提前到代码顶部执行。</p>
<p>由而产生了一种单一的 var 风格声明。<br>尼古拉斯推荐 合并var声明，可以清晰看到所有变量名 以及缩小代码量。并且建议每个变量都独占一行，统一缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing (item)&#123;</span><br><span class="line">    var i,</span><br><span class="line">    len,</span><br><span class="line">    value = 10,</span><br><span class="line">    result = value+10;</span><br><span class="line">    </span><br><span class="line">    for(i=10, len=item.length; i&lt;len; i++)&#123;</span><br><span class="line">        do(item[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>百度JS规范</p>
<pre><code>[强制] [RULE071] 每个 var 只能声明一个变量。  
[强制] [RULE072] 变量必须即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// good</span><br><span class="line">function kv2List(source) &#123;</span><br><span class="line">    var list = [];</span><br><span class="line"></span><br><span class="line">    for (var key in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(key)) &#123;</span><br><span class="line">            var item = &#123;</span><br><span class="line">                k: key,</span><br><span class="line">                v: source[key]</span><br><span class="line">            &#125;;</span><br><span class="line">            list.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">function kv2List(source) &#123;</span><br><span class="line">    var list = [];</span><br><span class="line">    var key;</span><br><span class="line">    var item;</span><br><span class="line"></span><br><span class="line">    for (key in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(key)) &#123;</span><br><span class="line">            item = &#123;</span><br><span class="line">                k: key,</span><br><span class="line">                v: source[key]</span><br><span class="line">            &#125;;</span><br><span class="line">            list.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 函数声明</strong></p>
<p>推荐总是先声明函数，再使用函数。Crockford规范还推荐在函数内部的函数应当紧跟着变量声明之后声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing (item)&#123;</span><br><span class="line">    var i,</span><br><span class="line">        len,</span><br><span class="line">        value = 10,</span><br><span class="line">        result = value+10;</span><br><span class="line">    </span><br><span class="line">    function do(item)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(i=10, len=item.length; i&lt;len; i++)&#123;</span><br><span class="line">        do(item[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明不应当出现在语句块之内，会有兼容方面的问题导致各个浏览器解析不一致。也是google规范中禁止的。</p>
<p><strong>4.3 函数调用隔离</strong></p>
<p>代码比较透气，增强可读性和读代码的舒适度</p>
<p>百度代码规范 <a target="_blank" rel="noopener" href="http://styleguide.baidu.com/style/js/index.html#id6">空格</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = !arr.length;</span><br><span class="line"></span><br><span class="line">if (condition) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function funcName() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var funcName = function funcName() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funcName();</span><br><span class="line"></span><br><span class="line">callFunc(a, b);</span><br></pre></td></tr></table></figure>

<p><strong>4.4 立即调用的函数</strong></p>
<p><strong>4.5 严格模式</strong><br>不推荐将严格模式使用在全局之中</p>
<p><strong>4.6 相等</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 == &quot;5&quot; // true</span><br><span class="line">25 == &quot;0x19&quot; // true</span><br><span class="line">2 == true // false</span><br></pre></td></tr></table></figure>

<p>对于对象，则会首先调用对象的 valueOf() 方法，得到原始类型值比较，如果没有定义则调用 toString()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var object =&#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;0x19&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">object == 25; // true</span><br></pre></td></tr></table></figure>
<p>由于强类型转换的情况，所以需要使用&#x3D;=&#x3D;和!=&#x3D;来处理比较的情况。而不推荐使用&#x3D;&#x3D;和!&#x3D; 。</p>
<h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><blockquote>
<p>构建软件设计的方法有两种：一种是把软件做的很简单以至于明显找不到缺陷，另一种是把它做的很复杂以至于找不到明显的缺陷。 - C.A.R.Hoare</p>
</blockquote>
<p><strong>5. 松耦合</strong></p>
<p>很多的设计模式就是为了解决紧耦合的问题。如果2个组件耦合太紧密，就说明一个组件和另一个组件直接相关。</p>
<p>比如有一个名为error的className，贯穿整个站点。有一天觉得他命名不合理需要更改的时候，有可能我们需要做更改上百个使用到它的组件，也有可能只需要更改一个组件。 </p>
<p>你能做到只修改一个组件而不是说修改N个组件，那么就做到了松耦合。对于一些大型系统来说这是至关重要的。</p>
<h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>JS执行环节相对于其他语言来说有很多独特之处，如全局变量和函数的使用。 </p>
<p>JS本身的初始执行环境就定义了多种多样的全局变量，这些全局变量在环境创始之初就存在了。  </p>
<p>全局对象是一个神秘的对象，表示脚本的最外层上下文。  </p>
<p><strong>6.1 全局变量带来的问题</strong></p>
<pre><code>命名冲突  
代码的脆弱性  
难以测试  
</code></pre>
<p><strong>6.2 意外的全局变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    var count = 10;</span><br><span class="line">        title = &quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">    var a = b = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于意外的全局变量一些工具，比如JSLint和JSHint就可以起到作用,严格模式下也会报错。</p>
<p><strong>6.3 单全局变量方式</strong></p>
<p>YUI 引入 唯一 YUI全局变量。<br>jQuery 引入 $ 和 jQuery 全局变量。<br>Dojo 引入 dojo 全局变量。<br>Closure 引入 goog 全局变量。  </p>
<pre><code>命名空间  
模块
</code></pre>
<p><strong>6.4 零全局变量</strong></p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>事件处理在JS中是至关重要的，影响着网站的各个方面。所有的JS代码均通过事件绑定到UI上，所以大多前端工程师需要花费很多的事件来编写和修改事件处理程序。  </p>
<p>大多事件处理程序相关代码和事件环境紧紧偶合在一起，导致了可维护性很糟糕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 不好的例子</span><br><span class="line">function handleClick( event )&#123;</span><br><span class="line">    var popup = document.getElementById( &quot;popup&quot; );</span><br><span class="line">    popup.style.left = event.clientX + &quot;px&quot;;</span><br><span class="line">    popup.style.top = event.clientY + &quot;px&quot;;</span><br><span class="line">    popup.className = &quot;reveal&quot;;</span><br><span class="line">&#125;</span><br><span class="line">addListener(element, &quot;click&quot;, handleClick);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>规则1：隔离应用逻辑</em><br>将应用逻辑从所有的事件处理程序中抽离出来是一种最佳实践。因为很有可能在之后的某段代码中我们会使用到同一段逻辑，抽离就降低了代码的耦合度，增强了可读性和维护成本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var MyApplication = &#123;</span><br><span class="line">    handleClick : function(event)&#123;</span><br><span class="line">        this.showPopup( event )；</span><br><span class="line">    &#125; ,</span><br><span class="line">    </span><br><span class="line">    showPopup : function(event)&#123;</span><br><span class="line">        var popup = document.getElementById( &quot;popup&quot; );</span><br><span class="line">        popup.style.left = event.clientX + &quot;px&quot;;</span><br><span class="line">        popup.style.top = event.clientY + &quot;px&quot;;</span><br><span class="line">        popup.className = &quot;reveal&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addListener(element, &quot;click&quot;, function(event)&#123;</span><br><span class="line">    MyApplication.handleClick( event );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><em>规则二：不要分发事件对象</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var MyApplication = &#123;</span><br><span class="line">    handleClick : function(event)&#123;</span><br><span class="line">        this.showPopup( event.clientX, event.clientY )；</span><br><span class="line">    &#125; ,</span><br><span class="line">    </span><br><span class="line">    showPopup : function(x, y)&#123;</span><br><span class="line">        var popup = document.getElementById( &quot;popup&quot; );</span><br><span class="line">        popup.style.left = x + &quot;px&quot;;</span><br><span class="line">        popup.style.top = y + &quot;px&quot;;</span><br><span class="line">        popup.className = &quot;reveal&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addListener(element, &quot;click&quot;, function(event)&#123;</span><br><span class="line">    MyApplication.handleClick( event );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>清楚地展示了事件处理程序和应用逻辑之间的分工。应用逻辑也不需要对event产生任何依赖，进而很多地方都可以使用相同的应用逻辑。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>8.1 检测原始值</strong></p>
<p>5种原始类型 字符串、数字、布尔值、null和undefined。<br>typeof 可以检测各个原始值的类型，并且返回相应类型字符串。而 typeof null 会返回 “object”。</p>
<p><strong>8.2 检测引用值</strong></p>
<p>对于检测引用值，typeof会力不从心，基本都会返回”object”，那么对于引用值检测最好的方法是使用 instanceof。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if( value instanceof Date )&#123;</span><br><span class="line">    // ... Code</span><br><span class="line">&#125;</span><br><span class="line">if( value instanceof RegExp )&#123;</span><br><span class="line">    // ... Code</span><br><span class="line">&#125;</span><br><span class="line">if( value instanceof Error )&#123;</span><br><span class="line">    // ... Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8.3 检测属性</strong></p>
<p>很多时候我们会使用与 null  undfined 对比来判断是否属性存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if( obj[prop] )&#123;  &#125;</span><br><span class="line">if( obj[prop] != null )&#123;  &#125;</span><br><span class="line">if( obj[prop] != undefined)&#123;  &#125;</span><br></pre></td></tr></table></figure>
<p>这样会导致代码有漏洞，不能将所有的情况都覆盖到。</p>
<h2 id="将配置数据从代码中分离"><a href="#将配置数据从代码中分离" class="headerlink" title="将配置数据从代码中分离"></a>将配置数据从代码中分离</h2><p>代码就是一些计算机运行的指令，当我们传递数据进入计算机的时候，指令对数据进行操作产生结果。  </p>
<p>那么当我们在修改一些数据问题的时候就会带来一些源代码引入BUG的风险，所以对于应用来说，应当将一些关键数据从主要的源码中抽离出来，这样就可以是我们在修改数据或者源码的时候更放心。</p>
<p><strong>9.1 什么是配置数据</strong></p>
<p>配置数据就是我们在应用中写死（hardcoded）的值。<br>配置数据的例子：</p>
<pre><code>1. URL
2. 需要展示给用户看的字符串
3. 重复的值
4. 设置的值，一些配置选项
5. 任何可能发生变化的值
</code></pre>
<p>配置数据随时都有可能做修改，我们不希望因为有人需要修改页面的提示信息而需要修改JS源码。</p>
<p><strong>9.2 抽离配置数据</strong></p>
<p>其实，抽离配置数据非常简单，只需要创建一个管理整体的配置数据的对象即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">    MSG_INVALID_VALUE : &quot;Invalid value&quot;,</span><br><span class="line">    URL_INVALID : &quot;/errors/invalid.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意统一在配置数据对象中的命名。<br>将配置数据提取出来之后任何人需要做修改都不会引起一些代码的逻辑错误问题，对于很大的系统，可以将配置数据专门使用其他单独文件，使其于代码隔离。</p>
<p><strong>9.3 保存配置数据</strong></p>
<p>配置数据最好放在单独的文件之中，以便清晰地分隔数据和应用逻辑。一种值得尝试的方法是将这些配置数据放于非JS的文件中。</p>
<pre><code>1. 使用各种流行的属性文件来存放。（如 Java属性文件）
2. JSONP，将JSON结构使用函数调用包装起来。
3. 纯JS对象
</code></pre>
<h2 id="抛出自定义错误"><a href="#抛出自定义错误" class="headerlink" title="抛出自定义错误"></a>抛出自定义错误</h2><p>编程语言具有“创建”错误的能力，在JS中抛出错误是一门艺术。再合适的时间抛出错误可以大大减少我们调试的事件，对代码的满意度也将急剧提升。</p>
<p><strong>10.1 错误的本质</strong></p>
<p>当某些非期望的事情发生的时候，程序就会要发一个错误。这也许是传入了非法的值，或许是遇到无效的操作符等等。</p>
<p>编程语言定义了一组基本的规则，当偏离了这些规则的时候将导致错误，只有当错误被抛出来时，我们才能有地方入手解决，如果错误无声无息，那么解决的代价可想而知。所以错误时开发者的朋友而非敌人。</p>
<p><strong>10.2 在 JS 中抛出错误</strong></p>
<p>毫无疑问，在 JS 中抛出错误比任何语言中做同样的事情更有价值，这要归结于Web端调试的复杂性。可以使用 throw 操作符，将提供一个对象作为错误抛出，Error对象时最常用的。</p>
<p><strong>10.3 抛出错误的好处</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDivs( element )&#123;</span><br><span class="line">    return element.getElementByTagName(&quot;div&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDivs( element )&#123;</span><br><span class="line">    if( element &amp;&amp; element.getElementsByTagName )&#123;</span><br><span class="line">        return element.getElementByTagName(&quot;div&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Error(&quot;getDivs() : Argument must be a DOM element&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10.4 何时抛出错误</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 不好的写法 检测太多</span><br><span class="line">function addClass(element, className)&#123;</span><br><span class="line">    if( !element || typeof element.className != &quot;string&quot; )&#123;</span><br><span class="line">        throw new Error(&quot;addClass() : First argument must be a DOM element&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if( typeof element.className != &quot;string&quot; )&#123;</span><br><span class="line">        throw new Error(&quot;addClass() : First argument must be a DOM element&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    element.className +=&quot; &quot; + className;</span><br><span class="line">&#125;</span><br><span class="line">// 原本只是需要加一个class 但是加了那么多的抛出错误，就会适得其反。会引起过度杀伤。</span><br><span class="line">// 好的写法</span><br><span class="line">function addClass(element, className)&#123;</span><br><span class="line">    if( !element || typeof element.className != &quot;string&quot; )&#123;</span><br><span class="line">        throw new Error(&quot;addClass() : First argument must be a DOM element&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    element.className +=&quot; &quot; + className;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>1. 当修复了一个难以调试的错误的时候，尝试增加一两个自定义错误，当再次发生错误的时候有助于解决问题。
2. 如果正在编写代码，思考一下我希望哪些事情不会发生，如果发生将引发较大问题，在这个某些问题上抛出错误。
3. 如果在编写别人的代码，思考下他们的使用方式在特定的情况下抛出错误。
</code></pre>
<p><strong>10.5 try-catch 语句</strong></p>
<p>try-catch 可以在浏览器抛出错误之前解析，将可能引发错误的代码放在 try 块中，将处理错误的代码放在 catch 中。当然还可以加入 finally 块。</p>
<p>在catch中不要为空，应该总要写点声明老处理错误，不然就会依旧不知道错误在哪里。</p>
<p><strong>10.6 错误的类型</strong></p>
<pre><code>Error ： 所有错误的基本类型，引擎不会抛出此类型。  
EvalError ： 通过 eval() 函数执行的代码发生错误。  
RangeError ： 一个数字超出边界时抛出，试图创建一个长度为-20的数组。 
ReferenceError ： 期望对象不存在，例如试图在null上调用函数。  
SyntaxError :  语法上的错误。  
TypeError ： 变量不是期望类型的时候。  
URIError ： 给一些内置函数传入非法URL时抛出的错误。
</code></pre>
<h2 id="不是你的对象不要动"><a href="#不是你的对象不要动" class="headerlink" title="不是你的对象不要动"></a>不是你的对象不要动</h2><p><strong>11.1 什么是你的</strong></p>
<p>当你的代码创建了这些对象，那么你拥有这些对象。维护是你的责任。牢记，如果你的代码没有创建这些对象，那么不要修改它们。</p>
<pre><code>1. 原生对象。
2. DOM对象    
3. 浏览器对象模式对象（BOM）。   
4. 类库对象。
</code></pre>
<p><strong>11.2 原则</strong></p>
<p>在JS中，我们将已经存在的对象视为一种背景，在此之上开发代码，应该将JS对象当做一个实用的工具函数来看待。</p>
<p>不覆盖方法，神圣的 document.getElementById 都可以被轻易覆盖。<br>不增加方法，Prototype库就是一个不好的例子，很随意的修改了大量的原生对象和方法。导致在JS的历史上遇到很多问题。在小于1.6的版本中，Prototype定义了一个document.getElementsByClassName()方法<br>不删除方法。</p>
<p><strong>11.3 更好的途径</strong></p>
<p>修改非自己拥有的对象是解决某些问题的很好的方案。可能有一些方法，所谓的设计模式，不直接修改这些对象而是扩展这些对象。</p>
<p>最受欢迎的对象扩充方式就是继承。一种类型的对象如果已经做到了你想要的大多数工作，那么继承，再加一些新的功能即可。JS中有两种基本形式：基于对象的继承和基于类型的继承。</p>
<p><em>11.3.1 基于对象的继承</em></p>
<p>基于对象的继承也就是原型继承，即ES5中的 Object.create() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;Nicholas&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ni = Object.create( person );</span><br><span class="line">// 当然可以扩展对象</span><br><span class="line">var ni = Object.create( person， &#123;</span><br><span class="line">    name : &#123;</span><br><span class="line">        value : &quot;Greg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>一旦以这种方式创建了对象，那么你可以随意修改新对象，毕竟你是对象的拥有者。</p>
<p><em>11.3.2 基于类型的继承</em></p>
<p>基于类型的继承是通过构造函数而非对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function MyError( message )&#123;</span><br><span class="line">    this.message = message;</span><br><span class="line">&#125;</span><br><span class="line">MyError.prototype = new Error();</span><br></pre></td></tr></table></figure>

<p><strong>11.3.3 门面模式</strong></p>
<p>门面模式是一种流行的设计模式，他为一个已经存在的对象创建新的接口，门面模式是一个全新的对象，背后是一个已经存在的对象在工作。</p>
<p>如果你的用例中无法使用继承满足需要，可以使用门面模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funtion DOMWrapper( element )&#123;</span><br><span class="line">    this.element = element;</span><br><span class="line">&#125;</span><br><span class="line">DOMWrapper.prototype.addClass( className )&#123;</span><br><span class="line">    this.element.classmName += &quot; &quot; + className; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wrapper = new DOMWrapper( document.getElementBuId(&quot;myDiv&quot;) );</span><br><span class="line">wrapper.addClass(&quot;selected&quot;);</span><br></pre></td></tr></table></figure>

<p>从JS的可维护性来说，门面模式是非常合适的方式，你可以完全控制这些接口。你可以允许访问任何底层对象的方法或者属性，反之也可以有效地过滤对象的访问。<br>门面实现一个特定的接口，让一个对象看上去像另一个对象就是适配器。两者的差别就是前者创建接口，后者实现已经存在的接口。</p>
<p><strong>11.4 关于Polyfill的注解</strong></p>
<p>随着ES5和H5的特性在各个浏览器中实现，JS polyfills（shims）开始就行起来，polyfill是指一种功能的模拟，这些功能在新版本的浏览器中已经实现，然后用自定义的方式使其在老版本中兼容实现。</p>
<p><strong>11.5 阻止修改</strong></p>
<p>在ES5中已经引入了几个方法来防止对对象的修改。<br>有三种级别： 防止扩展， 密封， 冻结。</p>
<h2 id="浏览器嗅探"><a href="#浏览器嗅探" class="headerlink" title="浏览器嗅探"></a>浏览器嗅探</h2><p>浏览器嗅探始终是web领域的一个热门话题。</p>
<p><strong>12.1 User-Agent 检测</strong></p>
<p>用户代理检测是更具客户端浏览器的user-agent字符串进行检测，但是最大的问题就是解析user-agent并不是很容易，有些浏览器为了保证兼容性，会复制另一个浏览器的user-agent字符串，每当一个新的浏览器出来的时候我们都需要对user-agent检测的代码进行重新修正。意味着我们无法预期的出了问题，只能等待问题出现后再进行处理。</p>
<p><strong>12.2 特性检测</strong></p>
<p>特性检测的原理就是为特定浏览器的各个特性进行检测，并当特性存在时处理问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getById( id )&#123;</span><br><span class="line"></span><br><span class="line">    var element = null;</span><br><span class="line"></span><br><span class="line">    if( document.getElementById )&#123;</span><br><span class="line">        element = document.getElementById( id );</span><br><span class="line">    &#125;else if( document.all )&#123;</span><br><span class="line">        element = document.all[id];</span><br><span class="line">    &#125;else if( document.layers )&#123;</span><br><span class="line">        element = document.layers[id];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性检测的重要组成部分</p>
<pre><code>1. 探测标准方法
2. 探测不同浏览器的特点方法
3. 当被检测方法不存在的时候提供合乎逻辑的备用方案。
</code></pre>
<p><strong>12.3 避免特性推断</strong></p>
<p>特性推断是更具一个特性的存在，推断另外一个特性是否存在。“如果他看起来像鸭子，就必定会像鸭子一样嘎嘎叫”</p>
<p><strong>12.4 避免浏览器推断</strong></p>
<p><strong>12.5 如何取舍</strong></p>
<p>特性推断和浏览器推断是非常糟糕的做法，应当不惜一切代价避免他，纯粹的使用特性检测是一种很好的方式，几乎在任何情况下都是你想要的结果。</p>
<p>对于 user-agent 检测，从来都不禁止他，因为总有非常适合的场景需要使用他。</p>
<h1 id="React的一点学习"><a href="#React的一点学习" class="headerlink" title="React的一点学习"></a>React的一点学习</h1><h2 id="容器型组件-amp-展示型组件"><a href="#容器型组件-amp-展示型组件" class="headerlink" title="容器型组件&amp;展示型组件"></a>容器型组件&amp;展示型组件</h2><p>容器型组件：意味组件如何工作，具体数据如何更新，不包含任何Virtual DOM的修改与组合，不包含组件样式。<br>展示型组件：意味组件是如何渲染的，包含了Virtual DOM的修改与组合。不依赖store。</p>
<p>这样区分能较好的使用相同的展示型组件来配合不同的数据最渲染，提高复用性。</p>
<p>Layouts<br>页面布局结构，讲主框架与页面主体内容分离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Layout = (&#123;children&#125;) =&gt; (</span><br><span class="line">    &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        &lt;div className=&quot;content&quot;&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Views<br>字路由的入口组件，包含此路由下的所有展示型组件。为保持子组件的纯净，在此层中定义数据以及action等，分发到子组件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class HomeView extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; sth, changeType &#125; = this.props;</span><br><span class="line">        const cardProps = &#123; sth, changeType &#125;;</span><br><span class="line">        </span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;page page-home&quot;&gt;</span><br><span class="line">                &lt;Card &#123;...cardProps&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Components<br>渲染组件，包含相关组件的业务逻辑与交互，但所有数据与action均为Views下发，完全脱离数据层存在的展示型组件。项目中数量级别较大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Card extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        </span><br><span class="line">        this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleChange(opts) &#123;</span><br><span class="line">        const &#123; type &#125; = opts;</span><br><span class="line">        </span><br><span class="line">        this.props.changeType(type);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; sth &#125; = this.props;</span><br><span class="line">        </span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;mod-card&quot;&gt;</span><br><span class="line">                &lt;Switch onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">                    //...</span><br><span class="line">                &lt;/Switch&gt;  </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><p>在React组件构建中，对于一类需要被不同需求同时使用的组件，就需要设计组件抽象的概念。主要为mixin与高阶组件。</p>
<p>高阶函数：函数接受函数作为输入，或者输出一个函数。<br>高阶组件：接受React组件作为输入，输出一个新的React组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MyContainer = (WrappedComponent) =&gt; </span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当React组件被包裹，高阶组件返回一个增强型的React组件，使得代码更具有复用性、逻辑性与抽象特性。</p>
<p>抽象一个input组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const MyContainer = (WrappedComponent) =&gt; </span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        consttructor(props) &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state = &#123;</span><br><span class="line">                name: &#x27;&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            this.onNameChange = this.onNameChange.bind(this);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        onNameChange(event) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                name: event.target.value</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        render() &#123;</span><br><span class="line">            const newProps = &#123;</span><br><span class="line">                name: &#123;</span><br><span class="line">                    value: this.state.name,</span><br><span class="line">                    onChange: this.onNameChange</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">@MyContainer</span><br><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;input name=&quot;name&quot; &#123;...this.props.name&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的评论功能页，包含评论内容区域以及评论编辑区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 数据类型</span><br><span class="line">&#123;</span><br><span class="line">    commentList: [</span><br><span class="line">        &#123;name: &quot;cam&quot;, content: &quot;It&#x27;s good!&quot;, publishTime: &quot;2015-01-01&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  CommentList extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        spuer(props);</span><br><span class="line">        </span><br><span class="line">        this.state = &#123;</span><br><span class="line">            loading: true,</span><br><span class="line">            error: null,</span><br><span class="line">            value: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.props.promise.then(respones =&gt; reponse.json())</span><br><span class="line">            .then(value =&gt; this.setState(&#123;loading: false, value&#125;))</span><br><span class="line">            .catch(error =&gt; this.setState(&#123;loading: false, error&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        if (this.state.loading) &#123;</span><br><span class="line">            return &lt;span&gt;loading...&lt;/span&gt;</span><br><span class="line">        &#125; else if (this.state.error !== null) &#123;</span><br><span class="line">            return &lt;span&gt;Error:&#123;this.state.error.message&#125;&lt;/span&gt;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            const list = this.state.value.commentList;</span><br><span class="line">            </span><br><span class="line">            return (</span><br><span class="line">                &lt;ul className=&quot;comment-box&quot;&gt;</span><br><span class="line">                    &#123;list.map((entry, i) =&gt; (</span><br><span class="line">                        &lt;li key=&#123;`response-$&#123;i&#125;`&#125; className=&quot;comment-item&quot;&gt;</span><br><span class="line">                            &lt;p className=&quot;comment-item-name&quot;&gt;&#123;entry.name&#125;&lt;/p&gt;</span><br><span class="line">                            &lt;p className=&quot;comment-item-content&quot;&gt;&#123;entry.content&#125;&lt;/p&gt;</span><br><span class="line">                        &lt;/li&gt;</span><br><span class="line">                    ))&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line"></span><br><span class="line">&lt;CommentList promise=&#123;fetch(&#x27;/api/response.json&#x27;)&#125;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显然数据请求与业务逻辑混合在一起了，那么此时应该具体的确认区分容器型组件与展示型组件的界限。<br>并且对于公共逻辑的抽象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 展示型组件</span><br><span class="line">class CommentList(&#123;commens&#125;) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;ul className=&quot;comment-box&quot;&gt;</span><br><span class="line">            &#123;commens.map((entry, i) =&gt; (</span><br><span class="line">                &lt;li key=&#123;`response-$&#123;i&#125;`&#125; className=&quot;comment-item&quot;&gt;</span><br><span class="line">                    &lt;p className=&quot;comment-item-name&quot;&gt;&#123;entry.name&#125;&lt;/p&gt;</span><br><span class="line">                    &lt;p className=&quot;comment-item-content&quot;&gt;&#123;entry.content&#125;&lt;/p&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 高阶函数 抽象异步加载的模块的结构</span><br><span class="line">const  Promised = (promiseProp, Wrapped) =&gt;class extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        spuer(props);</span><br><span class="line">        </span><br><span class="line">        this.state = &#123;</span><br><span class="line">            loading: true,</span><br><span class="line">            error: null,</span><br><span class="line">            value: null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.props[promiseProp].then(respones =&gt; reponse.json())</span><br><span class="line">            .then(value =&gt; this.setState(&#123;loading: false, value&#125;))</span><br><span class="line">            .catch(error =&gt; this.setState(&#123;loading: false, error&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        if (this.state.loading) &#123;</span><br><span class="line">            return &lt;span&gt;loading...&lt;/span&gt;</span><br><span class="line">        &#125; else if (this.state.error !== null) &#123;</span><br><span class="line">            return &lt;span&gt;Error:&#123;this.state.error.message&#125;&lt;/span&gt;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            const list = this.state.value.commentList;</span><br><span class="line">            </span><br><span class="line">            return &lt;Wrapped &#123;...this.props&#125; &#123;...this.state.value&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  CommentListContainer extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;CommentList comments=&#123;this.props.commentsList&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promised(&quot;comments&quot;, CommentListContainer);</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">&lt;CommentListContainer comments=&#123;fetch(&#x27;/api/response.json&#x27;)&#125; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CommentListContainer 与 CommentList 几乎等同，可以选择合并或者保留。取决于对于未来扩展的考量。</p>
<p><img src="http://image.freefe.cc/Snipaste_2018-04-11_10-12-32.png" alt="image"></p>
<h2 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h2><p>纯函数：<br>给定相同的输入，总返回相同的输出<br>过程没有副作用<br>没有额外的状态依赖</p>
<p>完全独立于外部状态，避免因为共享的外部状态而导致BUG。并且有利于方法级别的测试与重构。</p>
<p>PureRender：将props与state做浅比较（对象仅作引用比较），避免深比较的性能问题。</p>
<p>Immutable：一旦创建，则无法更改的对象，每次操作会生成新的 ImmutableData。</p>
<ol>
<li>降低可变带来的复杂度</li>
<li>节省内存（简化垃圾回收机制）</li>
<li>撤销，复制，时间旅行等实现容易</li>
<li>并发安全</li>
<li>拥抱函数式编程</li>
</ol>
<p>key: 标识当前唯一项的props</p>
<h2 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h2><p>类似纯函数形式，仅简单的接受props渲染生成DOM结构。纯粹未渲染而生的组件。简单便捷与高效。</p>
<h1 id="ES6语法的优雅写法"><a href="#ES6语法的优雅写法" class="headerlink" title="ES6语法的优雅写法"></a>ES6语法的优雅写法</h1><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>一直以来 var 声明让开发者在循环中创建函数以及一些循环事件绑定时，变成容易出错，陷入闭包的问题中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不得已，需要再创建一层作用域来解决此类问题，就显得不那么优雅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var funcs = [];</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push((function(value)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(value);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而块级作用域 let声明解决了该问题，每次迭代均会生成新变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let funcs = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    funcs.push(function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(function(func)&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么新的标准下，最佳实践为默认使用 const，在变量确实需要改变的时候使用 let。</p>
<h2 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h2><p>提供了一套生成、查询、操作来自其他语言里内容的领域专用语言。避免注入攻击，如XSS、SQL注入等。</p>
<p>占位符 ${} 内则为JS表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let count = 10,</span><br><span class="line">    price = 0.25,</span><br><span class="line">    message = `$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;`;</span><br></pre></td></tr></table></figure>

<h2 id="函数-amp-箭头函数"><a href="#函数-amp-箭头函数" class="headerlink" title="函数&amp;箭头函数"></a>函数&amp;箭头函数</h2><p>函数的默认参数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function makeRequest(url, timeout = 2000, callback = function()&#123;&#125;)&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不定参数<br>可以指定对个各自独立的参数，通过整合后的数组进行访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function pick(object, ...keys) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展开运算符<br>类似于不定参数，指定一个数组，将其打散后作为各自独立的参数传入函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let values = [12, 45, 43, 100];</span><br><span class="line">Math.max.apply(Math, values);</span><br><span class="line"></span><br><span class="line">Math.max(...values);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>块级函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line"></span><br><span class="line">    // ES5中报错，ES6中不报错</span><br><span class="line">    function doSomeThing() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数</p>
<ol>
<li>没有this、super、arguments、和new.target 绑定，值由外围最近一层的非箭头函数决定。</li>
<li>不能通过new关键词调用，无[[construct]]方法，不能被作为构造函数。</li>
<li>没有原型。</li>
<li>不能改变this的绑定。</li>
<li>不支持arguments。</li>
<li>不支持从夫命名参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let reflect = (value) =&gt; value;</span><br><span class="line">let sum = (num1, num2) =&gt; num1 + num2;</span><br></pre></td></tr></table></figure>

<p>业务中很多情况我们需要通过bind、闭包保存this等方法解决在处理回调函数时，考虑各种this的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let PageHamdler = &#123;</span><br><span class="line">    id: &#x27;123456&#x27;,</span><br><span class="line">    </span><br><span class="line">    init: function()&#123;</span><br><span class="line">        document.addEventListener(&#x27;click&#x27;, (function(event)&#123;</span><br><span class="line">            this.doSomething(event.type);</span><br><span class="line">        &#125;).bind(this), false)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    doSomething: function(type) &#123;</span><br><span class="line">        console.log(type + &#x27; for &#x27; + this.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简洁形式</span><br><span class="line"></span><br><span class="line">init: function()&#123;</span><br><span class="line">    document.addEventListener(&#x27;click&#x27;,</span><br><span class="line">        event =&gt; this.doSomething(event.type), false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意在VUE不应该使用箭头函数来定义 method 函数 箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例。</p>
</blockquote>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>打破数据结构，将其拆分为更小的部分的过程。</p>
<p>在嵌套过深的一些数据结构中，我们会进行频繁的判定，提取公共对象，取值等一系列操作。<br>而很多情况，我们可以使用 解构+默认值 的方式解决。</p>
<p>这是一坨动漫的业务老代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">const convertBanner = (obj,fromSelf,moduleTitle) =&gt; &#123;</span><br><span class="line">    let result = &#123;&#125;;</span><br><span class="line">    if (obj[&#x27;page_id&#x27;] &amp;&amp; obj[&#x27;link_type&#x27;] == &#x27;1&#x27;) &#123;</span><br><span class="line">        result.id = obj[&#x27;page_id&#x27;];</span><br><span class="line">        result.dataType = &#x27;channel&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if((obj[&#x27;book_id&#x27;] &amp;&amp; obj[&#x27;link_type&#x27;] == &#x27;0&#x27;) || !obj[&#x27;link_type&#x27;])&#123;</span><br><span class="line">        result.id = obj[&#x27;book_id&#x27;];</span><br><span class="line">        result.dataType = &#x27;detail&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(obj[&#x27;link_type&#x27;] == &#x27;2&#x27;)&#123;</span><br><span class="line">        result.url = obj[&#x27;url&#x27;];</span><br><span class="line">        result.dataType = &#x27;outerLink&#x27;;	</span><br><span class="line">    &#125;</span><br><span class="line">    result.title = obj[&#x27;record_title&#x27;];</span><br><span class="line">    result.pic = obj[&#x27;pic&#x27;];</span><br><span class="line">    result.cover = obj[&#x27;pic&#x27;];</span><br><span class="line">    result.dataFrom = fromSelf;</span><br><span class="line">    result.moduleTitle = moduleTitle;    </span><br><span class="line">    // todo server端的频道等其他参数。</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 简单的优化（对于老代码的优化）</span><br><span class="line">const convertBanner = (obj, dataFrom, moduleTitle) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 相关数据的说明</span><br><span class="line">    let &#123;</span><br><span class="line">        url, link_type, pic, book_id</span><br><span class="line">        page_id: id,</span><br><span class="line">        record_title: title</span><br><span class="line">    &#125; = obj;</span><br><span class="line"></span><br><span class="line">    let result = &#123;</span><br><span class="line">        pic,</span><br><span class="line">        title,</span><br><span class="line">        cover: pic,</span><br><span class="line">        dataFrom,</span><br><span class="line">        moduleTitle,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 相关逻辑的说明</span><br><span class="line">    if (link_type === &#x27;0&#x27; &amp;&amp; book_id || !link_type )&#123;</span><br><span class="line">        result.id = book_id;</span><br><span class="line">        result.dataType = &#x27;detail&#x27;;</span><br><span class="line">    &#125; else if (link_type === &#x27;1&#x27;) &#123;</span><br><span class="line">        result.id = page_id;</span><br><span class="line">        result.dataType = &#x27;channel&#x27;;</span><br><span class="line">    &#125; else if(link_type === &#x27;2&#x27;)&#123;</span><br><span class="line">        result.url = url;</span><br><span class="line">        result.dataType = &#x27;outerLink&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 如果是首次的编码</span><br><span class="line">const convertBanner = (obj, dataFrom, moduleTitle) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 相关数据的说明</span><br><span class="line">    let &#123;</span><br><span class="line">        url, link_type = &#x27;0&#x27;, pic, book_id</span><br><span class="line">        page_id: id,</span><br><span class="line">        record_title: title</span><br><span class="line">    &#125; = obj;</span><br><span class="line"></span><br><span class="line">    let result = &#123;</span><br><span class="line">        pic,</span><br><span class="line">        title,</span><br><span class="line">        cover: pic,</span><br><span class="line"></span><br><span class="line">        dataFrom,</span><br><span class="line">        moduleTitle,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 相关逻辑的说明</span><br><span class="line">    switch (link_type)&#123;</span><br><span class="line">        case &#x27;0&#x27;:</span><br><span class="line">            result.id = book_id;</span><br><span class="line">            result.dataType = &#x27;detail&#x27;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#x27;1&#x27;:</span><br><span class="line">            result.id = page_id;</span><br><span class="line">            result.dataType = &#x27;channel&#x27;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case &#x27;2&#x27;:</span><br><span class="line">            result.url = url;</span><br><span class="line">            result.dataType = &#x27;outerLink&#x27;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="其他点"><a href="#其他点" class="headerlink" title="其他点"></a>其他点</h2><p>迭代器&amp;生成器</p>
<p>Promise与异步编程</p>
<p>对象，数组功能性的扩展</p>
<p>模块封装</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">倪颖峰</p>
  <div class="site-description" itemprop="description">曾在果壳、百度蹦哒，目前在B站活跃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">倪颖峰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
