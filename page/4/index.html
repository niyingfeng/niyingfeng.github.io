<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freefe.cc","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:type" content="website">
<meta property="og:title" content="NiYingfeng 的博客">
<meta property="og:url" content="http://freefe.cc/page/4/index.html">
<meta property="og:site_name" content="NiYingfeng 的博客">
<meta property="og:description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="倪颖峰">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://freefe.cc/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>NiYingfeng 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">NiYingfeng 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、生活与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2016/05/28/sublime-set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/05/28/sublime-set/" class="post-title-link" itemprop="url">sublime 前端配置详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-29T00:00:00+08:00">2016-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2016/05/28/sublime-set/" class="post-meta-item leancloud_visitors" data-flag-title="sublime 前端配置详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>\前两天 sublime 出了莫名其妙的BUG，只得重新安装，可谓是惨不忍睹啊。一切屌屌的配置都要从新配起。虽说网上一大堆文献，可惜天下文章一大抄，夸张的说，如果某一篇文章出现文章，整个关键词的文章就废掉了。。。一怒之下，自己整理一篇小记，废话不多说，装起先。</p>
<h3 id="package-control"><a href="#package-control" class="headerlink" title="package control"></a>package control</h3><p>一般 sublime 插件都需要基于 package control，所以首先需要先安装 package control。 两种方法： <code>Ctrl + \</code> 或者 View - Show Console 打开 sublime 的控制台，网上好多同一版本的链接都已经失效，导致无法安装。这边提供最新有效的控制台安装代码。<code> </code>sublime 3 输入：&#96;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &#x27;2915d1851351e5ee549c20394736b442&#x27; + &#x27;8bc59f460fa1548d1514676163dafc88&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by)</span><br></pre></td></tr></table></figure>

<p><code>sublime 2 输入：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os,hashlib; h = &#x27;2915d1851351e5ee549c20394736b442&#x27; + &#x27;8bc59f460fa1548d1514676163dafc88&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllibinstall_opener( urllibbuild_opener( urllibProxyHandler()) ); by = urlliburlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) if dh == h else None; print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h) if dh != h else &#x27;Please restart Sublime Text to finish installation&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>若安装不成功，则先下载 https://github.com/lovenyf/file/blob/master/Package%20Control.sublime-package 将文件放置于 Preferences - Browse Packages 上一级目录的 Installed Packages 中，就ok了。</code> 然后是一大波前端实用的 sublime 插件（均可以在 package control 下安装）</p>
<ul>
<li>HTMLBeautify，CSS Format，JS Format 代码规范格式化插件，功能虽小，但是相当实用。</li>
<li>Git 如果你们是基于 git 开发环境的，sublime 的这个小玩意也会让你爱不释手，无需切回 shell控制台来执行一些 git 命令了。</li>
<li>Git Gutter 非常爽的玩意，能在编辑器内看到diff的内容等</li>
<li>Emmet 无需多说，极速编写html与css， Ctrl + e 搞定一切。（<a target="_blank" rel="noopener" href="http://emmet.io/%EF%BC%89">http://emmet.io/）</a></li>
<li>SublimeCodeIntel 代码提示插件，支持多种编程语言。（<a target="_blank" rel="noopener" href="https://github.com/SublimeCodeIntel/SublimeCodeIntel%EF%BC%89">https://github.com/SublimeCodeIntel/SublimeCodeIntel）</a></li>
<li>CssComb 将杂乱无章的 css 规范 近似一类的样式 归结在一起。</li>
<li>MarkdownEditing 如果没有使用过Markdown，建议可以去使用使用。 MarkdownEditing是一个Sublime Text的Markdown插件。提供了一种合适的Markdown着色方案(light 与 dark)，包含强大的语法高亮，和实用的Markdown编辑功能。支持3种风格：Standard Markdown, GitHub flavored Markdown, MultiMarkdown。</li>
<li>SASS Bulid SASS Build 是一个编写CSS的预处理器。这个特别的插件将帮助你妥善构建包括压缩选项在内的SASS文件。一旦你安装了这个插件</li>
<li>SideBarEnhancements 侧栏右键菜单增强插件，添加大量实用功能。</li>
<li>DocBlockr ( <a target="_blank" rel="noopener" href="https://github.com/spadgos/sublime-jsdocs">https://github.com/spadgos/sublime-jsdocs</a> ) , 规范代码注释，编写可维护的代码。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2016/03/28/dns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/03/28/dns/" class="post-title-link" itemprop="url">小谈DNS，域名解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-29T00:00:00+08:00">2016-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2016/03/28/dns/" class="post-meta-item leancloud_visitors" data-flag-title="小谈DNS，域名解析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DNS 域名系统，作为域名与IP地址相互映射的分布式数据库。通过域名最终得到相对应的 IP 地址的过程称为域名解析。 主机名到IP地址的映射主要的两种方式：</p>
<ol>
<li><code>静态映射</code>，设备上具有自己的映射表来处理查询 IP 的行为。</li>
<li><code>动态映射</code> 通过域名解析系统（DNS），在全球特定的 DNS 服务器上来查询 IP 地址映射。</li>
</ol>
<p>一般来说基本都是结合静态映射与动态映射来获得我们所需的目标域名的 IP 地址。 <img src="http://image.freefe.cc/20161129114825.png"> <code>查询流程</code></p>
<ol>
<li>在浏览器中输入 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 时 ，先会检测本地 hosts 是否有对应的映射，如果有则直接返回此 IP 地址，完成域名解析。</li>
<li>如果 hosts 中未配置，则查询本地 DNS 解析器缓存。查找映射关系，返回给客户端机，完成解析。</li>
<li>如未找到，则会从 TCP&#x2F;IP 中设置的首选 DNS 服务器，也称为本地DNS服务器。如果所查询映射在本地配置区域资源中，则返回给客户端机，并且此解析具有权威性。</li>
<li>若在本地配置区域资源中未找到相关映射，而 DNS 服务器缓存中具有映射，则返回结果给客户端机，但该结果不具有权威性。</li>
<li>当以上过程均为查找到所需的 IP 映射，会根据本地 DNS 服务器是否设置转发器的配置进行查询。</li>
<li>转发模式：此 DNS 服务器会将请求转发到上一级 DNS 服务器，由上一级来进行解析，以此循环，若查询到映射，在以回路的形式返回结果。</li>
<li>非转发模式，本地 DNS 服务器将全球发至13台根 DNS 服务器，根DNS服务器收到请求后会判断这个域名 .com 是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址 baidu.com 给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找 baidu.com 域服务器，重复上面的动作，进行查询，直至找到 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 主机。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2016/02/28/jquery-deferred/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/02/28/jquery-deferred/" class="post-title-link" itemprop="url">jQuery 实现异步队列模块 Deferred</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-02-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-02-29T00:00:00+08:00">2016-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2016/02/28/jquery-deferred/" class="post-meta-item leancloud_visitors" data-flag-title="jQuery 实现异步队列模块 Deferred" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>jQuery 依赖 sizzle 选择器引擎，将 DOM 处理性能优化到了一个很极致的程度，,但 jQuery 还有另一个亮点的处理就是对于异步的处理封装，Deferred，异步队列模块。 异步队列模块最长用到的场景就是 jQuery 封装的 Ajax 模块，不过经常，我们是这么使用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">        url: &#x27;test.php&#x27;,</span><br><span class="line">        data: &#123;test: 123&#125;,</span><br><span class="line">        success: function(data, status, xhr)&#123;&#125;,</span><br><span class="line">        error: function(xhr, status, error)&#123;&#125;,</span><br><span class="line">        complete: function(xhr, status)&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于经过了 Deferred 包装过的 $.ajax，其实我们更应该这样写：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        url: &#x27;test.php&#x27;,</span><br><span class="line">        data: &#123;test: 123&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(function(data, status, xhr)&#123;&#125;)</span><br><span class="line">.fail(function(xhr, status, error)&#123;&#125;)</span><br><span class="line">.complete(function(xhr, status)&#123;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Deferred 实现了将异步任务以及其回调函数的解耦，为 Ajax模块，队列模块，ready模块提供底层的基础。 异步队列模块主要为 $.when -&gt; $.Deferred -&gt; $.callbacks，依赖关系。 `$.Callbacks( flags )` 回调函数列表主要用于对于回调函数的添加，删除，触发，锁定以及禁用。jQuery 中的 Ajax 模块和 Deferred 模块功能强而不乱很大程度上也是归功于 Callbacks 模块的经典设计。 flags 参数：</span><br><span class="line"></span><br><span class="line">*   once: 确保回调列表只会执行一次。</span><br><span class="line">*   memory: 保存上一次的触发值，在回调列表添加新的函数时，使用保存的触发值进行触发。</span><br><span class="line">*   unique: 确保每一个触发值，只会被回调列表的同一个函数触发一次。</span><br><span class="line">*   stopOnFalse: 当一个回调返回false时 停止运行。</span><br><span class="line"></span><br><span class="line">以下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn1 (val) &#123;</span><br><span class="line">        console.log(&#x27;fn1 : &#x27;+val);</span><br><span class="line">&#125;</span><br><span class="line">function fn2 (val) &#123;</span><br><span class="line">        console.log(&#x27;fn2 : &#x27;+val);</span><br><span class="line">&#125;</span><br><span class="line">function fn3 (val) &#123;</span><br><span class="line">        console.log(&#x27;fn3 : &#x27;+val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`once：` ![](http://blog.chinaunix.net/attachment/201602/29/26672038_1456754259nLf8.png) `memory：` ![](http://blog.chinaunix.net/attachment/201602/29/26672038_1456754280EOuw.png) `unique：` ![](http://blog.chinaunix.net/attachment/201602/29/26672038_14567543041rKg.png) `stopOnFalse：` ![](http://blog.chinaunix.net/attachment/201602/29/26672038_1456754329tJXK.png) 将回调函数模块处理分割成 4 种状态这种思想，可以看到各个状态是互不排斥，并且可以随意搭配来生成一个回调函数列表，使其具有一种或者多种的状态值： 所依赖的底层功能函数的灵巧性，也造就了顶层代码功能的强大。其源码结构如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Callbacks = function( options ) &#123;</span><br><span class="line">    var options = createOptions(options);</span><br><span class="line">    var memory,</span><br><span class="line">        // 是否已经 fire 过</span><br><span class="line">        fired,</span><br><span class="line">        // 当前是否还处于 firing 过程中</span><br><span class="line">        firing,</span><br><span class="line">        // fire 调用的起始下标</span><br><span class="line">        firingStart,</span><br><span class="line">        // 需要 fire 调用的队列长度</span><br><span class="line">        firingLength,</span><br><span class="line">        // 当前正在 firing 的回调在队列的索引</span><br><span class="line">        firingIndex,</span><br><span class="line">        // 回调队列</span><br><span class="line">        list = [],</span><br><span class="line">        // 如果不是 once 的，stack 实际上是一个队列，用来保存嵌套事件 fire 所需的上下文跟参数</span><br><span class="line">        stack = !options.once &amp;&amp; [],</span><br><span class="line">        _fire = function( data ) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    var self = &#123;</span><br><span class="line">        add : function()&#123;&#125;,</span><br><span class="line">        remove : function()&#123;&#125;,</span><br><span class="line">        has : function()&#123;&#125;,</span><br><span class="line">        empty : function()&#123;&#125;,</span><br><span class="line">        fireWith : function(context, args)&#123;</span><br><span class="line">                _fire([context, args]);</span><br><span class="line">        &#125;;</span><br><span class="line">        fire : function(args)&#123;</span><br><span class="line">                this.fireWith(this, args);</span><br><span class="line">        &#125;</span><br><span class="line">        /* 其他方法 */</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其主要原理就是使用闭包特性，缓存各类状态值，在 add 方法中加入大量的逻辑判断实现。 再来简单说说 promise ，一个 promise 一般来说是处于三个互斥状态中的一个：</span><br><span class="line"></span><br><span class="line">*   pending：进行中。</span><br><span class="line">*   fulfilled：通过状态。</span><br><span class="line">*   rejected：拒绝状态。</span><br><span class="line"></span><br><span class="line">jQuery 的 Deferred 就是一个基于 Callbacks 的实现遵循 Common Promise/A 规范的一个功能。是的 jQuery 中许多功能方法得以实现异步的任务与回调函数的解耦。具体的，Deferred 有什么作用？ 比如说某一个情况，我需要在某个异步行为完成之后，执行特定的回调函数，那么基本会这么写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function asyn( callback )&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">                //....... // 执行的逻辑代码</span><br><span class="line">                callback(&#x27;123&#x27;); // 异步回调函数</span><br><span class="line">        &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyn( function(val)&#123; alert(val) &#125; );</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就是说，我必须在异步函数调用的时候，就要写好，传入回调函数，导致了上面所执行的逻辑代码必须和异步回调函数放在一起，导致了一定的耦合性，当遇到回调中嵌回调的时候，就可能出现嵌套地狱的情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function asyn()&#123;</span><br><span class="line">        var dtd = $.Deferred();</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">                //....... // 执行的逻辑代码</span><br><span class="line">                dtd.resolve(&#x27;123&#x27;); // 异步回调函数</span><br><span class="line">        &#125;, 100);</span><br><span class="line">        return dtd;</span><br><span class="line">&#125;</span><br><span class="line">var dtd = asyn();</span><br><span class="line">dtd.done(function(val)&#123; alert(val) &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其源码则是基于 Callbacks 的演化：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Deferred: function( func ) &#123;</span><br><span class="line">        var tuples = [</span><br><span class="line">                        // action, add listener, listener list, final state</span><br><span class="line">                        [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],</span><br><span class="line">                        [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],</span><br><span class="line">                        [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]</span><br><span class="line">                ],</span><br><span class="line">                state = &quot;pending&quot;,</span><br><span class="line">                promise = &#123;</span><br><span class="line">                        state: function() &#123;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        always: function() &#123;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        then: function( /* fnDone, fnFail, fnProgress */ ) &#123;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        promise: function( obj ) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                deferred = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        promise.pipe = promise.then;</span><br><span class="line">        ...</span><br><span class="line">        return deferred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Deferred 的 done 和 fail 传递回调函数分别对应在 resolve 和 reject 调用之后触发，或者在resolve 和 reject 调用之后，done fail 绑定回调函数的时候触发。当然 Deferred 还包括 then，promise，always等功能方法。 所以说，当无穷的嵌套地狱困扰回调函数的时候，不妨试试 promise 的解耦回调。 当然还有个不得不说的 $.when，当回调依赖回调形成嵌套回调的时候，可以使用 Deferred 很好的来解决，当回调依赖于多块异步逻辑代码的时候，经过 Deferred 封装的 when 就展现光彩了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var d1 = $.Deferred();</span><br><span class="line">var d2 = $.Deferred();</span><br><span class="line"></span><br><span class="line">$.when( d1, d2 ).done(function ( v1, v2 ) &#123;</span><br><span class="line">        console.log( v1 ); // &quot;Fish&quot;</span><br><span class="line">        console.log( v2 ); // &quot;Pizza&quot;</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">        dresolve( &quot;Fish&quot; );</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">        dresolve( &quot;dog&quot; );</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>
<p>&#96;&#96;&#96;</p>
<p>很对情况就是像，当我们展现某块数据，而数据依赖多个数据接口的时候，非常有用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/09/29/animate-performance-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/09/29/animate-performance-optimization/" class="post-title-link" itemprop="url">关于动画到硬件加速的那点事儿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-30T00:00:00+08:00">2015-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/09/29/animate-performance-optimization/" class="post-meta-item leancloud_visitors" data-flag-title="关于动画到硬件加速的那点事儿" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目前我们关于实现动画的方式，无非就是类似 jQuery的动画， CSS 的 animation，transition，tranform 或者 requestAnimationFrame 以及触及GPU的硬件加速动画。 jQuery的动画不用说，就普通的 CSS 动画而言使用浏览器自身的渲染引擎来处理动画的渲染，而触发 CSS 硬件加速则是通过 GPU 来提升 CSS 动画的性能，将有关于动画的运算从 CPU 移植到 GPU 上，大大提高渲染动画的效率。GPU 在对于渲染图形方便的优势，所以能在渲染动画上更容易达到每秒60帧的顺滑效果，使得视觉上顺畅无比。 简单来讲，当一个页面初次加载完毕的时候，浏览器的渲染引擎便开始了它的工作：</p>
<ul>
<li>浏览器解析HTML， 构建一棵 DOM 树，其每个节点对应页面的每个元素。</li>
<li>渲染引擎对 DOM树，以浏览器解析后的 CSS ，会对应构建出一棵 Render 树，其每个节点 RenderObject包含了所对应 DOM 的最终样式信息。</li>
<li>基于 Render 树，渲染引擎会将其中的某些特定节点同时创建新的 RenderLayer，从而还会生成一棵 RenderLayer 树。</li>
<li>当 Render 树和 RenderLayer 树构建完毕之后，便依据两者，遍历各个节点开始渲染绘制出页面。</li>
</ul>
<p><img src="http://blog.chinaunix.net/attachment/201509/30/26672038_14435988628aR6.png"> 再简单介绍下 chrome 的 timeline 的几个名词：</p>
<ul>
<li>Timer Fire： 定时器触发，很简单，比如 jquery 的动画均是通过 setTimeout 来处理生产动画效果（一般性的动画），所以每次展现完毕后都会触发下一个定时器事件 JS 的过程。</li>
<li>Recalculate Style：将 CSS 构建与 DOM 对应的的树，一般称之为 Render 树的过程。</li>
<li>Layout：依据 Render 树，以及 RenderLayer 树进行页面布局的过程。</li>
<li>Print：更具布局，绘制出页面的过程</li>
<li>Composite Layers：渲染展现到屏幕的过程</li>
</ul>
<p>最古老的动画形式： HTML：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;square&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.square&#123;</span><br><span class="line">        position:relative;</span><br><span class="line">        top:50px;</span><br><span class="line">        left: 50px;</span><br><span class="line">        margin-bottom: 10px; </span><br><span class="line">        height:80px;</span><br><span class="line">        width:80px;</span><br><span class="line">        background-color:#999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;.jquery&#x27;).click(function()&#123;</span><br><span class="line">        $(&#x27;.square&#x27;).animate(&#123;</span><br><span class="line">                height: 300,</span><br><span class="line">                width: 300,</span><br><span class="line">                left:200,</span><br><span class="line">                top:200,</span><br><span class="line">                opacity: 5&#125;,</span><br><span class="line">                3000, &#x27;linear&#x27;, function() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上是一个很简单 jq 动画效果，3秒钟从原有图形样式转变到指定的图形样式，但是，浏览器所处理的却是一段 jq 分割的复杂的过程， <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_14435978423d0d.png"> 每一次浏览器都要处理包括 Timer Fire，Recalculate Style，Layout，Paint，Composite Layers，一次又一次的不断重复又循环，内存占用率也是随之增大。 <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_1443597942uS7O.png"> 如今的时代，css的动画帮我们解决了很多难题， 普通的2D CSS动画： CSS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.css2d&#123;</span><br><span class="line">        width:300px;</span><br><span class="line">        height:300px;</span><br><span class="line">        left:200px;</span><br><span class="line">        top:200px;</span><br><span class="line">        transition: width 3s linear, height 3s linear,top 3s linear,left 3s linear;</span><br><span class="line">        -webkit-transition: width 3s linear, height 3s linear,top 3s linear,left 3s linear,;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;.css-2d&#x27;).click(function()&#123;</span><br><span class="line">        $(&#x27;.square&#x27;).addClass(&#x27;css2d&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接上图，计算样式以及重新布局均有浏览器自身完成，并且少了定时器触发事件这一块，使得动画运行方式更为自然， <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_1443598040RPIT.png"> 还有内存图： <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_1443598115lJHb.png"> 或许感觉还不错了，但是由于涉及到了一些或导致重排的属性，使得动画的时候一直重排重绘，那么来看看硬件加速的样式动画吧， 吊炸天的硬件加速CSS动画： CSS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.hardware&#123;</span><br><span class="line">        -webkit-animation: hardware 2s infinite linear;</span><br><span class="line">        animation: hardware 2s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes hardware &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">                transform: translate3d(0,0,0) scale3d(1,1,1);</span><br><span class="line">                -webkit-transform: translate3d(0,0,0) scale3d(1,1,1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        50% &#123;</span><br><span class="line">                transform: translate3d(150px,150px,0) scale3d(3,3,1);</span><br><span class="line">                -webkit-transform: translate3d(150px,150px,0) scale3d(3,3,1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@keyframes hardware &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">                transform: translate3d(0,0,0) scale3d(1,1,1);</span><br><span class="line">                -webkit-transform: translate3d(0,0,0) scale3d(1,1,1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        50% &#123;</span><br><span class="line">                transform: translate3d(150px,150px,0) scale3d(3,3,1);</span><br><span class="line">                -webkit-transform: translate3d(150px,150px,0) scale3d(3,3,1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;.css-hardware&#x27;).click(function()&#123;</span><br><span class="line">        $(&#x27;.square&#x27;).addClass(&#x27;hardware&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于硬件加速的动画，浏览器渲染的过程： <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_1443598224ob6h.png"> 屌不屌其实都一样啦，只不过没有使用处理元素的一些，如height， width，left，top 等元素值的动画，而使用了一些3D CSS属性达到了我们所需的动画效果，但是浏览器处理动画却已经完全不一样。动画过程优化到了仅剩Recalculate Style，Composite Layers 两个过程。 <img src="http://blog.chinaunix.net/attachment/201509/30/26672038_1443598249rf4X.png"> 这边为什么会这么吊呢，这就全依仗与 对应所生成的第三种树 RenderLayer 树，该元素节点被渲染引擎根据 CSS 创建了对应的 RenderLayer 树节点，并将其绑定到 GPU，当该 RenderLayer 的 transform 等变化时候，跳过浏览器的 Layout，以及 Print，直接有 GPU 对其做变换。这个也是直接提升动画性能，内存突然降低（计算被移植到了GPU）的原因。 那么如何来处理 CSS，将我们所需要进行动画的元素构建时拥有新建的 RenderLayer 节点呢？ 目前查询到的资料来看，chrome 以下：</p>
<ul>
<li>3D或透视变换（perspective transform）CSS属性</li>
<li>使用加速视频解码的\<video>节点</li>
<li>拥有3D（WebGL）上下文或加速的2D上下文的\<canvas>节点</li>
<li>混合插件（如Flash）</li>
<li>对自己的opacity做CSS动画或使用一个动画webkit变换的元素</li>
<li>拥有加速CSS过滤器的元素</li>
<li>元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</li>
</ul>
<p>一般我们都会尝试对需要进行动画的元素添加一个 3D 的属性从而来触发其硬件加速的动画效果，现在又有一个专门用作触发生成新 RenderLayer 的属性值 will-change。 当然以上动画最优情况只正对于部分 GPU 加速处理的 CSS 属性，对于涉及到重排 relayout 和 重绘 repaint 的属性我们可能需要慎重考虑以及优化了。 <code>重排：</code>重排是页面结构调整，获取或者设置元素某些属性值时，触发了浏览器 Layout 过程重新定义的情况，比如调整元素的几何大小，位置，获取宽高等。重排必然导致重绘，浏览器渲染总会依照 Layout，Paint，Composite Layers 的流程来处理。下面是触发重排的一些主要情况：</p>
<ul>
<li>脚本操作DOM，增加删除可视的DOM节点</li>
<li>操作 class 属性，或者设置 style 属性</li>
<li>计算获取当前 offsetTop&#x2F;Left&#x2F;Width&#x2F;Height, scrollTop&#x2F;Left&#x2F;Width&#x2F;Height, clientTop&#x2F;Left&#x2F;Width&#x2F;Height, width, height 等属性值</li>
<li>内容变化， 窗口调整等</li>
</ul>
<p><code>触发重排的属性：</code> <code>盒子模型的相关属性：</code>width, height, padding, margin, display, border <code>定位特性的相关属性：</code>top, bottom, left, right, position, float, clear <code>内容的相关属性：</code>text-align, overflow, font-family, line-height,font-size <code>重绘：</code>重排必然导致重绘，并且对于仅调整各类属性色值等时，浏览器重新绘制输出到浏览器的情况。 触发重排的属性：color, border-style, visibility, background, outline, box-shadow 等 一些动画的重排重绘我们不可避免，我们要做的并不是禁止它，存在即合理，事实只有我们滥用。以下是一些简单的优化重排，重绘的方法：</p>
<ul>
<li>将多次需要频繁改变的样式一次性完成，不要频繁的获取计算样式。</li>
<li>将大量的操作 DOM 操作放置到页面之外进行。</li>
<li>尽可能在最末端需要调整的 DOM 上改变 class，减小对其它 DOM 的影响。</li>
<li>动画尽量应用到 position 为 absolute 或者 fixed 的元素上，以便当前元素的动画造成大规模的重排。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/08/27/box-flex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/08/27/box-flex/" class="post-title-link" itemprop="url">box-flex 弹性可伸缩盒模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-28T00:00:00+08:00">2015-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/08/27/box-flex/" class="post-meta-item leancloud_visitors" data-flag-title="box-flex 弹性可伸缩盒模型" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前一直针对于PC端开发，自适应方面接触甚少，一般来说用些的 css 方法就直接解决一些设计问题，直到目前现状开始转变为纯移动端开发，于是乎开始慢慢接触移动端的新特性的实战，今天主要做一下 flexbox 的笔记。 Flexbox 布局模块提供了我们一个在未知或者动态容器中自适应出我们所希望的布局形式。垂直居中，重新排序，布局动态的伸展以及收缩等。目前在移动端大体来说兼容性还不错 can I use(Flex)。 Flexbox 实质来说并不能仅仅作为一种属性，而是作为一类模块，包括作为父元素的伸缩容器以及子元素的伸缩元素。伸缩元素会依据伸缩容器具体变化，类似于在一些情况下我们盒大小使用百分比情况类似，不过使用百分比总会有那么一些时候需要我们使用不太规范的方式来处理某些特定的情况情况。 前提是容器的宽高已定： <img src="http://image.freefe.cc/20170120105016.png"> 对于上面很常见的布局逻辑，一般来说会简单的使用下面形式的 html ```</p>
<p>``` 配合以下的 css ``` .container{ width: 300px; height: 100px; margin: 50px; } .item{ float: left; width: 33.33%; height: 100%; } .item:nth-child(1){ background-color: #333; } .item:nth-child(2){ background-color: #666; } .item:nth-child(3){ background-color: #999; } ``` 但是 我们更多的是会遇到这种形式 <img src="http://image.freefe.cc/20170120105036.png"> 那么 好吧 借助于一些通用的 css3 的伪类选择器 还是可以写的稍微好看一点，不过 html 也需要稍微恶心的包上一层，当然也有好多简单的 hack写法 ```</p>
<p>``` css 如下 ``` .container1{ width: 300px; height: 100px; margin: 50px; border: 1px solid #000; } .item1{ float: left; width: 33.33%; height: 100%; } .innerItem1{ height: 90px; margin: 5px 5px 5px 0; background-color: #CCC; } .item1:nth-child(1) .innerItem1{ margin-left: 5px; } ``` 好的，flexbox 闪亮登场 如何使用例1中的 html 结构 优美的写出例2的布局呢？ ```</p>
<p>``` 首先，对于 flexbox 我们需要创建一个 flex 容器，设置其 display 属性 ``` .container{ width: 300px; height: 100px; margin: 50px; border: 1px solid #000; display:-webkit-flex; display:-ms-flexbox; display:flex; } ``` 在对其子元素设置 flex： ``` .item{ flex:1; background-color: #999; margin: 5px 5px 5px 0; } .item:nth-child(1){ margin-left: 5px; } ``` 使得我们既不需要多放置一层div，也无需来处理写死内部伸缩元素的高度，最主要的却是内部元素的宽高已经完全依赖自适应于容器元素。将容器元素宽高随意配置均可使其子元素得到自适应（之前多嵌套一层的 高度上依旧不是很好处理）。 然后，处理高度的来了，先来个垂直居中吧。 <img src="http://image.freefe.cc/20170120105052.png"> 好吧，一般形式的已经不想写了，直接看下 flexbox 的形式 ``` &#x2F;&#x2F;html</p>
<p>&#x2F;&#x2F; css .container-h{ height: 300px; width: 100px; margin: 50px; border: 1px solid #000; display:-webkit-flex; display:-ms-flexbox; display:flex; &#x2F;<em>垂直居中</em>&#x2F; -webkit-align-items: center; align-items: center; } .item-h{ flex:1; height:100px; background-color: #999; margin: 5px; } ``` 终于写个垂直居中，我可以不用量 line-height，不用设置margin，也不用去攀比各种css的奇思妙想了。突然感觉世界的起跑线都一样了。 <strong>好了，先来熟悉下了解 felxbox 之前的一些简单概念：</strong> * 伸缩容器：一个设置了 display 为 flex 或者 inline-flex 的外层元素 * 伸缩元素：在伸缩容器中的子元素 * 主轴：延伸缩容器配置伸缩元素的方向 * 侧轴：主轴的垂直线 #### 伸缩容器属性简单介绍： &gt; flex-direction : row | row-reverse | column | column-reverse; &gt; 在伸缩容器上定义用来定义主轴方向。 <strong>row</strong>：为默认方向，排版方向 <img src="http://image.freefe.cc/20170120105104.png"> <strong>row-reverse</strong>：与 row 反方向 <img src="http://image.freefe.cc/20170120105115.png"> <strong>column</strong>：从上到下排版 <img src="http://image.freefe.cc/20170120105131.png"> <strong>column-reverse</strong>：与 column 排版方向相反 <img src="http://image.freefe.cc/20170120105143.png"> &gt; flex-wrap : nowrap | wrap | wrap-reverse; &gt; 在伸缩容器上用来定义容器内伸缩元素是单行还是多行显示。（各个伸缩元素设置最小高宽，在每个元素最小宽度下伸缩容器无法一行内放置的时候所做的处理） <strong>nowrap</strong>：默认值，伸缩容器为单行显示，当容器太小时，内部元素会跑出 <img src="http://image.freefe.cc/20170120105155.png"> <strong>wrap</strong>：内部元素会多行显示，伸缩容器一行内放置不下的元素会被放置到下一行（与排版方向有关） <img src="http://image.freefe.cc/20170120105211.png"> <strong>wrap-reverse</strong>：内部元素会多行显示，伸缩容器一行内放置不下的元素会被往上位置放置 <img src="http://image.freefe.cc/20170120105222.png"> <strong>flex-flow</strong> : || 为上面两种属性的缩写版。 &gt; justify-content ： flex-start | flex-end | center | space-between | space-around; &gt; 为可伸缩模型的重头戏，也是真正优雅实现各种居中的css3属性。 <strong>flex-start</strong>：伸缩元素向起始位置靠齐 <img src="http://image.freefe.cc/20170120105235.png"> <strong>flex-end</strong>：伸缩元素向结束位置靠齐 <img src="http://image.freefe.cc/20170120105244.png"> <strong>center</strong>：伸缩元素居中 <img src="http://image.freefe.cc/20170120105254.png"> <strong>space-between</strong>：均匀分布，第一个向起始位置靠齐，最后一个向结束位置靠齐 <img src="http://image.freefe.cc/20170120105305.png"> <strong>space-around</strong>：伸缩元素平均分布在行里，首尾保留一半空间 <img src="http://image.freefe.cc/20170120105315.png"> &gt; align-items：flex-start | flex-end | center | baseline | stretch; &gt; 用来定义伸缩容器内部的伸缩项目在侧轴上的对齐方式 <strong>flex-start</strong>：伸缩元素向侧轴起始位子靠拢 <img src="http://image.freefe.cc/20170120105329.png"> <strong>flex-end</strong>：伸缩元素向侧轴结束位子靠拢 <img src="http://image.freefe.cc/20170120105338.png"> <strong>center</strong>: 伸缩元素居中对齐 <img src="http://image.freefe.cc/20170120105352.png"> <strong>baseline</strong>：侧轴方向根据基线对齐 <img src="http://image.freefe.cc/20170120105402.png"> <strong>stretch</strong>: 为默认值，会更具伸缩的状态尽可能填充伸缩容器。 #### 项目的属性： <strong>order：</strong> 标示伸缩项目在容器中的排序先后。 <strong>flex : none | [ ? || ]</strong> **flex-grow : ** 伸缩元素的无单位的伸缩比例 **flex-shrink : ** 根据弹性盒子元素所设置的收缩因子来作比例收缩空间。 **flex-basis : ** 根据弹性盒子元素所设置的收缩因子来作比例收缩剩余的空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/04/13/ecmascript-6-promises-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/04/13/ecmascript-6-promises-3/" class="post-title-link" itemprop="url">ECMAScript 6 promises（下）：谈谈 API（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2015-04-14T00:00:00+08:00">2015-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/04/13/ecmascript-6-promises-3/" class="post-meta-item leancloud_visitors" data-flag-title="ECMAScript 6 promises（下）：谈谈 API（二）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址： <a target="_blank" rel="noopener" href="http://www.2ality.com/2014/10/es6-promises-api.html">http://www.2ality.com/2014/10/es6-promises-api.html</a><br>原文作者：Dr. Axel Rauschmayer</p>
<p>译者：倪颖峰</p>
<p>博文下半部分为纯干活内容，包括介绍的 ES6 中 Promise API，以及其简单的实现方式与思想，以及一些拓展内容。</p>
<h2 id="9-速查表：ES6的-promise-API"><a href="#9-速查表：ES6的-promise-API" class="headerlink" title="9. 速查表：ES6的 promise API"></a>9. 速查表：ES6的 promise API</h2><p>这边简单的给出一下 ES6 promise 的API 简述，详细描述请看[<a target="_blank" rel="noopener" href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">文档]</a></p>
<h3 id="9-1-术语"><a href="#9-1-术语" class="headerlink" title="9.1. 术语"></a>9.1. 术语</h3><p>promise 的 API 就是关于异步获取结果。一个 promise 对象是一个独立的对象，但会通过该对象传递结果。</p>
<p><strong>状态：</strong></p>
<ul>
<li>一个promise 一般来说会处于以下三种互斥状态中的一种：<ul>
<li>结果未完成时，promise 状态为 pending。</li>
<li>结果通过时，promise 状态为 fulfilled。</li>
<li>当错误发生时，promise 状态变为 rejected。</li>
</ul>
</li>
<li>一个promise 一旦被设置则为“运行完成”（包括 fulfilled 或者 rejected）。</li>
<li>一个peomise 一旦被设置之后便不能在改变。</li>
</ul>
<p><strong>状态变化反应：</strong></p>
<p>Promise reastions 就是你是用 promise 方法 then 来注册的回调函数，用来监听状态 fulfillment 和 rejected。</p>
<p>一个 then式即为一个含有 promise 风格方法 then 的对象。即使该方法仅仅只是监听状态的，依然为 then 式。</p>
<p><strong>状态改变：</strong></p>
<p>有两种改变 promise 状态的方式。一旦你调用了其中的一个，那么进一步调用将会无效。</p>
<ul>
<li>拒绝一个 promise 表示这个promise 被设为 rejected。</li>
<li>通过一个 promise 有两种情况，取决于以什么值来解决的：<ul>
<li>使用一个普通值（非 then式）来解决 promise。</li>
<li>解决 promise P 以一个 then式的 T，意味着P 不再可以设置 resolved，而将会随着 T的状态走，即其 fulfillment 和 rejection 值。P 的回调会在T 被设置状态后合适的时候触发（或者如果T 已经被设置状态了，那么就会立即触发）。</li>
</ul>
</li>
</ul>
<h3 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2. 构造函数"></a>9.2. 构造函数</h3><p>promise 的构造函数为以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(executor(resolve, reject));</span><br></pre></td></tr></table></figure>

<p>上面创建了一个行为由回调函数 exector 决定的 promise。使用参数来处理解决或者拒绝 p：</p>
<ul>
<li>resolve(x)，以 x 来解决 p：<ul>
<li>如果 x 是 then式的，那么它的结果会转到 p（包括通过 then() 注册的触发反馈）。</li>
<li>否者，p 就以 x 处理 fulfilled 状态。</li>
</ul>
</li>
<li>reject(x)，以 e 值来拒绝 p（通常为一个 Error 的子类）。</li>
</ul>
<h3 id="9-3-静态方法"><a href="#9-3-静态方法" class="headerlink" title="9.3. 静态方法"></a>9.3. 静态方法</h3><p>所有的 Promise 的静态方法都支持实例化：通过接收器来创建一个实例（像：new this），并且通过它来访问这些静态方法（this.resolve 与 Promise.resolve）。</p>
<p><strong>创建 promises：</strong> 下面两种方式来创建接收器的实例。</p>
<ul>
<li>Promise.resolve(x):<ul>
<li>如果 x 是 then式的，它将转化为一个 promise（接收器的实例）。</li>
<li>如果 x 是一个 promise，返回将没有变化。</li>
<li>否者将会返回一个接收器的实例并且以 x 来处理 fulfilled 状态。</li>
</ul>
</li>
<li>Promise.reject(reason)：创建一个新的promise，并且以 reason 值来处理拒绝状态。</li>
</ul>
<p><strong>组合 promises：</strong> 直观来说，静态方法 Promise.all() 和 Promise.race() 组合迭代的 promises 变为一个单一的 promise。即：</p>
<ul>
<li>它们采用迭代。迭代的元素通过 this.resolve() 来转化为 promises。</li>
<li>它们返回一个新的 promise。这个 promise 返回一个新的接收器的实例。</li>
</ul>
<p><strong>方式有：</strong></p>
<ul>
<li>Promise.all(iterable)：如此返回一个 promise<ul>
<li>如果迭代的元素均为 fulfilled 那么将其设置为 fulfilled。成功值：各个成功值生成的数组。            </li>
<li>当元素中有任何一个失败时便设置其为 rejected。拒绝值：第一个解决状态的值。</li>
</ul>
</li>
<li>Promise.race(iterable)：迭代的第一个被设置完毕的元素被用来解决返回的 promise。</li>
</ul>
<h3 id="9-4-继承原型方法"><a href="#9-4-继承原型方法" class="headerlink" title="9.4. 继承原型方法"></a>9.4. 继承原型方法</h3><p>Promise.prototype.then(onFulfilled, onRejected);</p>
<ul>
<li>回调函数 onFulfilled 和 onRejected 被车称为 reactions。</li>
<li>如果该 promise 已经被设为 fulfilled，或者一旦变成 fulfilled 状态，那么回调函数 onFulfilled 就会被立即执行。相同，被触发之后 onRejected 也一样。</li>
<li>then() 返回一个新的 promise Q（通过接收器的构造函数创建）：<ul>
<li>任意 reactions 返回一个结果，Q 便使用其来通过。</li>
<li>任意 reactions 抛出一个错误，Q 便使用其来拒绝。</li>
</ul>
</li>
<li>触发 reactions：<ul>
<li>如果 onFulfilled 被触发了，那么一个通过状态的接收器就会被转发到 then() 的结果中。</li>
<li>如果 onRejected 被触发了，那么一个拒绝状态的接收器就会被转发到 then() 的结果中。</li>
</ul>
</li>
</ul>
<p>触发 reactions 的默认值可以以以下方式执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function defaultOnFulfilled(x)&#123;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">function defaultOnRejected(e)&#123;</span><br><span class="line">	throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Promise.prototype.catch(onRejected)：</strong> 与 then(null, onRejected) 一样。</p>
<h2 id="10-promises-的优势与劣势"><a href="#10-promises-的优势与劣势" class="headerlink" title="10. promises 的优势与劣势"></a>10. promises 的优势与劣势</h2><h3 id="10-1-优势"><a href="#10-1-优势" class="headerlink" title="10.1. 优势"></a>10.1. 优势</h3><p><strong>统一的异步 APIs</strong><br>promises 的一个重要的优点就是被越来越多的浏览器的异步 API 使用，统一了当前多样化和不兼容的各种模式和约定。看一下即将出现的两种基于 promise 的API。</p>
<p>基于 promise 的 ferch API 替代 XMLHttpRequest：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">.then(request =&gt; request.text())</span><br><span class="line">.then(str =&gt; ...)</span><br></pre></td></tr></table></figure>

<p>fetch() 会对实际的请求返回一个 promise，text() 会对内容作为字符串返回一个 promise。</p>
<p>ECMAScript 6 API 编程式导入模块也是基于 promise：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.import(&#x27;some_modle.js&#x27;)</span><br><span class="line">.then(some_module =&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>promises VS events</strong></p>
<p>对比 events，promises 更适合做一次性结果的监听。不管你是在得到结果之前或者之后注册都不会影响你监听到结果。这是 promises 更本上的优势。另一方面，你不能使用它来处理一些反复性的事件。链式是         promise 的另一个优势，但是每次只能添加一个。</p>
<p><strong>promises VS callbacks</strong></p>
<p>对比回调函数，promises 具有更简洁的函数（方法）参数。在 callbacks 中，参数包含输入输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(name, opts?, function(err, data))</span><br></pre></td></tr></table></figure>

<p>而 promise 中，所有的参数均只是输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readFilePromisified(name, opts?)</span><br><span class="line">.then(dataHandler, errorHandler)</span><br></pre></td></tr></table></figure>

<p>此外，promises 的优势还包括更好的错误处理机制（异常的集成）和组合更任意更容易（因为你可以使用一些同步的工具，比如 Array.prototype.map()）。</p>
<h3 id="10-2-劣势"><a href="#10-2-劣势" class="headerlink" title="10.2. 劣势"></a>10.2. 劣势</h3><p>Promises 对于单一的异步结果能处理的很好。但是它不擅长于：</p>
<ul>
<li>反复性事件：如果你对此感兴趣，可以看一下 reactive programming（<a target="_blank" rel="noopener" href="http://reactive-extensions.github.io/RxJS/%EF%BC%89%EF%BC%8C%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9A%84%E5%B7%A7%E5%A6%99%E6%96%B9%E5%BC%8F%E3%80%82">http://reactive-extensions.github.io/RxJS/），关于链式处理普通的事件监听的巧妙方式。</a></li>
<li>数据流：支持的标准正在完善中。</li>
</ul>
<p>ECMAScript 6 的 promises 缺少一下的两个基本功能点：</p>
<ul>
<li>你无法取消。</li>
<li>你无法确定他们要在多久之后发生（例如在客户端用户界面展现进度条）。</li>
</ul>
<p>Q promises 库支持后者，并且也将计划添加到 Promises&#x2F;A+。</p>
<h2 id="11-promises-与-生成器"><a href="#11-promises-与-生成器" class="headerlink" title="11. promises 与 生成器"></a>11. promises 与 生成器</h2><p>由于一个实用功能 Q.spawn()，你可以通过生成器来实现在浅协程里使用基于 promises 的函数。这是一份重要的优点使得代码看起来类似于同步，并且可以使用一些同步机制，比如说 try-catch：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q.spawn(function* () &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">			let [foo, bar] = yield Promise.all([ // (A)</span><br><span class="line">					httpGet(&#x27;foo.json&#x27;),</span><br><span class="line">					httpGet(&#x27;bar.json&#x27;)</span><br><span class="line">			]);</span><br><span class="line">			render(foo);</span><br><span class="line">			render(bar);</span><br><span class="line">	&#125; catch (e)&#123;</span><br><span class="line">			console.log(&#x27;Read failed: &#x27;+ e );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Q.spawn() 的参数是生成器函数。如果 yield 标识符是有效的，那么将发生下面的事情：</p>
<ul>
<li>函数执行将被暂停。</li>
<li>操作符 yield 被函数返回（返回，描述的不确切，暂时忽略）。</li>
<li>随后函数会被恢复成一个值或者异常。前者情况继续执行之前暂停的那个点，yield 返回一个值。后者情况表达式被抛入函数中，类似 yield 操作符从内部被扔入。</li>
</ul>
<p>从而，很清楚的明白 Q.spawn() 所做的事情：当生成器函数产生一个 promise，spawn 便注册 reaction，等待处理。如果 promise 通过状态，生成器便会恢复一个结果。如果 promise 为拒绝，一个异常便会抛入注册器中。</p>
<p>这是一个通过新的语法结构-异步函数。来添加支持 JS spawn 的提案（<a target="_blank" rel="noopener" href="https://github.com/lukehoban/ecmascript-asyncawait%EF%BC%89%E3%80%82%E4%B9%8B%E5%89%8D%E4%BE%8B%E5%AD%90%E4%BD%9C%E4%B8%BA%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%BA%94%E8%AF%A5%E5%A6%82%E4%B8%8B%E3%80%82%E5%BA%95%E5%B1%82%EF%BC%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%BE%83%E5%A4%9A%E4%B8%8D%E5%90%8C">https://github.com/lukehoban/ecmascript-asyncawait）。之前例子作为异步函数应该如下。底层，并没有较多不同</a> - 异步函数基于生成器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyc function()&#123;</span><br><span class="line">	try &#123;</span><br><span class="line">			let [foo, bar] = await Promise.all([</span><br><span class="line">					httpGet(&#x27;foo.json&#x27;),</span><br><span class="line">					httpGet(&#x27;bar.json&#x27;)</span><br><span class="line">			]);</span><br><span class="line">			render(foo);</span><br><span class="line">			render(bar);</span><br><span class="line">	&#125; catch (e)&#123;</span><br><span class="line">			console.log(&#x27;Read failed: &#x27;+ e );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-调试-promises"><a href="#12-调试-promises" class="headerlink" title="12. 调试 promises"></a>12. 调试 promises</h2><p>主要的挑战是调试异步代码中包含异步函数和方法的调用。异步调用源自于一个任务执行了一个新的任务。如果该新任务中有异常，堆栈跟踪只会覆盖该任务，不会包含之前任务的信息。所以在异步编程中你只能获得很少的调试信息。</p>
<p>Google 的 chrome 最近开始可以调试异步代码。并不完全支持 promises，但是处理一般的异步编程做得非常不错。比如下面的实例，first 异步调用 返回调用 third 的 second。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function first()&#123;</span><br><span class="line">	setTimeout(function () &#123; second(&#x27;a&#x27;) &#125;, 0); //(A)</span><br><span class="line">&#125;</span><br><span class="line">function second()&#123;</span><br><span class="line">	setTimeout(function () &#123; third(&#x27;b&#x27;) &#125;, 0); //(B)</span><br><span class="line">&#125; </span><br><span class="line">function third()&#123;</span><br><span class="line">	debugger;</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br></pre></td></tr></table></figure>

<p>正如截图中所示，调试器展现一个包含三个函数的跟踪堆栈。它包含了 line A 和 line B 处的异步函数。</p>
<p><img src="http://image.freefe.cc/20170125162922.png"></p>
<h2 id="13-promises-内部窥秘"><a href="#13-promises-内部窥秘" class="headerlink" title="13. promises 内部窥秘"></a>13. promises 内部窥秘</h2><p>本段，我们将从不同的角度来看一下 promises：不再学习如何使用 promise API，我们将了解一下它的简单实现。这个视角将帮助我们实现一个 promises。</p>
<p>promises 的实现被称为 DemoPromise 和 在 GitHub 上可用的实例（<a target="_blank" rel="noopener" href="https://github.com/rauschma/demo_promise%EF%BC%89%E3%80%82%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%EF%BC%8C%E5%B0%86%E4%B8%8D%E4%BC%9A%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D">https://github.com/rauschma/demo_promise）。为了更容易理解，将不会完全匹配</a> API。但是它将足够使你了解在实现 promises 过程会中面对的各种难题。</p>
<p>DemoPromises 是一个含有三个原型方法的构造函数：</p>
<ul>
<li>DemoPromises.prototype.resolve(value)</li>
<li>DemoPromises.prototype.reject(reason)</li>
<li>DemoPromises.prototype.then(onFulfilled, onRejected)</li>
</ul>
<p>在此，resolve 和 reject 为方法（而不是传递给传递给构造函数作为参数的回调函数）。</p>
<h3 id="13-1-一个独立的-promise"><a href="#13-1-一个独立的-promise" class="headerlink" title="13.1 一个独立的 promise"></a>13.1 一个独立的 promise</h3><p>首先我们需要实现一个最少功能的独立的 promise ：</p>
<ul>
<li>你可以创建一个 promise。</li>
<li>你可以通过或者拒绝一个 promise 并且只能处理它一次。</li>
<li>你可以通过 then() 来注册 reactions（回调函数）。该方法不支持链式（该处应该是支持链式），就是说，其不返回任何东西。它需要被立即执行不管该 promise 是否已经被处理。</li>
</ul>
<p>以下是使用第一步所实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dp = new DemoPromise();</span><br><span class="line">dp.resolve(&#x27;abc&#x27;);</span><br><span class="line">dp.then(function(value)&#123;</span><br><span class="line">	console.log(value); // abc</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面图标说明了我们第一个 DemoPromise 是如何实现的：</p>
<p><img src="http://image.freefe.cc/20170125162939.png"></p>
<p>让我们首先研究下 then()。它必须处理两个情况：</p>
<ul>
<li>如果 promise 还在执行中，那么将在 promise 被处理完毕之后调用 onFulfilled 或者 onRejected 的时候使用。</li>
<li>如果 promise 已经被通过或者拒绝，onFulfilled 或者 onRejected 将被立即调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DemoPromise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	var fulfilledTask = function () &#123;</span><br><span class="line">			onFulfilled(self.promiseResult);</span><br><span class="line">	&#125;;</span><br><span class="line">	var rejectedTask = function () &#123;</span><br><span class="line">			onRejected(self.promiseResult);</span><br><span class="line">	&#125;;</span><br><span class="line">	switch (this.promiseState) &#123;</span><br><span class="line">			case &#x27;pending&#x27;:</span><br><span class="line">					this.fulfillReactions.push(fulfilledTask);</span><br><span class="line">					this.rejectReactions.push(rejectedTask);</span><br><span class="line">					break;</span><br><span class="line">			case &#x27;fulfilled&#x27;:</span><br><span class="line">					addToTaskQueue(fulfilledTask);</span><br><span class="line">					break;</span><br><span class="line">			case &#x27;rejected&#x27;:</span><br><span class="line">					addToTaskQueue(rejectedTask);</span><br><span class="line">					break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">function addToTaskQueue(task) &#123;</span><br><span class="line">	setTimeout(task, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>resolve() 工作原理如下：</strong>如果 promise 已经被处理完毕，将不做任何事情（确保一个 promise 只被处理一次）。否则，promise 的状态转变为 fulfilled 并且结果缓存到 this.promiseResult。所有入队到通过状态 reactions 的将被立即执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.resolve = function (value) &#123;</span><br><span class="line">	// 为执行回调函数方法 如果不为状态 pending 为在 then 时刻已经处理执行过，立即跳出</span><br><span class="line">	if (this.promiseState !== &#x27;pending&#x27;) return;</span><br><span class="line">	this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">	this.promiseResult = value;</span><br><span class="line">	this._clearAndEnqueueReactions(this.fulfillReactions);</span><br><span class="line">	return this; // 链式</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype._clearAndEnqueueReactions = function (reactions) &#123;</span><br><span class="line">	this.fulfillReactions = undefined;</span><br><span class="line">	this.rejectReactions = undefined;</span><br><span class="line">	reactions.map(addToTaskQueue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>reject() 与 resolve() 类似。</p>
<h3 id="13-2-链式（注意，这部分已经为下一步扁平化做好了基础）"><a href="#13-2-链式（注意，这部分已经为下一步扁平化做好了基础）" class="headerlink" title="13.2 链式（注意，这部分已经为下一步扁平化做好了基础）"></a>13.2 链式（注意，这部分已经为下一步扁平化做好了基础）</h3><p>接下来，我们将实现链式：</p>
<ul>
<li>then() 返回的 promise 实际上是 onFulfilled 或者 onRejected 被执行后所返回的。</li>
<li>如果 onFulfilled 或者 onRejectecd 缺失，那么不管它们所传递的是什么， promise 通过 then() 返回出来。</li>
</ul>
<p><img src="http://image.freefe.cc/20170125162959.png"></p>
<p>显然，只需要调整下 then()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DemoPromise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">	var returnValue = new DemoPromise(); // (A)</span><br><span class="line">	var self = this;</span><br><span class="line"></span><br><span class="line">	var fulfilledTask;</span><br><span class="line">	if (typeof onFulfilled === &#x27;function&#x27;) &#123;</span><br><span class="line">			fulfilledTask = function () &#123;</span><br><span class="line">					var r = onFulfilled(self.promiseResult);</span><br><span class="line">					returnValue.resolve(r); // (B)</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">			fulfilledTask = function () &#123;</span><br><span class="line">					returnValue.resolve(self.promiseResult); // (C)</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var rejectedTask;</span><br><span class="line">	if (typeof onRejected === &#x27;function&#x27;) &#123;</span><br><span class="line">			rejectedTask = function () &#123;</span><br><span class="line">					var r = onRejected(self.promiseResult);</span><br><span class="line">					returnValue.resolve(r); // (D)</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">			rejectedTask = function () &#123;</span><br><span class="line">					// Important: we must reject here!</span><br><span class="line">					// Normally, result of `onRejected` is used to resolve</span><br><span class="line">					returnValue.reject(self.promiseResult); // (E)</span><br><span class="line">			&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return returnValue; // (F)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>then() 创建并返回一个新的 promises（在 A 处和 F 处）。此外，fulfilledTask 和 rejectedTask 以不同方式设置：在处理结束时。</p>
<ul>
<li>onFulfilled 的结果被用在通过 returnValue（在 B 处）。如果 onFulfilled 为缺失的，我们使用通过的值来处理 returnValue（在 C 处）。</li>
<li>onRejected 的结果被用于通过（并非拒绝） returnValue（在 D 处）。如果，onRejected 缺失，我们使用拒绝的值来拒绝 returnValue（在 E 处）。</li>
</ul>
<h3 id="13-3-扁平化"><a href="#13-3-扁平化" class="headerlink" title="13.3 扁平化"></a>13.3 扁平化</h3><p>扁平化思想主要是使链式方式更为便捷：一般，将一个 reaction 返回的值传递到下一个 then()。如果我们返回一个 promise，不包裹的形式是最好的，像下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1()</span><br><span class="line">.then(function (value1)&#123;</span><br><span class="line">	return asyncFunc2(); // A</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (value2)&#123;</span><br><span class="line">	// value2 为 asyncFunc2() promise 的通过状态。</span><br><span class="line">	console.log(value2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在 A 处返回一个promise，就没有必要在当前方法中嵌套 then() 的调用，我们可以对方法的结果进行 then() 的调用。那么，不嵌套 then()，就保持扁平化。</p>
<p>我们通过使 resolve() 方法扁平化来实现整体扁平化：</p>
<ul>
<li>以一个 promise Q 通过一个 promise P 意味着 Q 的处理结果要在 P 的 reactions 之前。</li>
<li>在 Q 中，P 应该被锁定：它不能被通过（或者拒绝）。并且它的状态和结果和 Q 的保持同步。</li>
</ul>
<p>如果我们使用 then式 （而非一个 promise）能以更通用的形式实现扁平化。</p>
<p><img src="http://image.freefe.cc/20170125163015.png"></p>
<p>实现 锁住，我们需要使用一个布尔值标签 this.already 。一旦值为 true，this 将被锁住，不能在被通过，记录如果 this 仍在进行中，因为它的状态是和锁住的 promise 是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DemoPromise.prototype.resolve = function (value) &#123;</span><br><span class="line">	if (this.alreadyResolved) return;</span><br><span class="line">	this.alreadyResolved = true;</span><br><span class="line">	this._doResolve(value);</span><br><span class="line">	return this; // enable chaining</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>真实的解决代码在私有方法 _doResolve() 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DemoPromise.prototype._doResolve = function (value) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	// Is `value` a thenable?</span><br><span class="line">	if (value !== null &amp;&amp; typeof value === &#x27;object&#x27;</span><br><span class="line">			&amp;&amp; &#x27;then&#x27; in value) &#123;</span><br><span class="line">			addToTaskQueue(function () &#123; // (A)</span><br><span class="line">					value.then(</span><br><span class="line">							function onFulfilled(value) &#123;</span><br><span class="line">									self._doResolve(value);</span><br><span class="line">							&#125;,</span><br><span class="line">							function onRejected(reason) &#123;</span><br><span class="line">									self._doReject(reason);</span><br><span class="line">							&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">			this.promiseState = &#x27;fulfilled&#x27;;</span><br><span class="line">			this.promiseResult = value;</span><br><span class="line">			this._clearAndEnqueueReactions(this.fulfillReactions);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>扁平化处理在 A 处进行：如果 value 为通过状态，那么当前 self 为通过状态，如果 value 为拒绝的，我们就希望 self 为拒绝状态。前面所述通过私有方法 _doResolve 和 _doReject 来实现，通过 alreadyResolved 来绕开阻挡。</p>
<h3 id="13-4-更详细的-Promise-状态"><a href="#13-4-更详细的-Promise-状态" class="headerlink" title="13.4. 更详细的 Promise 状态"></a>13.4. 更详细的 Promise 状态</h3><p>由于链式形式，promises 的状态变得更为复杂。</p>
<p><img src="http://image.freefe.cc/20170125163029.png"></p>
<p>如果你只是使用 promises，你只需要以简单的视角来看待，忽略锁定就好。最主要的状态相关概念是“settledness”： 一个 promise 在被通过或者拒绝的时候被设置完毕。在一个 promise 被设置之后，将不再变化（状态为通过状态或者拒绝状态）。</p>
<p>如果你希望先处理 promsie，然后再将其通过，这便会很难理解：</p>
<ul>
<li>直观的说，‘resolved’（已处理）意味着不能再次被（直接）的处理。一个 promise 在只在即未被设置过也不在锁定的状态下被解决。引用下规范：一个未被处理的 promise 一般处在 pending 状态。一个已经处理的 promise 可能为 等待，通过或者拒绝状态。</li>
<li>处理中不一定会使其被设置：你可以通过一个 promise 以另一个状态为 pending的。</li>
<li>处理中现在包含拒绝：你可以拒绝一个 promise 通过一个拒绝的 promise 处理。</li>
</ul>
<h3 id="13-5-异常"><a href="#13-5-异常" class="headerlink" title="13.5. 异常"></a>13.5. 异常</h3><p>在我们不久的将来，我们将会在 user code 中以 rejections 形式处理异常。目前来说，user code 只代表 then 中的两个回调函数参数。</p>
<p><img src="http://image.freefe.cc/20170125163044.png"></p>
<p>下面代码片段展现了我们在 onFulfilled 内部处理异常转到 拒绝状态 - 通过 A 处调用时的 try-catch 包裹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fulfilledTask;</span><br><span class="line">if (typeof onFulfilled === &#x27;function&#x27;) &#123;</span><br><span class="line">	fulfilledTask = function () &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">					var r = onFulfilled(self.promiseResult); // (A)</span><br><span class="line">					returnValue.resolve(r);</span><br><span class="line">			&#125; catch (e) &#123;</span><br><span class="line">					returnValue.reject(e);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fulfilledTask = function () &#123;</span><br><span class="line">			returnValue.resolve(self.promiseResult);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-6-揭示构造函数模式"><a href="#13-6-揭示构造函数模式" class="headerlink" title="13.6. 揭示构造函数模式"></a>13.6. 揭示构造函数模式</h3><p>如果我们希望将 DemoPromise 转变为切实可用的 promise，我们还需要实现揭示构造函数模式：ES6 promises 不是通过方法来进行通过或者拒绝，而是通过监听在 executor 上的函数实现的，构造函数的参数。</p>
<p><img src="http://image.freefe.cc/20170125163059.png"></p>
<p>如果执行函数抛出一个异常，该 promise 一定被拒绝。</p>
<h2 id="14-两个常用的-promise-附加方法"><a href="#14-两个常用的-promise-附加方法" class="headerlink" title="14. 两个常用的 promise 附加方法"></a>14. 两个常用的 promise 附加方法</h2><p>本段介绍一下两个在 ES6 中添加到 promsie 的方法。promise 库的大部分都支持他们。</p>
<h3 id="14-1-done"><a href="#14-1-done" class="headerlink" title="14.1. done()"></a>14.1. done()</h3><p>当你将数个 promise 方法链式调用时，你可能会无心之中忽略错误。看实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">	asyncFunc()</span><br><span class="line">	.then(f1)</span><br><span class="line">	.catch(r1)</span><br><span class="line">	.then(f2); // A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在 A 处的 then() 生成拒绝状态，那么将不会被处理。 promise 库 Q 提供了一个方法 done()，放置在链式最后一个方法调用的后面。其或者替换最后一个 then()（也有一个到两个参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">	asyncFunc()</span><br><span class="line">	.then(f1)</span><br><span class="line">	.catch(r1)</span><br><span class="line">	.done(f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又或者仅仅是插到最后一个 then() 之后（无参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function doSomeThing()&#123;</span><br><span class="line">	asyncFunc()</span><br><span class="line">	.then(f1)</span><br><span class="line">	.catch(r1)</span><br><span class="line">	.then(f2)</span><br><span class="line">	.done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用 Q 的文档：</p>
<blockquote>
<p>done 与 then 使用的黄金规则：既不返回任何一个 promise，或者结束链式调用，那么使用 done 来终止。使用 catch 来终止不是很好，因为 catch 的可能是其自己内部的错误。</p>
</blockquote>
<p>这也是在 ES6 中实现  done 的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.done = function(onFulfilled, onRejected)&#123;</span><br><span class="line">	this.then(onFulfilled, onRejected)</span><br><span class="line">	.catch(function(reason)&#123;</span><br><span class="line">			setTimeout( ()=&gt;&#123; throw reason &#125;, 0 );</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然 done 功能极为有用，但是没有添加到 ES6 中，因为在将来这种检测可以被调试器自动调起（一个 ES 讨论版本中）。</p>
<h3 id="14-2-finally"><a href="#14-2-finally" class="headerlink" title="14.2. finally()"></a>14.2. finally()</h3><p>有时你希望某个行为不管有没有错误抛出都立即执行。例如在一系列行为后的处理。这便是 promise 方法 finally() 所做的，极为类似与错误处理机制中的 finally 。其回调方法不接受参数，但是会有 通过状态或者拒绝状态的通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createPeaource(...)</span><br><span class="line">.then(function(value1)&#123; ... &#125;)</span><br><span class="line">.then(function(value2)&#123; ... &#125;)</span><br><span class="line">.finally(function()&#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>这是 Domenic Denicola 计划实现的 finally()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">	let p = this.constructor;</span><br><span class="line">	// 不在此调用回调函数,</span><br><span class="line">	// 希望使用 then 来处理</span><br><span class="line">	return this.then(</span><br><span class="line">			// Callback fulfills: 传递参数结果</span><br><span class="line">			// Callback rejects: 传递拒绝状态</span><br><span class="line">			value =&gt; p.resolve(callback()).then(() =&gt; value),</span><br><span class="line">			reason =&gt; p.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">	);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回调函数决定了 接收器（this）如何设置处理：</p>
<ul>
<li>如果回调函数抛出一个错误或者返回一个拒绝状态的 promise，那么变为 拒绝状态的值。</li>
<li>否则，接收器的设置变为的 finally 返回的 promise 的设置。使用 finally() 的链式方法。</li>
</ul>
<p><strong>例一：使用 finally() 来隐藏 spinner：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">showSpinner();</span><br><span class="line">fetchGalleryData()</span><br><span class="line">.then(data =&gt; updateGallery(data) )</span><br><span class="line">.catch(showNoDataError)</span><br><span class="line">.finnally(hideSpinner);</span><br></pre></td></tr></table></figure>

<p><strong>例二：使用 finally 来清除测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var HTTP = require(&#x27;q-io/http&#x27;);</span><br><span class="line">var server = HTTP.Server(app);</span><br><span class="line">return server.listen(0)</span><br><span class="line">.then(function()&#123; ... &#125;)</span><br><span class="line">finally(server.stop);</span><br></pre></td></tr></table></figure>

<h2 id="15-ES6-兼容的-promise-库"><a href="#15-ES6-兼容的-promise-库" class="headerlink" title="15. ES6 兼容的 promise 库"></a>15. ES6 兼容的 promise 库</h2><p>下面有一些 promise 的库，有一些 ES6 的API，意味着你在将来也可以用原生 ES6 代码替换。</p>
<ul>
<li>RSVP.js 来自 Stefen Penner，为 ES6 promise API 的超集。</li>
<li>Native Promise Only 来自 Kyle Simpson 是原生 ES6 promise 的 polyfill，以严格模式来定义，尽可能接近而不扩展。</li>
<li>Lie 来自 Calvin Metcalf 小巧，完善的 promise 库，遵循 Promises&#x2F;A+ 规范。</li>
<li>Q.promise 来自 Kowal 实现 ES6 API。</li>
<li>最近的，来自 Paul Millr 包含 promise 的 ES6 Shim。</li>
</ul>
<h2 id="16-传统的异步代码的接口"><a href="#16-传统的异步代码的接口" class="headerlink" title="16. 传统的异步代码的接口"></a>16. 传统的异步代码的接口</h2><p>放你使用一个 promsie 库时，有时是基于不支持 promsie 的异步代码。这段讲述一下 Node.js 风格的异步函数与 jQuery deferreds。</p>
<h3 id="16-1-Node-js-的接口"><a href="#16-1-Node-js-的接口" class="headerlink" title="16.1 Node.js 的接口"></a>16.1 Node.js 的接口</h3><p>promise 库 Q 有几个工具方法来转换函数使其使用 Node.js 风格(err, result)的回调函数然后返回一个promise（还有一些做一些相反的事情，转换基于 promise 的函数来为一些接受回调函数的函数）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var readFile = Q.denideify( FS.readFile );</span><br><span class="line">readFile(&#x27;foo,txt&#x27;, &#x27;utf-8&#x27;)</span><br><span class="line">.then(function(text)&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>denodify 为一个符合 ES6 promise API ，提供 nodification 函数式化功能。</p>
<h3 id="16-2-jQuery-的接口"><a href="#16-2-jQuery-的接口" class="headerlink" title="16.2. jQuery 的接口"></a>16.2. jQuery 的接口</h3><p>jQuery 的 deferred 类似于 promise，但是也有几个兼容性方面的不同。方法 then() 都类似与 ES6 promises（主要不同之处是：不会在 reactions 中监控错误抛出）。我们可以通过 Promise.resolve() 将 一个 jQuery deferred 为 ES6 的 promise：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(</span><br><span class="line">	jQuery.ajax(&#123;...&#125;)</span><br><span class="line">).then(funciton(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">	console.error(reason)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="17-延伸阅读"><a href="#17-延伸阅读" class="headerlink" title="17. 延伸阅读"></a>17. 延伸阅读</h2><ol>
<li>Promises&#x2F;A+（<a target="_blank" rel="noopener" href="http://promisesaplus.com/%EF%BC%89%EF%BC%9ABrian">http://promisesaplus.com/）：Brian</a> Cavalier 与 Domenic Denicola 编辑（JS promise 事实标准）</li>
<li>Javascript Promises：再次强势归来（<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/%EF%BC%89%EF%BC%9A%E6%9D%A5%E8%87%AA">http://www.html5rocks.com/en/tutorials/es6/promises/）：来自</a> Jake Archibad（挺不错的 promise 简要介绍）</li>
<li>Promsie 反模式（<a target="_blank" rel="noopener" href="http://taoofcode.net/promise-anti-patterns/%EF%BC%89%EF%BC%9A%E6%9D%A5%E8%87%AA">http://taoofcode.net/promise-anti-patterns/）：来自</a> Tao（要点与技术）</li>
<li>Promise 模式（<a target="_blank" rel="noopener" href="https://www.promisejs.org/patterns/%EF%BC%89%E6%9D%A5%E8%87%AA">https://www.promisejs.org/patterns/）来自</a> Forbes Lindeasy</li>
<li>揭示构造函数模式（<a target="_blank" rel="noopener" href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/%EF%BC%89%EF%BC%9A%E6%9D%A5%E8%87%AA">http://domenic.me/2014/02/13/the-revealing-constructor-pattern/）：来自</a> Domenic Denicola（为 Promise 构造函数使用的模式）</li>
<li>Chrome 开发者工具调试异步 JS 代码（<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/developertools/async-call-stack/%EF%BC%89%EF%BC%9A%E6%9D%A5%E8%87%AA">http://www.html5rocks.com/en/tutorials/developertools/async-call-stack/）：来自</a> Pearl Chen</li>
<li>ES6 中的迭代器和生成器（<a target="_blank" rel="noopener" href="http://www.2ality.com/2013/06/iterators-generators.html%EF%BC%89">http://www.2ality.com/2013/06/iterators-generators.html）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/03/16/ecmascript-6-promises-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/03/16/ecmascript-6-promises-2/" class="post-title-link" itemprop="url">ECMAScript 6 promises（下）：谈谈 API（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2015-03-17T00:00:00+08:00">2015-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/03/16/ecmascript-6-promises-2/" class="post-meta-item leancloud_visitors" data-flag-title="ECMAScript 6 promises（下）：谈谈 API（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址： <a target="_blank" rel="noopener" href="http://www.2ality.com/2014/10/es6-promises-api.html">http://www.2ality.com/2014/10/es6-promises-api.html</a><br>原文作者：Dr. Axel Rauschmayer</p>
<p>译者：倪颖峰</p>
<p>（文章第二部分实在是太长，所以在此分成两部分翻译）<br>本文是通过普通的 promises 和 ES6的 promise API 来介绍异步编程。这是两篇系列文章的第二部分 - 第一部分介绍了一下异步编程的基础（你需要充分理解一下以便明白这篇文章）。</p>
<p>鉴于 ES6 的 promise API 比较容易从 ES5 标准模拟生成过来，所以这边主要使用函数表达式，而不使用更为简洁的 ES6 中的箭头函数。</p>
<h2 id="1-Promises"><a href="#1-Promises" class="headerlink" title="1. Promises"></a>1. Promises</h2><p>Promises 是一种来解决特定异步编程的模式：函数（或者方法）异步返回其结果。实现一个对返回结果的具有占位符意义的对象 promise。函数的调用者注册回调函数，一旦结果运算完毕就立即通知 promise。函数会由 promise 来传递结果。</p>
<p>JavaScript 的 promises 事实标准称为 Promises&#x2F;A+。ES6 的 promise API 便遵循这个标准。</p>
<h2 id="2-第一个实例"><a href="#2-第一个实例" class="headerlink" title="2. 第一个实例"></a>2. 第一个实例</h2><p>看一下第一个实例，来了解下 promises 是如何运行的。</p>
<p>NodeJS 风格的回调函数，异步读取文件如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&#x27;config.json&#x27;, function (error, text) &#123;</span><br><span class="line">	if (error) &#123;</span><br><span class="line">			console.error(&#x27;Error while reading config file&#x27;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">					var obj = JSON.parse(text);</span><br><span class="line">					console.log(JSON.stringify(obj, null, 4));</span><br><span class="line">			&#125; catch (e) &#123;</span><br><span class="line">					console.error(&#x27;Invalid JSON in file&#x27;);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 promises，相同功能的实现可以是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">readFilePromisified(&#x27;config.json&#x27;)</span><br><span class="line">.then(function (text) &#123; // (A)</span><br><span class="line">	var obj = JSON.parse(text);</span><br><span class="line">	console.log(JSON.stringify(obj, null, 4));</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (reason) &#123; // (B)</span><br><span class="line">	// File read error or JSON SyntaxError</span><br><span class="line">	console.error(&#x27;An error occurred&#x27;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这边依旧是有回调函数，但是这里通过方法来提供的，避免了放在结果中（then() 和 catch()）。在 B 处的报错的回调函数有两方面的优势：第一，这是一种单一风格的监听错误。 第二，你可以同时处理  readFilePromisified() 的 和 A 处回调函数的错误。</p>
<h2 id="3-promises-的创建和使用"><a href="#3-promises-的创建和使用" class="headerlink" title="3. promises 的创建和使用"></a>3. promises 的创建和使用</h2><p>从生成形式和消耗形式两方面来看一下 promises 是如何操作的。</p>
<h3 id="3-1-生成一个-promise"><a href="#3-1-生成一个-promise" class="headerlink" title="3.1. 生成一个 promise"></a>3.1. 生成一个 promise</h3><p>作为一个生成形式，你创建一个 promise 然后由它传递结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise( function( resolve, reject )&#123;</span><br><span class="line">	...</span><br><span class="line">	if( ... )&#123;</span><br><span class="line">			resolve( value );</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">			reject( reason );</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>一个 promise 一般具有一个到三个（互斥）的状态：</p>
<blockquote>
<p>Pending：还没有得到结果，进行中<br>Fulfilled：成功得到结果，通过<br>Rejected：在计算过程中发生一个错误，拒绝</p>
</blockquote>
<p>一个 promise 被设置过后（ 代表运算已经完成 ）那么它要么是 fulfilled 要么是 rejected。每一个 promise 只能被处理一次，然后保持处理后的状态。之后在处理它将不会触发任何效果。</p>
<p><img src="http://image.freefe.cc/20170125155753.png"></p>
<p>new Promise() 的参数（ 在 A 处开始的 ）称为 executor（执行者）:</p>
<ol>
<li>如果运算成功，执行器会将结果传递给 resolve()。那属于 promise 通过（后面将会解释，如果你处理一个 promise 可能会不同）。</li>
<li>如果错误发生了，执行器就会通过 reject() 通知 promise 消耗形式。就会解决该 promise。</li>
</ol>
<h3 id="3-2-消耗一个promise"><a href="#3-2-消耗一个promise" class="headerlink" title="3.2. 消耗一个promise"></a>3.2. 消耗一个promise</h3><p>作为 promise 的消耗形式，你会将一个完成态或者通过态通知给 reactions - 通过 then 方法注册的回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then( function( value )&#123;</span><br><span class="line">	/* fulfillment */</span><br><span class="line">&#125;, function( reason )&#123;</span><br><span class="line">	/* rejection */</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>正是由于一个 promise 仅能被处理一次，之后再也不能变化使得 promises 对于异步函数来说异常有用（一次性使用结果）。此外，还没有任何其他的条件，因为在 promise 被处理时间点的前后调用 then() 是一样的：</p>
<ol>
<li>前者的情况，合适的反馈调用会在 promise 被处理时立即调用。</li>
<li>后者情况，promise 的结果（通过的值或者拒绝的值）会被缓存起来，在合适的请跨过下立即处理反馈（排列一个任务）</li>
</ol>
<h3 id="3-3-只处理通过态或者拒绝态"><a href="#3-3-只处理通过态或者拒绝态" class="headerlink" title="3.3. 只处理通过态或者拒绝态"></a>3.3. 只处理通过态或者拒绝态</h3><p>如果你只关心通过状态，你可以忽略 then() 的第二个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function( value )&#123;</span><br><span class="line">	/* fulfillment */</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你只需要通过状态，你可以忽略第一个参数。用 catch() 方法也可以更紧凑的来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.then( null, function( reason )&#123;</span><br><span class="line">		 /* rejection */</span><br><span class="line">&#125; );</span><br><span class="line">// 等价于</span><br><span class="line">promise.catch( function( reason )&#123; </span><br><span class="line">	/* rejection */</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>这里推荐只是用 then() 处理成功状态，使用 catch() 处理错误，因为这样可以更加优雅的标记回调函数并且你可以同时对多个 promises 进行通过态处理（稍后解释）。</p>
<h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h2><p>让我们在一些例子中使用一下基本构成形式。</p>
<h3 id="4-1-例：promise-化-XMLHttpRequest"><a href="#4-1-例：promise-化-XMLHttpRequest" class="headerlink" title="4.1. 例：promise 化 XMLHttpRequest"></a>4.1. 例：promise 化 XMLHttpRequest</h3><p>下面是一个基于 XMLHttpRequest API 事件，通过 promise 编写的 HTTP GET函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function httpGet( url )&#123;</span><br><span class="line">	return new Promise( function( resolve, reject )&#123;</span><br><span class="line">			var request = new XMLHttpRequest();</span><br><span class="line">			request.onreadystatechange = function()&#123;</span><br><span class="line">					if( this.status === 200 )&#123;</span><br><span class="line">							// success</span><br><span class="line">							resolve( this.response );</span><br><span class="line">					&#125;else &#123; </span><br><span class="line">							reject( new Error( this.statusText ) );</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			request.onerror = function()&#123;</span><br><span class="line">					reject( new Error( &#x27;XMLHttpRequest Error: &#x27; + this.statusText ) );</span><br><span class="line">			&#125;</span><br><span class="line">			request.open( &#x27;GET&#x27;, url );</span><br><span class="line">			request.send();</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是如何使用 httpGet()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">httpGet(&quot;http://example.com/file.txt&quot;)</span><br><span class="line">	.then(function()&#123;</span><br><span class="line">			console.log(&#x27;contents: &#x27;+ value);</span><br><span class="line">	&#125;, function( reason )&#123;</span><br><span class="line">			console.log(&#x27;something error&#x27;, reason);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-例子：延迟执行"><a href="#4-2-例子：延迟执行" class="headerlink" title="4.2. 例子：延迟执行"></a>4.2. 例子：延迟执行</h3><p>使用 setTimeout() 来实现基于 promise 的 delay()（类似于Q.delay()）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function delay( ms )&#123;</span><br><span class="line">	return new Promise(function( resolve, reject )&#123;</span><br><span class="line">			sertTimeout( resolve, ms ); // (A)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 使用 delay()</span><br><span class="line">delay( 5000 ).then(function()&#123; // (B)</span><br><span class="line">	console.log(&#x27;5s have passed&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意 A 处我们调用 resolve 没有传递参数，相当于我们这么调用 resolve( undefined )。在 B 处我们不需要通过的返回值，就可以简单的忽略它。仅仅通知就已经OK了。</p>
<h3 id="4-3-暂停-promise"><a href="#4-3-暂停-promise" class="headerlink" title="4.3. 暂停 promise"></a>4.3. 暂停 promise</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function timeout( ms, promise )&#123;</span><br><span class="line">	return new Promise(function( resolve, reject )&#123;</span><br><span class="line">			promise.then( resolve );</span><br><span class="line">			setTimeout(function()&#123;</span><br><span class="line">					reject(new Error(&#x27;Timeout after &#x27; + ms + &#x27; ms&#x27;)); // (A)</span><br><span class="line">			&#125;, ms)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 A 处的超时失败并不会阻止这个请求，但是可以确保 promise 的成功状态结果。</p>
<p>如下方式使用 timeout()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timeout( 5000, httpGet(&quot;http://example.com/file.txt&quot;) )</span><br><span class="line">	.then(function( value )&#123;</span><br><span class="line">			console.log(&#x27;contents: &#x27; + value);</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(function( reason )&#123;</span><br><span class="line">			console.log(&#x27;error or timeout: &#x27; , reason);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-链式调用-then"><a href="#5-链式调用-then" class="headerlink" title="5. 链式调用 then()"></a>5. 链式调用 then()</h2><p>方法调用结果 P.then( onFulfilled, onRejected ) 是一个新的 promise Q。这意味着在 Q 中，你可以通过调用 then() 来保持对基于 promise 流的控制：</p>
<ol>
<li>Q 在 onFulfilled 或者 onRejected 返回结果的时候，即为通过。</li>
<li>Q 在 onFulfilled 或者 onRejected 抛出错误的时候，即为拒绝。</li>
</ol>
<h3 id="5-1-一般值来通过"><a href="#5-1-一般值来通过" class="headerlink" title="5.1.  一般值来通过"></a>5.1.  一般值来通过</h3><p>如果你通过使用 then() 返回一个一般值来处理一个 Q，那你就可以通过下一个 then 来取到这个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc().then( function()&#123;</span><br><span class="line">	return 123;</span><br><span class="line">&#125; ).then( function( value )&#123;</span><br><span class="line">	console.log( value ); // 123</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

<h3 id="5-2-通过-then式-来通过"><a href="#5-2-通过-then式-来通过" class="headerlink" title="5.2. 通过 then式 来通过"></a>5.2. 通过 then式 来通过</h3><p>你也可以通过 then() 来返回一个 then式的 R对象 来将 promise Q 通过。then式表示有 promise 风格方法 then() 的任何对象。即， promises 便是 then式的。处理 R （例如将其以 onFulfilled 来返回）意味着他是被插入到 Q 之后的：R的结果将被作为 Q onFulfilled 或者 onRejected 的回调函数。也就是说 Q 转变为 R。</p>
<p><img src="http://image.freefe.cc/20170125155818.png"></p>
<p>这个形式主要是用来扁平化嵌套式调用 then()，比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1()</span><br><span class="line">.then(function(value1)&#123;</span><br><span class="line">	asyncFunc2()</span><br><span class="line">	.then(function(value2)&#123;</span><br><span class="line">			...</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么扁平化形式可以变为这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1()</span><br><span class="line">.then(function(value1)&#123;</span><br><span class="line">	return asyncFunc2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value2)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-错误处理"><a href="#6-错误处理" class="headerlink" title="6. 错误处理"></a>6. 错误处理</h2><p>如之前提到的，不管你在错误中返回什么都讲成为一个 fulfillment 的值（或者 rejection 值）。这使得你可以定义失败执行的默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">retrieveFileName()</span><br><span class="line">.catch(function()&#123;</span><br><span class="line">	return &#x27;Untitled.txt&#x27;;</span><br><span class="line">&#125;).then(function(fileName)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-1-捕获异常"><a href="#6-1-捕获异常" class="headerlink" title="6.1. 捕获异常"></a>6.1. 捕获异常</h3><p>执行过程中的异常将会传递到下一个错误处理中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">	throw new Error();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(err)&#123;</span><br><span class="line">	// Handle error here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>作为异常，会将其作为then的一个参数抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc()</span><br><span class="line">.then(funcrion(value)&#123;</span><br><span class="line">	throw new Error();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">	// Handle error here</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>

<h3 id="6-2-链式的错误处理"><a href="#6-2-链式的错误处理" class="headerlink" title="6.2. 链式的错误处理"></a>6.2. 链式的错误处理</h3><p>将会有一个或者多个的 then() 调用但并没有提供一个错误处理。那么直到出现错误处理该错误才会被传递出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1()</span><br><span class="line">.then(asyncFunc2)</span><br><span class="line">.then(asyncFunc3)</span><br><span class="line">.catch(function(reason&#123;</span><br><span class="line">	// something went wrong above</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h2><p>本段会描述你如何将先现有的 promises 来组合创建新的 promise。我们已经使用过一种组合 promise 的方式了：通过 then() 连续的链式调用。Promise.all() 和 Promise.race() 提供了另一些组合的形式。</p>
<h3 id="7-1-通过-Promise-all-实现-map"><a href="#7-1-通过-Promise-all-实现-map" class="headerlink" title="7.1. 通过 Promise.all() 实现 map()"></a>7.1. 通过 Promise.all() 实现 map()</h3><p>庆幸的是，基于 promise 返回结果，很多同步的工具仍然可以使用。比如你可以使用数组的方法 map()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fileUrls = [</span><br><span class="line">	&#x27;http://example.com/file1.txt&#x27;,</span><br><span class="line">	&#x27;http://example.com/file2.txt&#x27;</span><br><span class="line">];</span><br><span class="line">var promisedTexts = fileUrls.map(httpGet);</span><br></pre></td></tr></table></figure>

<p>promisedTexts 为一个 promises 对象的数组。Promise.all() 可以处理一个 promises 对象的数组（then式 和 其他值可以通过 Promise.resolve() 来转换为 promises）一旦所有的项状态都为 fulfilled，就会处理一个他们值得数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all(promisedTexts)</span><br><span class="line">.then(function(texts)&#123;</span><br><span class="line">	texts.forEach(function(text)&#123;</span><br><span class="line">			console.log(text);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">	// 接受 promises 中第一个 rejection 状态</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-2-通过-Promise-race-实现延时"><a href="#7-2-通过-Promise-race-实现延时" class="headerlink" title="7.2. 通过 Promise.race() 实现延时"></a>7.2. 通过 Promise.race() 实现延时</h3><p>Promise.race() 使一个 promises 对象数组（then式 和 其他值可以通过 Promise.resolve() 来转换为 promises）返回一个 promise 对象 P。输入第一个的 promises 会将其结果通过参数传递给输出的 promise。</p>
<p>举个例子，来使用 Promise.race() 来实现一个 timeout：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([</span><br><span class="line">	httpGet(&#x27;http://example.com/file.txt&#x27;),</span><br><span class="line">	delay(5000).then(function()&#123;</span><br><span class="line">			throw new Error(&#x27;Time out&#x27;);</span><br><span class="line">	&#125;)</span><br><span class="line">])</span><br><span class="line">.then(function(text)&#123; ... &#125;)</span><br><span class="line">.catch(function(reason)&#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-Promises-基本都是异步的"><a href="#8-Promises-基本都是异步的" class="headerlink" title="8. Promises 基本都是异步的"></a>8. Promises 基本都是异步的</h2><p>一个 promise 库，不管结果是同步（正常方式）还是异步（当前延续的代码块完成之后）进行的传递都做好控制。然而，Promises&#x2F;A+ 规范约定后一种方式应总是可用的。它以以下的条件来将状态传给 then()：</p>
<blockquote>
<p>当执行上下文栈中只包含平台代码时才执行 onFulfilled 或者 onRejected。</p>
</blockquote>
<p>这意味着你可以依赖运行到完成的语态（第一部分中提到的），使得链式的 promises 不会使其他任务在闲置时处于等待状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/02/10/ecmascript-6-promises-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/02/10/ecmascript-6-promises-1/" class="post-title-link" itemprop="url">ECMAScript 6 promises（上）：基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-02-11 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-11T00:00:00+08:00">2015-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/02/10/ecmascript-6-promises-1/" class="post-meta-item leancloud_visitors" data-flag-title="ECMAScript 6 promises（上）：基本概念" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址： <a target="_blank" rel="noopener" href="http://www.2ality.com/2014/09/es6-promises-foundations.html">http://www.2ality.com/2014/09/es6-promises-foundations.html</a><br>原文作者：Dr. Axel Rauschmayer</p>
<p>译者：倪颖峰</p>
<p>本文主要介绍一下JS中异步编程的基础。这是一个主体两篇博文的第一部分，第二部分会涵盖在 ES6 中 promises 的API。</p>
<h2 id="1-JavaScript-中的调用堆栈"><a href="#1-JavaScript-中的调用堆栈" class="headerlink" title="1. JavaScript 中的调用堆栈"></a>1. JavaScript 中的调用堆栈</h2><p>当函数 f 调用一个函数 g，g 就需要知道它完成后在哪里返回（在 f 内部）。这里的主要方式是使用栈进行管理，即调用堆栈。来看一个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function h( z )&#123;</span><br><span class="line">	console.log( new Error.stack ); // (A)</span><br><span class="line">&#125;</span><br><span class="line">function g( y )&#123;</span><br><span class="line">	h( y+1 ); // (B)</span><br><span class="line">&#125;</span><br><span class="line">function f( x )&#123;</span><br><span class="line">	g( x+1 ); // (C)</span><br><span class="line">&#125;</span><br><span class="line">f( 3 ); // (D)</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<p>开始，当上面的程序运行时，调用堆栈为空。 当在 D 处函数调用 f( 3 )时，栈中有了一个项：</p>
<blockquote>
<p>当前的全局作用域</p>
</blockquote>
<p>当在 C 处调用函数 g( x+1 )时，栈中就有了两个项：</p>
<blockquote>
<p>当前的 f<br>当前的全局作用域</p>
</blockquote>
<p>在当 B 处调用函数 h( y+1 )时，栈中含有了三项：</p>
<blockquote>
<p>当前的 g<br>当前的 f<br>当前的全局作用域</p>
</blockquote>
<p>在 A 处的栈跟踪内会展示出下面的调用堆栈：</p>
<p>at <strong>Error</strong>    at <strong>h</strong>    at <strong>g</strong>    at <strong>f</strong> </p>
<p>接下来，每当一个函数执行结束，栈中就会相应的删除顶部的对应项。当函数 f 结束后，就会回到全局作用域，然后调用栈变为空。在 E 处，返回是栈为空，意味着程序的结束。</p>
<h2 id="2-浏览器的事件循环"><a href="#2-浏览器的事件循环" class="headerlink" title="2. 浏览器的事件循环"></a>2. 浏览器的事件循环</h2><p>简而言之，每一个浏览器页面tab都有独立的进程，事件循环。该循环会执行浏览器相关的由一个任务队列分发的事务（称为 任务）。任务实例有：</p>
<ol>
<li>解析 HTML</li>
<li>执行 script 标签中的 JS 代码</li>
<li>处理用户交互（点击鼠标，键盘输入等）</li>
<li>处理网络异步请求结果</li>
</ol>
<p>2 - 4任务均是通过浏览器内置引擎来执行JS代码。在代码结束时结束。然后队列中的下一项任务开始被执行。下面图片展示了所有的机制是如何连接起来的。<br>事件循环是掺杂在其他并行运行的各种进程中（定时器，输入处理器等）。这些进程同通过向其队列添加任务进行通信。</p>
<h3 id="2-1-定时器"><a href="#2-1-定时器" class="headerlink" title="2.1. 定时器"></a>2.1. 定时器</h3><p>浏览器具有定时器，setTimeout() 来创建定时器，等到触发时刻就会向其队列添加一个任务。如下标识：<br>setTimeout( callback, ms );</p>
<p>在ms毫秒之后， callback 回调函数就被添加到任务队列中。需要注意的是 ms 只是指定回调函数添加的事件，并不保证被执行。特别是如果事件循环被阻塞，那可能会在很久才执行（文章后面会提到）。</p>
<p>当 setTimeout() ms 设置为零是一个较为通用的方法来向队列立即添加任务。然而一些浏览器并不与许 ms 设置低于最小限度（FF 中为4ms）；如果小于最小限度，那也会将被设置成最小限度值。</p>
<h3 id="2-2-显示DOM的变化"><a href="#2-2-显示DOM的变化" class="headerlink" title="2.2. 显示DOM的变化"></a>2.2. 显示DOM的变化</h3><p>对于许多的DOM变化（特别是会引起重排的），也不会立即更新显示。“布局没16ms才会刷新一次”而且必须给予其通过事件循环执行的机会。</p>
<p>有一些办法来协调浏览器频繁的DOM更新，来避免布局结果的冲突。查询一下关于 requestAnimationFrame() 的详细文档吧。</p>
<h3 id="2-3-运行至完成-的语义"><a href="#2-3-运行至完成-的语义" class="headerlink" title="2.3. 运行至完成 的语义"></a>2.3. 运行至完成 的语义</h3><p>JS 所谓的运行至完成语义：当前任务总是在下一个任务执行前完成。这意味着每一个任务都可以完全控制所有的当前状态，并且不需要担心并发的修改。<br>看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( function()&#123;</span><br><span class="line">	console,log(&#x27;Second&#x27;); // (A)</span><br><span class="line">&#125;, 0 );</span><br><span class="line">console,log(&#x27;First&#x27;); // (B)</span><br></pre></td></tr></table></figure>

<p>在A处开始的函数是被立即添加到队列中的，但是只有在当前代码块完成之后（具体就是 B 处），才能执行。意味着代码输出永远是：</p>
<p><strong>First</strong>    <strong>Second</strong></p>
<p>2.4. 阻塞事件循环</p>
<p>我们可以发现，每个tab（在一些浏览器，完整的浏览器）被单独的进程控制-包括永辉二面和其它所有的运算。这意味着你在进程中执行长时间的运算将会使得用户界面被定格。延时代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function testBlocking()&#123;</span><br><span class="line">	console.log( &#x27;Blocking...&#x27; );</span><br><span class="line">	sleep( 5000 );</span><br><span class="line">	console.log( &#x27;Done&#x27; );</span><br><span class="line">&#125;</span><br><span class="line">function sleep( ms )&#123;</span><br><span class="line">	var start = Date.now();</span><br><span class="line">	while( (Date.now() - start) &lt; ms );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testBlocking();</span><br></pre></td></tr></table></figure>

<p>当函数执行时，同步的函数 sleep() 阻塞事件循环5秒钟，在这些时间里用户界面将被锁定。</p>
<h3 id="2-5-避免阻塞"><a href="#2-5-避免阻塞" class="headerlink" title="2.5. 避免阻塞"></a>2.5. 避免阻塞</h3><p>你可以使用两种方式来避免阻塞事件循环：</p>
<blockquote>
<p>首先，不要在主进程中执行长时间的计算，将其移到其他进程中。可以通过 Worker API 来实现。<br>其次。不应该（以同步方式）等待一个长时间运算的结果（ 在Worker进程中运行你的算法，或者以网络请求等 ），你可以继续执行事件循环，是运算在完成的时候通知你。事实上，在浏览器中你没有什么选择，而只能这么做。比如，并没有内置的 sleep 同步（例如之前使用的 sleep() 方法）。取而代之的是 setTimeout() 异步的sleep方法。</p>
</blockquote>
<p>下面部分将会讲解一下关于异步等待结果的技术。</p>
<h2 id="3-异步处理结果"><a href="#3-异步处理结果" class="headerlink" title="3. 异步处理结果"></a>3. 异步处理结果</h2><p>异步处理结果的两个常见部分：事件与回调函数。</p>
<h3 id="3-1-通过事件异步处理结果"><a href="#3-1-通过事件异步处理结果" class="headerlink" title="3.1 通过事件异步处理结果"></a>3.1 通过事件异步处理结果</h3><p>在这部分的异步处理结果内容中，你需要为每一个请求创建一个对象，对其注册事件绑定：一个为计算成功，一个为出错。下面代码展示对于 XMLHttpRequest API的工作原理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var req = new XMLHttpRequest();</span><br><span class="line">req.open(&#x27;GET&#x27;, url);</span><br><span class="line"></span><br><span class="line">req.onload = function()&#123;</span><br><span class="line">	if( req.status === 200 )&#123;</span><br><span class="line">			processData( req.response );</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">			console.log( &#x27;ERROR&#x27;, req.statusText );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">req.onerror = function()&#123;</span><br><span class="line">	console.log(&#x27;Network Error&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">req.send();// add request to task queue</span><br></pre></td></tr></table></figure>

<p>记住，事实上最后一行并不执行结果，它只是将其添加到任务队列。因此你也可以在 设置 onload和onerror之前，open() 之后正确的调用该方法。将会一样的执行，由于JS代码的 运行至完成的特性。</p>
<p>如果你使用多线程语言，indexedDB（索引型数据库）请求可能会引起相竞争的情况。因此，运行至完成的特性使得在JS变得安全可靠。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var openRequest = indexedDB.open( &#x27;test&#x27;, 1 );</span><br><span class="line">	openRequest.onsuccess = function( event )&#123;</span><br><span class="line">	console.log(&#x27;Success!&#x27;);</span><br><span class="line">	var db = event.target.result;</span><br><span class="line">&#125;</span><br><span class="line">openRequest.onerror = function( error )&#123;</span><br><span class="line">	cosole.log( error );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open() 不会立即打开数据库，它会在队列中添加一个任务，该任务会在当前所有任务执行完毕之后执行。这就是为何你可以（事实上也是必须可以）在调用 open() 之后注册事件句柄的原因。</p>
<h3 id="3-2-通过回调函数异步处理结果"><a href="#3-2-通过回调函数异步处理结果" class="headerlink" title="3.2. 通过回调函数异步处理结果"></a>3.2. 通过回调函数异步处理结果</h3><p>如果使用回调函数来异步处理结果，你需要将回调函数作为链接参数传递给异步函数或者方法进行调用。<br>下面为 Node.js 的实例。通过 fs.readFile() 异步读取文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Node.js</span><br><span class="line">fs.readFile( &#x27;myfile.txt&#x27;, &#123; encoding: &#x27;utf8&#x27; &#125;, function( error, text )&#123;</span><br><span class="line">	if( error, text )&#123; // (A)</span><br><span class="line">			// ...</span><br><span class="line">	&#125;</span><br><span class="line">	console.log( text );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>如果 readFile() 成功，在A处的回调函数就会通过参数 text 来传递结果值。如果失败，回调函数会通过第一个参数获取一个错误（一般来说是一个Error或者其子类）。</p>
<p>在经典的函数式编程风格中，代码可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">readFileFunctional( &#x27;myfile.txt&#x27;, &#123; encoding: &#x27;utf8&#x27; &#125;, function( text )&#123;</span><br><span class="line">			console.log( text ); // success</span><br><span class="line">	&#125;, function( error )&#123; // failure</span><br><span class="line">			// .....</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-连续传递风格"><a href="#3-3-连续传递风格" class="headerlink" title="3.3. 连续传递风格"></a>3.3. 连续传递风格</h3><p>使用回调函数的编程风格（特别是在功能式证明之前）又叫做连续传递式（CPS），因为下一步是需要传递一个参数的。这使得调用函数可以得到更多的对于接下来运行的和什么时候运行的控制。<br>下面代码显示了所谓的CPS：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;A&#x27;);</span><br><span class="line">identity(&#x27;B&#x27;, function step2(result2) &#123;</span><br><span class="line">	console.log(result2);</span><br><span class="line">	identity(&#x27;C&#x27;, function step3(result3) &#123;</span><br><span class="line">		 console.log(result3);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(&#x27;D&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;E&#x27;);</span><br><span class="line"></span><br><span class="line">// Output: A E B D C</span><br><span class="line"></span><br><span class="line">function identity(input, callback) &#123;</span><br><span class="line">	setTimeout(function () &#123;</span><br><span class="line">			callback(input);</span><br><span class="line">	&#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一步，都在程序的控制流内进行回调。这就导致了有时被称为回调地狱的嵌套函数。当然，你完全可以避免嵌套，因为JS的函数声明是被提升的（它们被计算定义是在它们作用域的最开始阶段）。这意味着你可以提前调用和使用定义在程序后面的函数声明。下面代码就是使用提升使得之前的例子扁平化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;A&#x27;);</span><br><span class="line">identity(&#x27;B&#x27;, step2);</span><br><span class="line">function step2(result2) &#123;</span><br><span class="line">	// The program continues here</span><br><span class="line">	console.log(result2);</span><br><span class="line">	identity(&#x27;C&#x27;, step3);</span><br><span class="line">	console.log(&#x27;D&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function step3(result3) &#123;</span><br><span class="line">	console.log(result3);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;E&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-CPS中编写代码"><a href="#3-4-CPS中编写代码" class="headerlink" title="3.4. CPS中编写代码"></a>3.4. CPS中编写代码</h3><p>在一般的JS风格中，我们使用以下方式来组合代码块：</p>
<ol>
<li>将其一个接一个放置。使代码变得一目了然，普通风格的级联式代码可以帮助我们提醒记住代码的正确组合顺序。</li>
<li>Array 的方法，比如 map()，filter() 和 forEach()。</li>
<li>如 for 或者 while 的循环。</li>
</ol>
<p>Async.js 这个库提供了让我们用 CPS 做的更简单的操作符，NodeJS 风格的回调函数。下面是一个被使用来加载存在数组中的三个文件内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&#x27;async&#x27;);</span><br><span class="line">var fileNames = [ &#x27;foo.txt&#x27;, &#x27;bar.txt&#x27;, &#x27;baz.txt&#x27; ];</span><br><span class="line">async.map( fileNames, function( fileName, callback )&#123;</span><br><span class="line">	fs.readFile( fileName, &#123; encoding: &#x27;utf8&#x27; &#125;, callBack );</span><br><span class="line">&#125;, function( error, textArray )&#123;</span><br><span class="line">	if( error )&#123;</span><br><span class="line">			cosole.log( error );</span><br><span class="line">			return;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log( &#x27;TEXTS:&#x27; + textArray.join( &quot; &quot; ) );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<h3 id="3-5-回调函数的利弊"><a href="#3-5-回调函数的利弊" class="headerlink" title="3.5. 回调函数的利弊"></a>3.5. 回调函数的利弊</h3><p>使用回调函数处理结果是一种完全不同的编程风格，CPS。CPS主要优点是很容易理解。当然，他有一些缺点：</p>
<ol>
<li>错误监控变的较为复杂：一般通过两种方式来处理报错，通过回调函数和异常。也需要小心两者相结合的情况。</li>
<li>更少的信息：在同步函数中对于输入（参数）和输出（函数的返回值）会有一个明确的关系。在异步函数中使用回调函数，他们被混在一起：函数结果并不重要，并且一些参数作为输入，一些参数作为输出。</li>
<li>组合变的更为复杂：因为有些输出就在参数中，这变成了更为复杂的组合器。</li>
</ol>
<p>在 NodeJS 风格中回调函数有三个弊端（与函数式风格相比较）：</p>
<ol>
<li>使用 if 语句处理错误状态增加了复杂程度。</li>
<li>重用绑定函数较为困难。</li>
<li>提供一个默认的错误处理函数也很困难。如果你对自己的函数调用不想写处理函数，那么默认的错误处理函数是非常有用的。它可以被使用在函数调用者没有指定特定的处理函数的时候。</li>
</ol>
<h2 id="4-展望一下"><a href="#4-展望一下" class="headerlink" title="4. 展望一下"></a>4. 展望一下</h2><p>第二部分主要包括了 promises 以及 ES6 中 promise API。Promises 底层的实现比回调函数复杂很多。当然，它也带来了挺多优势之处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2015/02/08/js-observer-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/02/08/js-observer-pattern/" class="post-title-link" itemprop="url">JS设计模式八：观察者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-02-09 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-09T00:00:00+08:00">2015-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2015/02/08/js-observer-pattern/" class="post-meta-item leancloud_visitors" data-flag-title="JS设计模式八：观察者模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>观察者模式对于前端开发来说也是一种接触较为频繁的软件设计模式，如果没注意过，那说明你还要好好学习啦。</p>
<p>观察者模式又称做发布订阅模式，基本定义为一对多或者多对多的依赖关系，由一个或者多个观察者对象来对一个或者多个发布者进行监听，由发布者的行为来触发各个观察者的行为。</p>
<p>观察者模式使的可以支持简单的广播通信，自动通知所有订阅过的对象，从而使得目标对象和各个观察者可以各自独立，减弱耦合度，使两者更容易扩展和重用。</p>
<p>简单的观察者模式也就无非为一个简单的对象，内部有一个存放函数的数组 list， add以及fire方法，add方法用来添加监听的回调函数进入lists数组，fire则是传递参数触发回调函数列表。这是JS中以回调函数形式实现观察者模式最简单的一种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Observable = &#123;</span><br><span class="line">    lists : [],</span><br><span class="line">    add : function( fn )&#123;</span><br><span class="line">        this.lists.push( fn );</span><br><span class="line">    &#125;,</span><br><span class="line">    fire : function( args )&#123;</span><br><span class="line">        this.lists.forEach(fucntion()&#123;</span><br><span class="line">            fn( args );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果当然是biubiu弹出两个console了。下面是一个稍微复杂点的观察者模式，包含了订阅，发布以及退订三个方法，基本可以实现一些简单的观察者模式。以围绕存储回调函数列表的对象 topics 进行订阅，发布和退订。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line"></span><br><span class="line">    var q = window.pubsub = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var topics = &#123;&#125;,</span><br><span class="line">        subUid = 0;</span><br><span class="line"></span><br><span class="line">    // 发布</span><br><span class="line">    q.publish = function (topic, args) &#123;</span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        var subscribers = topics[topic],</span><br><span class="line">            len = subscribers ? subscribers.length : 0,</span><br><span class="line">            i = 0;</span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line">            subscribers[i].func(args);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //订阅方法</span><br><span class="line">    q.subscribe = function (topic, func) &#123;</span><br><span class="line">        if( !func )&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line">            topics[topic] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        var token = subUid++;</span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            func: func</span><br><span class="line">        &#125;);</span><br><span class="line">        return token;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //退订方法</span><br><span class="line">    q.unsubscribe = function (topic, token) &#123;</span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        var subscribers = topics[topic],</span><br><span class="line">            len = subscribers ? subscribers.length : 0,</span><br><span class="line">            i = 0;</span><br><span class="line">        for (; i &lt; len; i++) &#123;</span><br><span class="line">            if (subscribers[i].token === token) &#123;</span><br><span class="line">                subscribers.splice(i, 1);</span><br><span class="line">                return token;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>一般来说这是JS中实现观察者模式最基本的形式，数组来存放回调，手动进行回调函数的添加，删除和触发。有点类似于一些库中的回调函数的形式。在复杂一点就是处理一下对于数据的储存方式等，下面是之前写过的一个自己的观察者模式实现方式：</p>
<p>subpub 模块，实现发布者与订阅者双向记录绑定 即：发布者中记录订阅该发布者的所有订阅者， 订阅者中记录该订阅者订阅的所有发布者。</p>
<p>实现创建 publisher 发布者 和 subscriber 订阅者 。</p>
<p><strong>publisher 实现</strong></p>
<ol>
<li>publish 发布信息 </li>
<li>addSubscriber 添加订阅者 </li>
<li>deleteSubscriber 删除订阅者 </li>
<li>clear 清空订阅者。</li>
</ol>
<p><strong>subscriber 实现</strong> </p>
<ol>
<li>subscribe 订阅发布者 </li>
<li>unsubscribe 取消订阅发布者 </li>
<li>triggle 触发订阅者执行函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">(function( subpub )&#123;</span><br><span class="line">    if( typeof define === &quot;function&quot; &amp;&amp; define.amd )&#123;</span><br><span class="line">        define( subpub );</span><br><span class="line">    &#125;else if( window.jQuery )&#123;</span><br><span class="line">        var old = jQuery.subpub,</span><br><span class="line">            sp = subpub();</span><br><span class="line">        jQuery.subpub = sp;</span><br><span class="line">        jQuery.template.noConflict = function () &#123;</span><br><span class="line">            jQuery.subpub = old;</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if( !window.subpub )&#123;</span><br><span class="line">        window.subpub = subpub();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw new Error(&#x27;Variable cookie is already exit in window&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(function()&#123;</span><br><span class="line">   </span><br><span class="line">    // 由于发布者 订阅者是双向存储标记的 所以使用发布者ID和订阅者ID进行标记</span><br><span class="line">    // 发布和订阅总对象来关联 ID 与 对象</span><br><span class="line">    var PUBID = 0,</span><br><span class="line">        pubObj = &#123;&#125;,</span><br><span class="line">        SUBID = 0,</span><br><span class="line">        subObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 关于对象类型的均不采用鸭子辨别法 只用全等</span><br><span class="line">    function has( array, item )&#123;</span><br><span class="line">        var value,i,len, hasOwn = &#123;&#125;.hasOwnProperty;</span><br><span class="line">        if(array == null) return;</span><br><span class="line"></span><br><span class="line">        if( array instanceof Array )&#123;</span><br><span class="line">            for(i=0, len=array.length; i&lt;len; i++)&#123;</span><br><span class="line">                if( array[i] === item )&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(var key in array)&#123;</span><br><span class="line">                if(hasOwn.call(array, key) &amp;&amp; array[key] === item)&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function each( array, iterator, context )&#123;</span><br><span class="line">        var value,i,len,</span><br><span class="line">            forEach = [].forEach,</span><br><span class="line">            hasOwn = &#123;&#125;.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">        context = context||this;</span><br><span class="line"></span><br><span class="line">        if(array == null) return;</span><br><span class="line"></span><br><span class="line">        if(forEach &amp;&amp; array.forEach === forEach)&#123;</span><br><span class="line">            array.forEach(iterator, context);</span><br><span class="line">        &#125;else if( array instanceof Array )&#123;</span><br><span class="line">            for(i=0, len=array.length; i&lt;len; i++)&#123;</span><br><span class="line">                iterator.call(context, array[i], i, array);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(var key in array)&#123;</span><br><span class="line">                if(hasOwn.call(array, key))&#123;</span><br><span class="line">                    iterator.call(context, array[key], key, array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function publisher()&#123;</span><br><span class="line"></span><br><span class="line">        // 本来想将该属性私有封装，不过代码量会增加很多，并且也没有什么必要</span><br><span class="line">        this.subIds = [];</span><br><span class="line">        this.pubID = PUBID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publisher.prototype = &#123;</span><br><span class="line"></span><br><span class="line">        // 发布 触发所有的 subIds id 列表成员的 trigger</span><br><span class="line">        publish : function( info )&#123;</span><br><span class="line">            var subIds = this.subIds;</span><br><span class="line"></span><br><span class="line">            each( subIds, function( subId )&#123;</span><br><span class="line">                subObj[subId].trigger( info );</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 发布者中添加 订阅者， 并在订阅者中记录发布者 单一订阅原则</span><br><span class="line">        addSubscriber : function( subscriber )&#123;</span><br><span class="line">            var subIds = this.subIds,</span><br><span class="line">                subId = subscriber.subID;</span><br><span class="line"></span><br><span class="line">            // 单一订阅 也可以避免 订阅者 发布者中相互记录的无限循环</span><br><span class="line">            if( has( subIds, subId ) )&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(subscriber &amp;&amp; subscriber.subscribe)&#123;</span><br><span class="line">                subIds.push( subId );</span><br><span class="line">                subscriber.subscribe( this );</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw new Error(&#x27;subscriber is illegal&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        deleteSubscriber : function( subscriber )&#123;</span><br><span class="line">            var subIds = this.subIds,</span><br><span class="line">                subId = subscriber.subID;</span><br><span class="line"></span><br><span class="line">            if( !has( subIds, subId ) )&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (var i = subIds.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                if( subIds[i] === subId )&#123;</span><br><span class="line">                    subIds.splice(i, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            subscriber.unsubscribe( this );</span><br><span class="line"></span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        clear : function()&#123;</span><br><span class="line">            var subIds = this.subIds;</span><br><span class="line">            for (var i = subIds.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                subObj[ subIds[i] ].unsubscribe( this );</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            this.subIds = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function subscriber( func )&#123;</span><br><span class="line">        this.pubIds = [];</span><br><span class="line">        this.subID = SUBID;</span><br><span class="line">        this.callbck = func;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subscriber.prototype = &#123;</span><br><span class="line">        subscribe : function( publisher )&#123;</span><br><span class="line">            var pubIds = this.pubIds,</span><br><span class="line">                pubId = publisher.pubID;</span><br><span class="line"></span><br><span class="line">            if( has( pubIds, pubId ) )&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if( publisher &amp;&amp; publisher.addSubscriber )&#123;</span><br><span class="line">                pubIds.push( pubId );</span><br><span class="line">                publisher.addSubscriber(this);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw new Error(&#x27;publisher is illegal&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        unsubscribe : function( publisher )&#123;</span><br><span class="line">            var pubIds = this.pubIds,</span><br><span class="line">                pubId = publisher.pubID;</span><br><span class="line"></span><br><span class="line">            if( !has( pubIds, pubId ) )&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (var i = pubIds.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                if( pubIds[i] === pubId )&#123;</span><br><span class="line">                    pubIds.splice(i, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            publisher.deleteSubscriber( this );</span><br><span class="line"></span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        clear : function()&#123;</span><br><span class="line">            var pubIds = this.pubIds;</span><br><span class="line">            for (var i = pubIds.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                pubObj[ pubIds[i] ].deleteSubscriber( this );</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            this.pubIds = [];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        trigger : function( args )&#123;</span><br><span class="line">            this.callbck( args );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        creatPublisher : function()&#123;</span><br><span class="line">            var pub = new publisher();</span><br><span class="line">            pubObj[ PUBID++ ] = pub;</span><br><span class="line"></span><br><span class="line">            return pub;</span><br><span class="line">        &#125;,</span><br><span class="line">        creatSubscriber : function( func )&#123;</span><br><span class="line">            var sub = new subscriber( func );</span><br><span class="line">            subObj[ SUBID++ ] = sub;</span><br><span class="line"></span><br><span class="line">            return sub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">    实例：</span><br><span class="line"></span><br><span class="line">var sp = window.subpub;</span><br><span class="line"></span><br><span class="line">var a1 = sp.creatPublisher(), a2 = sp.creatPublisher(), a3 = sp.creatPublisher();</span><br><span class="line">var b1 = sp.creatSubscriber(function(a)&#123; console.log(&#x27;b1 &#x27;+a) &#125;),</span><br><span class="line">    b2 = sp.creatSubscriber(function(a)&#123; console.log(&#x27;b2 &#x27;+a) &#125;),</span><br><span class="line">    b3 = sp.creatSubscriber(function(a)&#123; console.log(&#x27;b3 &#x27;+a) &#125;);</span><br><span class="line"></span><br><span class="line">a1.addSubscriber(b1)</span><br><span class="line">a1.addSubscriber(b3)</span><br><span class="line">a2.addSubscriber(b2)</span><br><span class="line">a3.addSubscriber(b1)</span><br><span class="line">a3.addSubscriber(b2)</span><br><span class="line">a3.addSubscriber(b3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt; a1.publish(&quot;this is a1 publish&quot;)</span><br><span class="line">&gt; &quot;b1 this is a1 publish&quot;</span><br><span class="line">&gt; &quot;b3 this is a1 publish&quot;</span><br><span class="line"></span><br><span class="line">&lt; a3.deleteSubscriber(b1)</span><br><span class="line">&lt; a3.deleteSubscriber(b2)</span><br><span class="line">&lt; a3.publish(&quot;this is a3 publish&quot;)</span><br><span class="line">&gt; &quot;b3this is a3 publish&quot;</span><br><span class="line"></span><br><span class="line">&lt; b3.unsubscribe(a3)</span><br><span class="line">&lt; b2.subscribe(a3)</span><br><span class="line">&lt; a3.publish(&quot;this is a3 publish&quot;)</span><br><span class="line">&gt; &quot;b2 this is a3 publish&quot;</span><br></pre></td></tr></table></figure>

<p>简单学习了那么些设计模式之后，其实越来越觉得设计模式开始越来越抽象化，成为一种类似于现实如何转化为逻辑，思维的一种方式。所以个人认为，如何将事物抽象化，各种方式主要解决的针对性问题是什么，或许就是设计模式存在的真正意义吧。</p>
<p>不足之处，望读者指出，谢谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/10/13/es6-module-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/10/13/es6-module-2/" class="post-title-link" itemprop="url">【译】 ECMAScript 6 模块化：最后的战役（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2014-10-14T00:00:00+08:00">2014-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2014/10/13/es6-module-2/" class="post-meta-item leancloud_visitors" data-flag-title="【译】 ECMAScript 6 模块化：最后的战役（下）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="5-导入导出更多信息"><a href="#5-导入导出更多信息" class="headerlink" title="5. 导入导出更多信息"></a>5. 导入导出更多信息</h2><h3 id="5-1-导入"><a href="#5-1-导入" class="headerlink" title="5.1. 导入"></a>5.1. 导入</h3><p><strong>ECMAScript 6 提供了以下的导入方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义式导出和命名式导出</span><br><span class="line">import theDefault, &#123; named1, named2 &#125; from &#x27;src/mylib&#x27;;</span><br><span class="line">import theDefault from &#x27;src/mylib&#x27;;</span><br><span class="line">import &#123; named1, named2 &#125; from &#x27;src/mylib&#x27;;</span><br><span class="line"></span><br><span class="line">// 重命名：导入named1 作为 myNamed1</span><br><span class="line">import &#123; named1 as myNamed1, named2 &#125; from &#x27;src/mylib&#x27;;</span><br><span class="line"></span><br><span class="line">// 作为兑现导入模块（每个命名式导出均作为一个属性）</span><br><span class="line">import * as mylib from &#x27;src/mylib&#x27;;</span><br><span class="line"></span><br><span class="line">// 仅仅加载模块而不导出</span><br><span class="line">import &#x27;src/mylib&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-导出"><a href="#5-2-导出" class="headerlink" title="5.2. 导出"></a>5.2. 导出</h3><p>在当前模块内部有两种方式导出。一种就是以关键字 export 标记导出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export var myVar1 = ...;</span><br><span class="line">export let myVar2 = ...;</span><br><span class="line">export const myVar3 = ...;</span><br><span class="line"></span><br><span class="line">export function myFunc()&#123; ... &#125;</span><br><span class="line">export function* myGeneratorFunc()&#123; ... &#125;</span><br><span class="line">export class MyClass&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>操作符 default 导出的是表达式（包括函数表达式，类表达式）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default 123;</span><br><span class="line">export default function (x)&#123; </span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">export default x =&gt; x;</span><br><span class="line">export default class&#123;</span><br><span class="line">    constructor( x, y )&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方式就是将所有你想导出的列出来放置在模块最下方（风格与模块模式比较类似）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONST = ... ;</span><br><span class="line">function myFunc()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; MY_CONST, myFunc &#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用不同的名称导出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &#123; MY_CONST as THE_CONST, myFunc as theFunc &#125;;</span><br></pre></td></tr></table></figure>

<p>记住不能使用保留字作为变量名称（如 default 和 new），却可以作为导出名称来使用（在 ECMAScript 5 中也可以将其作为属性名称来使用）。如果你是直接导入这些命名式导出，那么你就需要使用变量名称来重命名。</p>
<h3 id="5-3-重导出"><a href="#5-3-重导出" class="headerlink" title="5.3. 重导出"></a>5.3. 重导出</h3><p>重导出意味着你在当前模块添加另一个模块的导出。你可以看添加所有的模块导出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export * from &#x27;src/other_moule&#x27;;</span><br></pre></td></tr></table></figure>

<p>或者你可以添加选着（通过重命名）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export &#123; foo, bar &#125; from &#x27;src/other_moule&#x27;;</span><br><span class="line">// 以 myFoo 来导出模块 other_module 的 foo</span><br><span class="line">export &#123; foo as myFoo, bar &#125; from &#x27;src/other_moule&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="6-模块的元数据"><a href="#6-模块的元数据" class="headerlink" title="6. 模块的元数据"></a>6. 模块的元数据</h2><p>ECMAScript 6 也提供了在模块内部访问当前模块数据的方式（比如模块的 URL），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; url &#125; from this module;</span><br><span class="line">console.log( url );</span><br></pre></td></tr></table></figure>

<p>this module 表示一个简单的作为一个模块导入元数据的标识。它也可以作为模块元数据。</p>
<p>也可以通过对象来访问元数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as metaData from this module;</span><br><span class="line">console.log( metaData.url );</span><br></pre></td></tr></table></figure>

<p>Node.js 使用模块局部变量 __fileName 来作为这类元数据。</p>
<h2 id="7-eval-和-模块"><a href="#7-eval-和-模块" class="headerlink" title="7. eval() 和 模块"></a>7. eval() 和 模块</h2><p>eval() 不支持模块语法。它将参数按照脚本语法规则解析，而脚本是不支持模块语法的（稍后说明原因）。如果你想运行模块代码，你可以使用模块加载器的API（稍后说明）。</p>
<h2 id="8-ECMAScript-6-模块加载器-API"><a href="#8-ECMAScript-6-模块加载器-API" class="headerlink" title="8. ECMAScript 6 模块加载器 API"></a>8. ECMAScript 6 模块加载器 API</h2><p>除了定义了模块语法的工作之外，还有一个编程式的API，它可以使：</p>
<ol>
<li>编程式的使用模块和脚本</li>
<li>配置模块加载。</li>
</ol>
<p>加载器解决了模块修饰符（在 import… from 后面的字符串 ID）的加载模块。构造函数是  Reflect.Loader 。每个平台都有其自己特定的全局变量 System（系统加载器），实现其平台特定的模块加载方式。</p>
<h3 id="8-1-导入模块和加载脚本"><a href="#8-1-导入模块和加载脚本" class="headerlink" title="8.1. 导入模块和加载脚本"></a>8.1. 导入模块和加载脚本</h3><p>你可以通过 ES6 promises 式的 API，编程式的导入一个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.import( &#x27;some_moule&#x27; )</span><br><span class="line">.then( some_module =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; )</span><br><span class="line">.catch( error =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>

<p>System.import() 使你可以：</p>
<pre><code>1. 在 标签内部使用模块（不支持模块语法）。
2. 限制性加载模块。
</code></pre>
<p>System.import() 可以载入单个模块，导入多个模块你可以使用 Promise.all():</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.all(</span><br><span class="line">    [ &#x27;module1&#x27;, &#x27;module2&#x27;, &#x27;module3&#x27; ]</span><br><span class="line">    .map( x =&gt; System.import( x ) ) )</span><br><span class="line">.then( &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>更多加载方式：</p>
<ol>
<li>System.module( source, options? ) 在 source 的模块的中运行 JavaScript 代码（通过 promise 实现异步形式）</li>
<li>System.set( name, module ) 为注册一个模块（一个你通过 System.module() 创建的）。</li>
<li>System.define( name, source, option? )  运行模块代码并且注册结果。</li>
</ol>
<h3 id="8-2-配置模块加载"><a href="#8-2-配置模块加载" class="headerlink" title="8.2. 配置模块加载"></a>8.2. 配置模块加载</h3><p>模块加载器API的配置有各种钩子。完成工作依旧在进行中。第一个为浏览器开发的系统加载器当前正在实施测试。目标是找到最好的模块加载配置方式。</p>
<p>加载器API需要允许多种自定义加载，如：</p>
<ol>
<li>导入时检测模块是否符合Lint（如 通过 JSLint 或者 JSHint）</li>
<li>导入时自动转译模块（模块内可能有 CoffeeScript 或者 TypeScript 代码）</li>
<li>使用传统的模块（AMD，Node.js的）</li>
</ol>
<p>配置模块加载在 Node.js 和 CommonJS 中是受限制的。</p>
<h2 id="9-蓝图"><a href="#9-蓝图" class="headerlink" title="9. 蓝图"></a>9. 蓝图</h2><p>下文内容回答了两个关于 ECMAScript 6 模块的相关问题：如何运作？如何插入到HTML中？</p>
<ol>
<li>“现在如何使用 ECMAScript 6”【译文在此】提供了一个 ECMAScript 6 的概述，解释了如何将其编译为 ECMAScript 5。如果有兴趣可以从<a target="_blank" rel="noopener" href="http://www.2ality.com/2014/08/es6-today.html#using_ecmascript_6_today">这里</a>开始阅读。一个小而有趣的解决方案 ES6 Module Transplier 仅仅添加了将 ES6 模块语法编译成 ES5，既不是 AMD 也非 CommonJS。</li>
<li>在 HTML 中插入 ES6：在 script&gt; 标签中的代码不支持模块语法，因为元素的同步特性与模块的异步特性是相冲突的。取而代之的你可以使用新的 标签。文章“<a target="_blank" rel="noopener" href="http://www.2ality.com/2013/11/es6-modules-browsers.html">未来浏览器中的ECMAScript 6 模块化 </a>”介绍了 的工作原理。相对于 script&gt;来说有几个明显的优点，并且可以选着替代版本</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">倪颖峰</p>
  <div class="site-description" itemprop="description">曾在果壳、百度蹦哒，目前在B站活跃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/niyingfeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;niyingfeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yingfeng.ni@gmail.com" title="E-Mail → mailto:yingfeng.ni@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">倪颖峰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
     & <a target="_blank" href="https://beian.miit.gov.cn/" title="Semantic Personal Publishing Platform">浙ICP备16020323号-1</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"z3J5VC7OBuKe3Bs1ApRTYaT8-gzGzoHsz","app_key":"jijPF2bP4TXvA3lY4rddhVVF","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
