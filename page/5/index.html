<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freefe.cc","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:type" content="website">
<meta property="og:title" content="NiYingfeng 的博客">
<meta property="og:url" content="http://freefe.cc/page/5/index.html">
<meta property="og:site_name" content="NiYingfeng 的博客">
<meta property="og:description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="倪颖峰">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://freefe.cc/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>NiYingfeng 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">NiYingfeng 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、生活与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/09/14/js-calculation-most-letter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/09/14/js-calculation-most-letter/" class="post-title-link" itemprop="url">JS 统计一个字符串中出现次数最多字母</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2014-09-15T00:00:00+08:00">2014-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个感觉很平凡的，常常在面试中出现的题目，拥有各种实现形式也就显示出 JS 水平的不同。</p>
<p>首先，简单的来一个基本思路的计算方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function maxNumLetter( str )&#123;</span><br><span class="line">    var lettersObj = &#123;&#125;,</span><br><span class="line">        len = str.length,</span><br><span class="line">        letter, letterNum, maxLetter, maxNumber = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while( len-- )&#123;</span><br><span class="line">        letter = str.substr(len, 1);</span><br><span class="line">        letterNum = lettersObj[ letter ] = ( lettersObj[ letter ] || 0 ) + 1;</span><br><span class="line">        </span><br><span class="line">        if( letterNum &gt; maxNumber )&#123;</span><br><span class="line">            maxLetter = letter;</span><br><span class="line">            maxNumber = letterNum;</span><br><span class="line">        &#125;else if( letterNum === maxNumber )&#123;</span><br><span class="line">            ( maxLetter instanceof Array) ? maxLetter.push( letter ) : ( maxLetter = [ maxLetter, letter ] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLetter.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是基本实现形式，对字符串的每个字母进行遍历，并且在 lettersObj 进行缓存记录，不过每次循环都对字符串进行截取字母看着总是有点不爽，那么可以先将字符串通过 split 进行数组化在进行循环遍历，或者使用字符串的 replace 方式进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function maxNumLetter( str )&#123;</span><br><span class="line">    var lettersObj = &#123;&#125;,</span><br><span class="line">        letterNum, maxLetter, maxNumber = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    str.replace(/[a-zA-Z]/g, function( l )&#123;</span><br><span class="line">        var lNum = (lettersObj[ l ] || 0 ) + 1;</span><br><span class="line">              letterNum = lettersObj[ l ] = ( lettersObj[ l ] || 0 ) + 1;</span><br><span class="line">       </span><br><span class="line">        if( letterNum &gt; maxNumber )&#123;</span><br><span class="line">              maxLetter = l;</span><br><span class="line">              maxNumber = letterNum;</span><br><span class="line">        &#125;else if( letterNum === maxNumber )&#123;</span><br><span class="line">              ( maxLetter instanceof Array) ? maxLetter.push( l ) : ( maxLetter = [ maxLetter, l ] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return maxLetter.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 replace 添加函数参数形式的特性来替代人工的字母遍历循环。当然由于考虑有相同最多次数字母情况，所以显得比较繁琐。如果还有较为巧妙的方法，欢迎学习交流~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/09/08/iframe-height-auto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/09/08/iframe-height-auto/" class="post-title-link" itemprop="url">iframe自适应高度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2014-09-09T00:00:00+08:00">2014-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>iframe 自适应高度，目前最广泛的实现方式是以 JS 获取 iframe 所载入页面的 body 高度。（在本地 html 文件测试的时候 chrome 会有跨域错误，可以使用 IE 来测试）。其实质就是通过 offsetHeight 或者 scrollHeight 获取到 iframe 内部 body 的高度，再调整 iframe 高度即可。</p>
<p>以下是Test.html 源码初略形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;iframe 自适应高度&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;iframe id=&quot;auto&quot; name=&quot;auto&quot; src=&quot;./Test2.html&quot; width=&quot;100%&quot; onload=&quot;autoHeight()&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;</span><br><span class="line">      function autoHeight()&#123; </span><br><span class="line">        var ifr = document.getElementById(&#x27;auto&#x27;); </span><br><span class="line">        ifr.height = ( ifr.contentDocument &amp;&amp; ifr.contentDocument.body.offsetHeight ) ||</span><br><span class="line">                     ( ifr.contentWindow.document.body.scrollHeight ); </span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>Test2.html 源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt; </span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;iframe 自适应高度&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      html,body&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      #block&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">        height: 500px;</span><br><span class="line">        width: 800px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;block&quot;&gt; &lt;/div&gt; </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>当然以上只是简单的实现，具体更严谨的计算高度做好使用一些兼容性不错库作为基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/08/10/ecmascript6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/08/10/ecmascript6/" class="post-title-link" itemprop="url">【译】来试试 ECMAScript 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-08-11 00:00:00" itemprop="dateCreated datePublished" datetime="2014-08-11T00:00:00+08:00">2014-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="http://www.2ality.com/2014/08/es6-today.html">http://www.2ality.com/2014/08/es6-today.html</a> 原文作者：Dr. Axel Rauschmayer （ 译者： 可以在此处了解 ES5.1 的情况 ） ECMAScript 6 （ES6）听起来依旧感觉离我们很远。毕竟，它要到2015年中旬才能成为标准。但是，它的一些特性逐渐出现在一些浏览器中，有其内置的编译器将 ES6编码 转化为 ES5编码。由于 ES6 的特性集为冻结状态，所以通过后者实现是一个不错的解决方案。 本文简述一下 ECMAScript 6 的特性以及介绍一下现在来使用它们的一些工具。</p>
<h3 id="1-ECMAScript-6-的亮点"><a href="#1-ECMAScript-6-的亮点" class="headerlink" title="1. ECMAScript 6 的亮点"></a>1. ECMAScript 6 的亮点</h3><p>本段展现一些 ECMAScript 6 的亮点。</p>
<h3 id="1-1-新语法"><a href="#1-1-新语法" class="headerlink" title="1.1. 新语法"></a>1.1. 新语法</h3><p><code>对象字面量 - 属性值简写（用于后面重构的例子）：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">let first = &#x27;Jane&#x27;;</span><br><span class="line">let last = &#x27;Doe&#x27;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first, last &#125;;</span><br><span class="line">// 等同于</span><br><span class="line">let obj = &#123; first:first, last:last &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`对象字面量 - 方法定义：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">        myMethod( arg0, arg1 )&#123;</span><br><span class="line">                // ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`箭头函数：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ 1,2,3 ];</span><br><span class="line">let squares = arr.map( x =&gt; x\*x );</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`扩展操作符：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ -1, 7, 2 ];</span><br><span class="line">let highest = Math.max( ...arr ); // 7</span><br><span class="line">new Date( ...[ 2011, 11, 24 ] );</span><br><span class="line">// 非破坏性的链接单个元素</span><br><span class="line">let arr2 = [ ...arr, 9, -6 ]; // [ -1, 7, 2, 9, -6 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`重构：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [ all, year, month, day ] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec(&#x27;20110-12-12&#x27;);</span><br><span class="line">let &#123; first, last &#125; = &#123; first: &#x27;Jane&#x27;, last: &#x27;Doe&#x27; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`参数默认值`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function findClosestShape( x=0, y=0 )&#123;</span><br><span class="line">        // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`余参`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function format( pattern, ...params )&#123;</span><br><span class="line">        // return params;</span><br><span class="line">&#125;</span><br><span class="line">console.log( formart( &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ) );</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`通过重构命名参数：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Entries&#123;</span><br><span class="line">        // ...</span><br><span class="line">        selectEntries( &#123; from=0, to=this.length &#125; = &#123;&#125; )&#123;</span><br><span class="line">                // Long: &#123; from: from=0, to: to=this.length &#125;</span><br><span class="line">                // Use &#x27;from&#x27; and &#x27;to&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let entries = new Entriea();</span><br><span class="line">entries.selectEntries( &#123; from:5, to: 15 &#125; );</span><br><span class="line">entries.selectEntries( &#123; from:5 &#125; );</span><br><span class="line">entries.selectEntries( &#123; to: 15 &#125; );</span><br><span class="line">entries.selectEntries( &#123; &#125; );</span><br><span class="line">entries.selectEntries();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`模板字符串：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let str = String.raw`This is a text </span><br><span class="line">with multiple lines.</span><br><span class="line"> Escapes are not interpreted,</span><br><span class="line"> \n is not a newline.`</span><br><span class="line"></span><br><span class="line">var parts = &#x27;/2012/10/Page.html&#x27;.match(XRegExp.rx`</span><br><span class="line">                ^ # match at start of string only</span><br><span class="line">                / (?&lt;year&gt; [^/]+ ) # capture top dir name as year</span><br><span class="line">                / (?&lt;month&gt; [^/]+ ) # capture subdir name as month</span><br><span class="line">                / (?&lt;title&gt; [^/]+ ) # capture base name as title</span><br><span class="line">                \.html? $ # .htm or .html file ext at end of path</span><br><span class="line">        `);</span><br><span class="line">console.log( parts.year ); // 2012</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`类：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">        constructor( nane )&#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        describe()&#123;</span><br><span class="line">                return &quot;Person called&quot; + this.name;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line">        constructor ( name, title )&#123;</span><br><span class="line">                // super.constructor( name )</span><br><span class="line">                super( name );</span><br><span class="line">                this.title = title; </span><br><span class="line">        &#125;</span><br><span class="line">        describe()&#123;</span><br><span class="line">                // super.describe()</span><br><span class="line">                return super() + &quot;(&quot; + this.title + &quot;)&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`内置函数的子类，如 Error 和 Array：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyError extends Error&#123;</span><br><span class="line">        // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`for-of 循环（对于所有遵守 ES6 迭代规则的对象均有效）`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arr = [ &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27; ];</span><br><span class="line"></span><br><span class="line">for( let element of arr )&#123;</span><br><span class="line">        console.log( element );</span><br><span class="line">&#125;</span><br><span class="line">// foo</span><br><span class="line">// bar</span><br><span class="line">// baz</span><br><span class="line"></span><br><span class="line">for( let [ index, element ] of arr.entries() )&#123;</span><br><span class="line">        console.log( index + &quot;.&quot; + element );</span><br><span class="line">&#125;</span><br><span class="line">// foo</span><br><span class="line">// bar</span><br><span class="line">// baz</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`模块化`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">export const sqet = Math.sqrt;</span><br><span class="line">export function square( x )&#123;</span><br><span class="line">        return x * x ;</span><br><span class="line">&#125;</span><br><span class="line">export function diag( x, y )&#123;</span><br><span class="line">        return sqrt( square(x) + square( y ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import &#123; square, diag &#125; from &#x27;lib&#x27;;</span><br><span class="line">console.log( square( 11 ) ); // 121</span><br><span class="line">console.log( diag( 4, 3 ) ); // 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.2. 标准库中的新功能</span><br><span class="line"></span><br><span class="line">`Object.assign() ：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">        constructor( x, y )&#123;</span><br><span class="line">                Object.assign( this, &#123; x, y &#125; );</span><br><span class="line">                // ES6中 &#123; x, y &#125; 为 &#123; x : x, y : y &#125; 缩写。</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Array.prototype.findIndex()：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ 6, 8, -5 ].findIndex( x =&gt; x&lt;0 ); // 2</span><br><span class="line">[ 6, 8, -5 ].findIndex( x =&gt; x&lt;0 ); // -1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Array.prototype.fill()：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ].fill( 7 ); // [7, 7, 7]</span><br><span class="line">new Array( 3 ).fill( 7 ); // [7, 7, 7]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`新字符串方法：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello world&#x27;.startsWith( &#x27;hello&#x27; ); // true</span><br><span class="line">&#x27;*&#x27;.repeart( 5 ); // *****</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Map（值可以为任何数据格式）：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set( obj, 123 );</span><br><span class="line">map.get( obj ); // 123</span><br><span class="line">map.has( obj ); // true</span><br><span class="line">map.delete( obj ); // true</span><br><span class="line">map.has( obj ); // false</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Set：`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [5, 1, 7, 7, 5];</span><br><span class="line">let unique = [ ...new Set( arr ) ]; // [ 5, 1, 7 ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 1.3. 更多 ECMAScript 6 概要</span><br><span class="line"></span><br><span class="line">ECMAScript 6：JavaScript 的下一步棋 es6 特性 https://github.com/lukehoban/es6features#readme es6 利刃 https://github.com/hemanth/paws-on-es6</span><br><span class="line">### 2. 现在就是用 ECMAScript 6</span><br><span class="line">ECMAScript 6 特性开始不断在各种引擎中出现。你可以预览一下 Kangax 的” ECMAScript 6 兼容性表“来知道各个引擎的支持情况。 但对于现实中的项目，你还需要借助一些工具来使当前引擎使用 ECMAScript 6： &quot;es6-tools&quot;（https://github.com/addyosmani/es6-tools） ：就是这样一个完整的工具列表。 &quot;ES.next showcase&quot; （https://github.com/sindresorhus/esnext-showcase） ：展示了实际使用 ECMAScript 6 的特性。两个实例： 下一版本的 Ember.js 将通过 ES6 的模块 Transplier 来支持 ES6 模块。 下一个版本的 ArgularJS 将通过 Traceur 来支持 ES6 模块。 以下将介绍一些 ES6 应用的工具。</span><br><span class="line">### 3. ECMAScript 6 编译器</span><br><span class="line">如果一个工具需要将 ECMAScript 6 代码转换到 ECMAScript 5，那么它的功能需要超越转换器，所以称之为编译器。两个重要的编译器是 TypeScript 和 Traceur。</span><br><span class="line"></span><br><span class="line">### 3.1. TypeScript</span><br><span class="line"></span><br><span class="line">跟踪 ECMAScript 6 代码时 TypeScript 开发者所宣称的目标。因此，该语言允许你为 ECMAScript 6 添加注释（为可选）。 TypeScript 可以通过 npm 方便的安装，IDEs Visual Studio 和 WebStorm 均被支持。 当前的 TypeScript 的模块语法有一点滞后于 ECMAScript 6 的规范。它支持两种模块标准：CJS（Node.js） 和 AMD（RequireJS）。</span><br><span class="line"></span><br><span class="line">### 3.2. Traceur</span><br><span class="line"></span><br><span class="line">Traceur 是最流行的纯 ECMAScript 6 编译器。它对于新特性的支持令人震撼。Traceur 的开发者将它读为 &#x27; tray-SOOR &#x27;。有两种方式来使用 Traceur。 静态形式：构建工具（如 Grunt，Gulp，Broccoli 等）的 Traceur 插件可以在开发时将 ES6 文件自动编译为 ES5 文件。查看 es6 工具详情（https://github.com/addyosmani/es6-tools） 动态形式：如果你的 web 应用里有 Traceur 那么你可以通过给 script 标签赋值 type 属性为 module 进行 ES6 编译。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;output&quot;&gt;&lt;/div&gt; </span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;module&quot;&gt; </span><br><span class="line">        var output = document.getElementById(&#x27;output&#x27;); </span><br><span class="line">        var w = &#x27;world&#x27;; </span><br><span class="line">        output.textContent = `Hello $&#123;w&#125;!`; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&#96;&#96;&#96;</p>
<p>你可以通过传递一个编译参数来使 Traceur 使用确定的模块标准： 1. ES6 的模块加载API 2. AMD（RequireJS） 3. CJS（Node.js）</p>
<h3 id="4-模块系统-以及-ECMAScript-6"><a href="#4-模块系统-以及-ECMAScript-6" class="headerlink" title="4. 模块系统 以及 ECMAScript 6"></a>4. 模块系统 以及 ECMAScript 6</h3><p>一些现有的和新的 JavaScript 模块系统都通过现成的或者插件的方式来支持 ECMAScript 6。 1. AMD 和 CJS：ES 6 模块编译器（<a target="_blank" rel="noopener" href="https://github.com/square/es6-module-transpiler%EF%BC%89%E5%8A%A0%E5%85%A5%E4%BA%86%E5%B0%86">https://github.com/square/es6-module-transpiler）加入了将</a> ECMAScript 6 模块语法转移为 ECMAScript 5 将其编译为 AMD 或者 CJS。极简风格的解决方案较为吸引人。 2. Browserify：通过基于 Traceur 的 es6ify（<a target="_blank" rel="noopener" href="https://github.com/thlorenz/es6ify%EF%BC%89">https://github.com/thlorenz/es6ify）</a> 转换来支持 ES6。 3. webpack（<a target="_blank" rel="noopener" href="https://github.com/webpack/webpack%EF%BC%89%E6%9D%A5%E8%87%AA%E7%8E%B0%E6%9C%89%E7%9A%84">https://github.com/webpack/webpack）来自现有的</a> ECMAScript 6 支持。 4. ES6 模块加载补充：基于 ES6 API 和 在Node.js和当前浏览器中动态加载 ES6 模块。以下面两个工具进行补充： SystemJS：基于 ES6 的模块加载器，除了加载 ES6 模块之外还加载 AMD 和 CJS 模块。 jspm.io：为 SystemJS 而出现的包管理器。</p>
<h3 id="5-ECMAScript-6-命令行"><a href="#5-ECMAScript-6-命令行" class="headerlink" title="5. ECMAScript 6 命令行"></a>5. ECMAScript 6 命令行</h3><p>JavaScript 命令行是测试特性常用的交互方式。这边简单介绍下可以是使用 ECMAScript 6 语法的命令行。</p>
<h3 id="5-1-ES6-Fiddle"><a href="#5-1-ES6-Fiddle" class="headerlink" title="5.1. ES6 Fiddle"></a>5.1. ES6 Fiddle</h3><p>Jeff 编写的 ES6 Fiddle（<a target="_blank" rel="noopener" href="http://www.es6fiddle.com/%EF%BC%89%E6%98%AF%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8E">http://www.es6fiddle.com/）是一款基于</a> Traceur 的 ECMAScript 6 命令行工具。你可以点击工具栏的一个图标来通过 URL 和唯一的 ID 来保存一个实例。</p>
<h3 id="5-2-Traceur-转码-demo"><a href="#5-2-Traceur-转码-demo" class="headerlink" title="5.2. Traceur 转码 demo"></a>5.2. Traceur 转码 demo</h3><p>Traceur 有它自己的 demo 交互页面（<a target="_blank" rel="noopener" href="http://google.github.io/traceur-compiler/demo/repl.html%EF%BC%89%E3%80%82%E8%BF%99%E6%98%AF%E4%B8%80%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%8F%90%E7%A4%BA%EF%BC%9A">http://google.github.io/traceur-compiler/demo/repl.html）。这是一些页面的提示：</a> 1. 你可以打开控制台，通过 console.log() 看到所有你输入到控制台的 ES6 源码。 2. ES6 的源码都被添加到页面的 URL 中，所以你可以通过分享 URL 来分享 ES6 实例。 3. Traceur 在 ES5 中实现了许多 ES6 的方法，意味着你可以在控制台中直接使用例如 Array.form() 之类的方法。 4. let 和 const 变量声明仍在实验阶段，可以通过参数来打开。但是生成的代码较多。幸好这些计划（<a target="_blank" rel="noopener" href="https://github.com/google/traceur-compiler/issues/6%EF%BC%89%E6%9E%81%E5%A4%A7%E7%9A%84%E6%8F%90%E9%AB%98%E4%BA%86%E5%AF%B9">https://github.com/google/traceur-compiler/issues/6）极大的提高了对</a> let 和 const 的支持：比如，Traceur 可以用多种方式将 let 转到 var ，这样就不会有较大耗损性的使用let（前瞻性的）。</p>
<h3 id="6-ECMAScript-6-shims"><a href="#6-ECMAScript-6-shims" class="headerlink" title="6. ECMAScript 6 shims"></a>6. ECMAScript 6 shims</h3><p>Shims 是一些将未来系统属性模拟到当前系统中的一些库。ECMAScript 6 标准库中包含有趣的新功能，这些功能一般都可以通过库来反向编译为 ECMAScript 5。 1. es6-shim（<a target="_blank" rel="noopener" href="https://github.com/paulmillr/es6-shim%EF%BC%89%EF%BC%9A%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D">https://github.com/paulmillr/es6-shim）：支持多种</a> ECMAScript 6 标准库中的特性。 2. ECMAScript 6 promises 的 Shims（Traceur 有它自己的 promise polyfill）： RSVP.js（<a target="_blank" rel="noopener" href="https://github.com/tildeio/rsvp.js/%EF%BC%89%EF%BC%9A%E6%98%AF">https://github.com/tildeio/rsvp.js/）：是</a> ES6 API 的一个超集。 es6-promise（<a target="_blank" rel="noopener" href="https://github.com/jakearchibald/es6-promise%EF%BC%89%E6%98%AF">https://github.com/jakearchibald/es6-promise）是</a> RSVP.js 的子集，仅包含ES6 API。 Q.Promise 与 ES 6 兼容。</p>
<h3 id="7-那么继续学习-ECMAScript-5-还有意义么？"><a href="#7-那么继续学习-ECMAScript-5-还有意义么？" class="headerlink" title="7. 那么继续学习 ECMAScript 5 还有意义么？"></a>7. 那么继续学习 ECMAScript 5 还有意义么？</h3><p>众所周知，你现在已经完全可以使用 ECMAScript 6 的代码来避免旧版本的 JavaScript。那是否就意味着我们再也不需要学习 ECMAScript 5了？当然不是，举几个原因： 1. ECMAScript 6 是 ECMAScript 5 的一个超集，新版本 JavaScript 绝对不能破坏旧版本代码。那么你学习 ECMAScript 5并不会白费。 2. 有一部分 ECMAScript 6 特性是替换 ECMAScript 5 的特性的，但是前提是依旧可以使用。两个例子： classes 在内部转为构造函数，method 仍然为函数（因为一直都是）。 3. 只要 ECMAScript 6 被转义为 ECMAScript 5，那么了解编译过程的输出结果还是有用的。你必须要在一段时间内编译为 ES5（或许是几年），直到你可以在所有相关的浏览器中可以依赖 ES6，如现在依靠 ES5 一样。 4. 理解传统代码依旧是很重要的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/07/28/ecmascript-function-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/07/28/ecmascript-function-call/" class="post-title-link" itemprop="url">【译】ECMAScript 5 与 6 中方法的调度调用和和直接调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-07-29 00:00:00" itemprop="dateCreated datePublished" datetime="2014-07-29T00:00:00+08:00">2014-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="http://www.2ality.com/2014/07/method-calls.html">http://www.2ality.com/2014/07/method-calls.html</a></p>
<p>原文作者：Dr. Axel Rauschmayer</p>
<p>在 JavaScript 中有两种方式调用方法：通过调度调用（如：obj.someMethod( arg0, arg1 )）和直接调用（如：someFunc.call( thisValue, arg0, arg1 )）。本文解释一下两者的运行方式，以及为何在 ECMScript 6 我们较少的使用直接调用方法形式。</p>
<h2 id="1-调度式方法调用-vs-直接式方法调用"><a href="#1-调度式方法调用-vs-直接式方法调用" class="headerlink" title="1. 调度式方法调用 vs 直接式方法调用"></a>1. 调度式方法调用 vs 直接式方法调用</h2><h3 id="1-1-基础：原型链"><a href="#1-1-基础：原型链" class="headerlink" title="1.1. 基础：原型链"></a>1.1. 基础：原型链</h3><p>记住任何在 JavaScript 中对象事实上都是一个或者多个对象组成的链。第一个对象继承后者对象的属性。例如，一个数组 [‘a’, ‘b’]的原型链看起来应该为如下形式：</p>
<ol>
<li>实例，保存着元素 ‘a’ 和 ‘b’</li>
<li>Array.prototype，由 Array 构造函数提供的属性</li>
<li>Object.prototype，由 Object 构造函数提供的属性</li>
<li>null，（链的末端，并不是真正意义上链的成员）</li>
</ol>
<p>你可以通过 Object.getPrototypeOf() 来检测原型链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &#x27;a&#x27;, &#x27;b&#x27; ];</span><br><span class="line">var p = Object.getPrototypeOf;</span><br><span class="line"></span><br><span class="line">p( arr ) === Array.prototype; // true</span><br><span class="line">p( p( arr )) === Object.prototype; // true</span><br><span class="line">p( p( p( arr )));</span><br></pre></td></tr></table></figure>

<p>处在更靠前对象中的属性会覆盖靠后对象中的属性。例如，Array.prototype 中提供的一个数组形式版本的 toString() 方法覆盖了 <code>Object.prototype.toString()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &#x27;a&#x27;, &#x27;b&#x27; ];</span><br><span class="line">Object.getOwnPrototypeNames( Array.prototype ); // [&#x27;toString&#x27;, &#x27;join&#x27;, ...]</span><br><span class="line">arr.toString();</span><br></pre></td></tr></table></figure>

<h3 id="1-2-调度式方法调用"><a href="#1-2-调度式方法调用" class="headerlink" title="1.2. 调度式方法调用"></a>1.2. 调度式方法调用</h3><p>如果仔细观察 arr.toString() 的方法调用，可以发现它实际上执行了两步：</p>
<ol>
<li>调度：在 arr 的原型链上，取出第一个属性名为 toString 的属性值。</li>
<li>调用：调用所取到的值，设置隐式参数 this 为接受者 arr 作为其方法调用。</li>
</ol>
<p>你可以通过函数的 call() 方法来展示这两步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var func = arr.toString; // 调度</span><br><span class="line">func.call( arr ); // 直接调用，提供一个明确的 this 值</span><br></pre></td></tr></table></figure>

<h3 id="1-3-直接式方法调用"><a href="#1-3-直接式方法调用" class="headerlink" title="1.3. 直接式方法调用"></a>1.3. 直接式方法调用</h3><p>在 JavaScript 中有两种形式的直接式方法调用：</p>
<ol>
<li>Function.prototype.call( thisValue, arg0?, arg1?, … )</li>
<li>Function.prototype.apply( thisValue, argArray? )</li>
</ol>
<p>call 和 apply 两种方法均在函数上进行调用。这两种方式和一般的函数调用不一样，需要指定 this 的值。call 通过单个参数形式给调用函数提供参数，apply 通过数组的方式提供。</p>
<p>通过动态调度式调用方法有一个问题就是该方法必须在一个对象的原型链上。call() 可以让你指定接受者来直接调用一个方法。这意味着你可以从一个对象中借来一个方法而并不需要存在当前原型链上的。举个栗子：你可以借用Object.prototype.toString 从而使 arr 调用原生的，未被重写的 toString()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call( arr );</span><br></pre></td></tr></table></figure>

<p>方法在一个不同的对象（不只是继承与它们的构造函数）下调用称为通用。说起 JavaScript 中有一系列方法均是通用的。这列表包括许多数组的方法和所有的 Object.prototype 上的方法（它与所有的对象一起工作，从而使隐式的通用）。</p>
<h2 id="2-使用直接式方法调用的实例"><a href="#2-使用直接式方法调用的实例" class="headerlink" title="2. 使用直接式方法调用的实例"></a>2. 使用直接式方法调用的实例</h2><h3 id="2-1-通过数组形式给方法传参"><a href="#2-1-通过数组形式给方法传参" class="headerlink" title="2.1. 通过数组形式给方法传参"></a>2.1. 通过数组形式给方法传参</h3><p>一些方法接受多个参数，但是每个参数只有一个值。那么你时候希望以数组形式进行传参呢？</p>
<p>比如，push() 允许你具有破坏性的将一些值添加到数组中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">arr.push( &#x27;c&#x27;, &#x27;d&#x27; ); // 4</span><br><span class="line">arr; // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure>

<p>但是你不能破坏性的添加一整个数组。你可以通过 apply() 来解决这个限制问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">Array.prototype.push.apply( arr, [ &#x27;c&#x27;, &#x27;d&#x27; ] ); // 4</span><br><span class="line">arr; //  [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure>

<p>类似的，Math.max() 和 Math.min() 也只能使用单个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max( -1, 7 ,2 ); // 7</span><br></pre></td></tr></table></figure>

<p>通过apply()，你可以对他们使用数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply( null, [ -1, 7, 2 ] ); // 7</span><br></pre></td></tr></table></figure>

<h3 id="2-2-一个类数组对象转换成一个数组"><a href="#2-2-一个类数组对象转换成一个数组" class="headerlink" title="2.2. 一个类数组对象转换成一个数组"></a>2.2. 一个类数组对象转换成一个数组</h3><p>在 JavaScript 中一些对象为类数组，它们大致上是数组，但是没有任何数组方法。看下两个例子。</p>
<p>首先，函数的特殊变量 arguments 是类数组， 它有一个 length 和 可以下标访问元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var args = function()&#123; return arguments; &#125;( &#x27;a&#x27;, &#x27;b&#x27; );</span><br><span class="line">args.length; // 2</span><br><span class="line">args[0]; // &#x27;a&#x27;</span><br></pre></td></tr></table></figure>

<p>但是 arguments 并不是 Array 的一个实例，并且没有 forEach() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args instanceof Array; // false</span><br><span class="line">args.forEach; // undefined</span><br></pre></td></tr></table></figure>

<p>其次，DOM 方法 document.querySelectorAll() 返回的 NodeList 实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelectorAll(&#x27;a[href]&#x27;) instanceof NodeList; // true</span><br><span class="line">document.querySelectorAll(&#x27;a[href]&#x27;).forEach; // undefined</span><br></pre></td></tr></table></figure>

<p>再次，一些复杂操作，你需要现将类数组转化成数组形式。这可以通过 Array.prototype.slice() 来实现。该方法将接受者中的元素拷贝出来放置到新的素组中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">arr.slice(); // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">arr.slice() === arr; // fasle</span><br></pre></td></tr></table></figure>

<p>如果直接式调用 slice()，可以将一个 NodeList 转化为一个数组 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var domList = document.querySelectorAll( &#x27;a[href]&#x27; );</span><br><span class="line">var links = Array.prototype.slice.call( domList );</span><br><span class="line">links.forEach(function( link )&#123;</span><br><span class="line">    console.log( link );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以将 arguments 转化为数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function format(pattern) &#123;</span><br><span class="line">    var params = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return params; </span><br><span class="line">&#125;</span><br><span class="line">console.log(format(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)); // [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="2-3-正确是使用-hasOwnPrototype"><a href="#2-3-正确是使用-hasOwnPrototype" class="headerlink" title="2.3. 正确是使用 hasOwnPrototype()"></a>2.3. 正确是使用 hasOwnPrototype()</h3><p>obj.hasOwnPrototype(‘prop’) 可以检测对象 obj 是否有自己（非继承的）的 prop 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; prop: 123 &#125;;</span><br><span class="line">obj.hasOwnProperty(&#x27;prop&#x27;); // true </span><br><span class="line">&#x27;toString&#x27; in obj; // true </span><br><span class="line">obj.hasOwnProperty(&#x27;toString&#x27;); // fasle</span><br></pre></td></tr></table></figure>

<p>然而，如果 Object.prototype.hasOwnPrototype 被覆盖过， 那么通过正确的调度式调用 hasOwnPrototype 可能回发生错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; hasOwnprototype : 123 &#125;;</span><br><span class="line">obj.hasOwnPrototype( &#x27;toString&#x27; );</span><br><span class="line">// TypeError: number is not a function</span><br></pre></td></tr></table></figure>

<p>如果一个对象的原型链上没有Object.prototype，那么通过调度式调用 hasOwnPrototype 可能出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create( null );</span><br><span class="line">obj.hasOwnPrototype( &#x27;toString&#x27; );</span><br><span class="line">// TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>

<p>两者，可以使用直接式调用 hasOwnPrototype 的方法来解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123; hasOwnProperty: 123 &#125;;</span><br><span class="line">Object.prototype.hasOwnProperty.call(obj1, &#x27;hasOwnProperty&#x27;) ; // true </span><br><span class="line">   </span><br><span class="line">var obj2 = Object.create(null);</span><br><span class="line">Object.prototype.hasOwnProperty.call(obj2, &#x27;toString&#x27;) ; // false</span><br></pre></td></tr></table></figure>

<h3 id="2-4-避免中间对象"><a href="#2-4-避免中间对象" class="headerlink" title="2.4. 避免中间对象"></a>2.4. 避免中间对象</h3><p>对字符串应用一个数组的方法，比如 join() 转化，一般有两步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abc&#x27;;</span><br><span class="line">var arr = str.split(&#x27;&#x27;); // step 1</span><br><span class="line">var joined = arr.join(&#x27;-&#x27;); // step 2</span><br><span class="line">console.log( joined ); // a-b-c</span><br></pre></td></tr></table></figure>

<p>字符串是类数组，可以作为数组通用方法的 this 值：<br>因此，直接式的调用可以避免第一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abc&#x27;;</span><br><span class="line">var joined = Array.prototype.join.call( str, &#x27;-&#x27; );</span><br></pre></td></tr></table></figure>

<p>类似的，你可以对字符串分割为数组后，或者通过直接式方法调用来使用 map()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toUpper( x )&#123;</span><br><span class="line">    return x.tiUpperCase();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x27;abc&#x27;.split(&#x27;&#x27;).map( toUpper ); // [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ]</span><br><span class="line">Array.prototype.map.call( &#x27;abc&#x27;, toUpper ); // [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ]</span><br></pre></td></tr></table></figure>

<p>记住，直接式调用可能可以更高效，但是形式是不为优雅。但那是值得的。</p>
<h2 id="3-Object-prototype-和-Array-prototype-简短形式"><a href="#3-Object-prototype-和-Array-prototype-简短形式" class="headerlink" title="3.  Object.prototype 和 Array.prototype 简短形式"></a>3.  Object.prototype 和 Array.prototype 简短形式</h2><p>你可以通过一个空对象字面量（其原型是 Object.prototype）来访问 Object.prototype 的方法。如下面两种直接式方法调用是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.hasOwnPrototype.call( obj, &#x27;propKey&#x27; );</span><br><span class="line">&#123;&#125;.hasOwnPrototype.call( obj, &#x27;propKey&#x27; );</span><br></pre></td></tr></table></figure>

<p>对于 Array.prototype 使用相同方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call( arguments );</span><br><span class="line">[].slice.call( arguments );</span><br></pre></td></tr></table></figure>

<p>这种形式变得颇为流行。相对于较长版本来说，可能没有更好的显示出作者的意图，但是它更为简短，速度方面也并没有很大的差距（译者注： <a target="_blank" rel="noopener" href="http://jsperf.com/array-prototype-slice-vs-slice2">http://jsperf.com/array-prototype-slice-vs-slice2</a> 和 <a target="_blank" rel="noopener" href="http://jsperf.com/object-prototype-tostring-call-vs-tostring">http://jsperf.com/object-prototype-tostring-call-vs-tostring</a> 显然字面量形式肯定会慢一点，要创建完对象或者数组之后再去原型上查询，但是差距并不是很大）。</p>
<h2 id="4-在-ECMAScript-6中-直接式调用的替代方案"><a href="#4-在-ECMAScript-6中-直接式调用的替代方案" class="headerlink" title="4. 在 ECMAScript 6中 直接式调用的替代方案"></a>4. 在 ECMAScript 6中 直接式调用的替代方案</h2><p>感谢 ECMAScript 6 的新特性，你可以不再那么频繁的使用直接式方法调用了。</p>
<h3 id="4-1-扩展操作符-几乎可以替代-apply"><a href="#4-1-扩展操作符-几乎可以替代-apply" class="headerlink" title="4.1.  扩展操作符 几乎可以替代 apply()"></a>4.1.  扩展操作符 几乎可以替代 apply()</h3><p>是我们用过 apply() 使用直接式方法调用的唯一原因是我们要转换一个数组为 arguments 显得比较麻烦，这也是 ECMAScript 6 有了扩展操作符（…）的原因。它为调度式调用方法提供了此功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max( ...[ -1, 7, 2 ] ); // 7</span><br></pre></td></tr></table></figure>

<p>另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">arr.push( ...[&#x27;c&#x27;, &#x27;d&#x27;] ); // 4</span><br><span class="line">arr; // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure>

<p>另一个边界&#x3D;&#x3D;便捷， 扩展在 new 操作符中也是起作用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date( ...[ 2011, 11, 24 ] );</span><br></pre></td></tr></table></figure>

<p>记住，apply() 是无法在 new 操作符中使用，上面的形式需要通过复杂的形式围绕 ECMAScript 5 来实现。</p>
<h3 id="4-2-在-ECMAScript-6-中类数组对象将不再成为累赘"><a href="#4-2-在-ECMAScript-6-中类数组对象将不再成为累赘" class="headerlink" title="4.2. 在 ECMAScript 6 中类数组对象将不再成为累赘"></a>4.2. 在 ECMAScript 6 中类数组对象将不再成为累赘</h3><p>一方面，  ECMAScript 6 拥有 Array.form() 方法，一个转化类数组对象为数组的简单方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let domLinks = document.querySelectorAll( &#x27;a[href]&#x27; );</span><br><span class="line">let links = Array.form( domLinks );</span><br><span class="line">links.forEach(function( link )&#123;</span><br><span class="line">    console.log( link );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另一方面，你不在需要类数组 arguments，因为  ECMAScript 6 可以获取其余参数（三个点声明）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function format( pattern, ...params )&#123;</span><br><span class="line">    return params;</span><br><span class="line">&#125;</span><br><span class="line">console.log( format(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) ); // [ &#x27;b&#x27;, &#x27;c&#x27; ]</span><br></pre></td></tr></table></figure>

<h3 id="4-3-hasOnPrototype"><a href="#4-3-hasOnPrototype" class="headerlink" title="4.3. hasOnPrototype()"></a>4.3. hasOnPrototype()</h3><p>hasOnPrototype()  基本是通过对象实现映射。幸好， ECMAScript 6 中有有了内置的 Map 数据结构，所以可以使你更少的使用 hasOnPrototype()。</p>
<h3 id="4-4-避免中间对象"><a href="#4-4-避免中间对象" class="headerlink" title="4.4. 避免中间对象"></a>4.4. 避免中间对象</h3><p>Array.form() 可以式转换和映射一步完成，也可以在第二个参数传入回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#x27;abc&#x27;, ch =&gt; ch.toUpperCase())</span><br><span class="line">// [ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ] </span><br></pre></td></tr></table></figure>

<p>也可以作为两步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abc&#x27;.split(&#x27;&#x27;).map(function (x) &#123; return x.toUpperCase() &#125;)</span><br><span class="line">//[ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; ]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/07/19/js-decorator-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/07/19/js-decorator-pattern/" class="post-title-link" itemprop="url">JS设计模式七：装饰者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2014-07-20T00:00:00+08:00">2014-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>装饰者模式，Decorator Pattern。在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。</p>
<p><strong>装饰者模式特点：</strong></p>
<ol>
<li>不修改原对象的原本结构来进行功能添加。</li>
<li>装饰对象和原对象具有相同的接口，可以使客户以与原对象相同的方式使用装饰对象。</li>
<li>装饰对象中包含原对象的引用，即装饰对象为真正的原对象在此包装的对象。</li>
</ol>
<p>装饰者模式可以为对象添加功能从而代替了编写大量子类的情况。</p>
<p>以JS设计模式实例为例，首先自行车商店有4种类型自行车：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ABicycle = function()&#123; ... &#125;;</span><br><span class="line">var BBicycle = function()&#123; ... &#125;;</span><br><span class="line">var CBicycle = function()&#123; ... &#125;;</span><br><span class="line">var DBicycle = function()&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>当自行车商店需要为每类自行车推出附加功能或者配件，比如前灯，车篮，改色等的时候，其最基本的方式就是为每一种组合创建一个子类，如有铃铛的A类车，黄色的B类车，有车篮的C类车等等，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ABicycleWithBell = function()&#123; ... &#125;;</span><br><span class="line">var BBicycleWithColorYellow = function()&#123; ... &#125;;</span><br><span class="line">var CBicycleWithColorBule = function()&#123; ... &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>的确，就犹如你第一眼看到的感觉一样，这搞法果断不靠谱，n种配置，到最后就会生成4n+4种类（包括原始的4个父类），那是决然不可取的。</p>
<p>当然我们可能的第一想法便是可以将颜色，车篮什么的设为实例属性，在类中由传递的参数进行控制生成，这样的确不错没什么问题，不过对于一些功能上的扩展可能就心有余而力不足了，比如自行车添加变速功能，刹车加强功能，防盗功能等，那么对于添加这些功能使用装饰者模式则更为简便了（如果说将更能内置于类中，再由传参进行处理，在功能较多的情况下显然也比较不靠谱）。</p>
<p>首先需要一个基础自行车A的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ABicycle()&#123; &#125;</span><br><span class="line">ABicycle.prototype = &#123;</span><br><span class="line">    wash : function()&#123; &#125;,</span><br><span class="line">    ride : function()&#123; &#125;,</span><br><span class="line">    getPrice : function()&#123; </span><br><span class="line">        return 999; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是给自行车装上铃铛，响铃的功能：</p>
<p>最简单的应该就是直接包装对象实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function bicycleBell( bicycle )&#123;</span><br><span class="line">    var price= bicycle.getPrice();</span><br><span class="line"></span><br><span class="line">    bicycle.bell = function()&#123;</span><br><span class="line">        console.log(&quot;ding! ding! ding!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bicycle.getPrice = function()&#123;</span><br><span class="line">            return price + 100;</span><br><span class="line">    &#125;;</span><br><span class="line">    return bicycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bicycleA = new ABicycle();</span><br><span class="line">bicycleA = bicycleBell( bicycleA );</span><br></pre></td></tr></table></figure>

<p>如果是下面这种形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycle.getPrice = function()&#123;</span><br><span class="line">     return bicycle.getPrice() + 100;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种形式当然就会导致无限循环调用~</p>
<p>的确这种包装方法不是将对象再次包装成构造函数，仅仅只是调整实例对象，既方便又简单，不过对于类似getPrice方法这种返回常量数据结果的倒是问题也不大，可以使用如上面闭包形式的方式来保存。</p>
<p>但如果对于其功能的在包装需要调用，再用闭包形式来先进行原始方法的保存，就会赶脚很繁琐不变。</p>
<p>那么可以来看一下下面这种装饰方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function BicycleBell( bicycle )&#123;</span><br><span class="line">    this.bicycle = bicycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BicycleBell.prototype = &#123;</span><br><span class="line">    wash : function()&#123; </span><br><span class="line">        return this.bicycle.wash();</span><br><span class="line">    &#125;,</span><br><span class="line">    ride : function()&#123;</span><br><span class="line">        return this.bicycle.ride();</span><br><span class="line">    &#125;,</span><br><span class="line">    getPrice : function()&#123; </span><br><span class="line">        return this.bicycle.ride() + 100; </span><br><span class="line">    &#125;,</span><br><span class="line">    bell : function()&#123;</span><br><span class="line">        console.log(&quot;ding! ding! ding!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装实例，再次模拟原始类，将实例作为参数包装，提供与原始类一样的接口。这种方式很好的解决了对于某些需要修改并且依赖原始该方法的方法生成形式。当然其也有自己的缺点，这个装饰者太过于繁琐，所有的，比如加速，切换颜色，车篮什么的装饰者每一个都必须如此形式的话势必代码有点杂乱多。</p>
<p>那么，提取出来吧</p>
<p>首先需要有一个继承的方法，并且有指向父类的prototype</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function extend( subClass, superClass )&#123;</span><br><span class="line">    var F = function()&#123;&#125;;</span><br><span class="line">    F.prototype = superClass.prototype;</span><br><span class="line">    subClass.prototype = new F();</span><br><span class="line">    subClass.prototype.constructor = subClass;</span><br><span class="line">    </span><br><span class="line">    // 此处指向superClass的prototype 比直接保存superClass使用更为方便</span><br><span class="line">    subClass.superclass = superClass.prototype;</span><br><span class="line">    if( superClass.prototype.constructor === Object.prototype.constructor )&#123;</span><br><span class="line">        superClass.prototype.constructor = superClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一个各个装饰者可以依赖继承的中间装饰者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function BicycleDecorator( bicycle )&#123;</span><br><span class="line">    this.bicycle = bicycle;</span><br><span class="line">&#125;</span><br><span class="line">BicycleDecorator.prototype = &#123;</span><br><span class="line">    wash : function()&#123; </span><br><span class="line">        return this.bicycle.wash();</span><br><span class="line">    &#125;,</span><br><span class="line">    ride : function()&#123;</span><br><span class="line">        return this.bicycle.ride();</span><br><span class="line">    &#125;,</span><br><span class="line">    getPrice : function()&#123; </span><br><span class="line">        return this.bicycle.ride(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后么很巧妙的使用extend</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var BicycleBell = function( bicycle )&#123;</span><br><span class="line">    // 继承 BicycleDecorator 内部 this定义的数据或者方法</span><br><span class="line">    BicycleBell.superclass.constructor.call( this, bicycle );</span><br><span class="line">&#125;</span><br><span class="line">// 继承 BicycleDecorator.prototype 并且添加 BicycleBell.superclass 指向 BicycleDecorator.prototype</span><br><span class="line">extend( BicycleBell, BicycleDecorator );</span><br><span class="line">// 添加或者修改</span><br><span class="line">BicycleBell.prototype.bell = function()&#123;</span><br><span class="line">    console.log(&quot;ding! ding! ding!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BicycleBell.prototype.getPrice = function()&#123;</span><br><span class="line">    return this.bicycle.getPrice() + 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一样的方式进行实例包装使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bicycleA = new ABicycle();</span><br><span class="line">bicycleA = new BicycleBell( bicycleA );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述方式就是一种较为不错的装饰者模式形式，更完善一些可能需要对BicycleDecorator，以及BicycleDecorator.prototype对象定义时使用对最初类遍历方式来获取各个原有接口。</p>
<p>当然对于这几种方式可以按需进行使用，有针对性的处理才是最有方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/05/14/javascript-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/05/14/javascript-this/" class="post-title-link" itemprop="url">【译】 JavaScript 之 this：看它为何让你斩不断理还乱</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2014-05-15T00:00:00+08:00">2014-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="http://www.2ality.com/2014/05/this.html">http://www.2ality.com/2014/05/this.html</a><br>原文作者：Dr. Axel Rauschmayer</p>
<p>在JavaScript中，特殊变量 this 相对来说较为复杂，因为它不仅仅只在面向对象设定中出现，其随处可见。这里会解释一下 this 的工作原理以及会引起问题的地方，最佳实践总结。</p>
<p>理解 this，最好的方式是区分被使用的三种类型的位置：</p>
<ul>
<li>函数内部：this 是一个额外的隐式的参数。</li>
<li>函数外（顶层作用域）：this 在浏览器中指向全局对象，Node.js中指向一个模块的暴露接口。</li>
<li>在传递给 eval() 的字符串中：eval() 也许会取得当前 this 的值，或者是将其设置为全局对象，取决于是直接或者间接的调用。</li>
</ul>
<p>来看一下各个类型。</p>
<h2 id="1-在函数内部的-this"><a href="#1-在函数内部的-this" class="headerlink" title="1. 在函数内部的 this"></a>1. 在函数内部的 this</h2><p>这是 this 一种最常用的方式，因为在 JavaScript 中，函数以三种不同的角色代表了所有的可调用的结构形式。</p>
<ol>
<li>确切的函数（this 在松散模式中为全局对象，在严格模式中为 undefined ）</li>
<li>构造函数（this 指向新创建的实例）</li>
<li>方法（this 指向方法调用的接受者）</li>
</ol>
<p>在函数中，this 被常常认为是一个额外的隐式的参数。</p>
<h3 id="1-1-在确切的函数中的-this"><a href="#1-1-在确切的函数中的-this" class="headerlink" title="1.1 在确切的函数中的 this"></a>1.1 在确切的函数中的 this</h3><p>在确切的函数中，this 的值依赖于其所在的模式：</p>
<p><strong>松散模式：this 指向全局对象（浏览器下为windows）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sloppyFunc()&#123;</span><br><span class="line">    console.log( this === window )</span><br><span class="line">&#125;</span><br><span class="line">sloppyFunc();</span><br></pre></td></tr></table></figure>

<p><strong>严格模式：this 的值为 undefined</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function strictFunc()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log( this === undefined );</span><br><span class="line">&#125;</span><br><span class="line">strictFunc();</span><br></pre></td></tr></table></figure>

<p>就是说，this 是一个隐式的，设置有默认值（window 或者 undefined）的参数。但是，你可以使一个函数通过 call() 或者 apply() 调用来明确的指定 this 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function func( arg1, arg2 )&#123;</span><br><span class="line">    console.log( this );</span><br><span class="line">    console.log( arg1 );</span><br><span class="line">    console.log( arg2 );</span><br><span class="line">&#125;</span><br><span class="line">func.call( &#123; a:&#x27;a&#x27; &#125; , &#x27;b&#x27;, &#x27;c&#x27; ); </span><br><span class="line">// Object &#123;a: &quot;a&quot;&#125;</span><br><span class="line">// b</span><br><span class="line">// c</span><br><span class="line">func.apply( &#123; a:&#x27;a&#x27; &#125; , [ &#x27;b&#x27;, &#x27;c&#x27; ]); </span><br><span class="line">// Object &#123;a: &quot;a&quot;&#125;</span><br><span class="line">// b</span><br></pre></td></tr></table></figure>

<h3 id="1-2-在构造函数中的-this"><a href="#1-2-在构造函数中的-this" class="headerlink" title="1.2 在构造函数中的 this"></a>1.2 在构造函数中的 this</h3><p>你通过 new 操作符来调用的函数即是构造函数，该操作符创建一个新的对象，并把它通过 this 传递给构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var savedThis;</span><br><span class="line">function Constr()&#123;</span><br><span class="line">    savedThis = this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inst = new Constr();</span><br><span class="line">console.log( savedThis === inst );</span><br></pre></td></tr></table></figure>

<p>new 操作符使用 JavaScript 实现大致如下（一个更为准确复杂的实现 <a target="_blank" rel="noopener" href="http://speakingjs.com/es5/ch17.html#_the_new_operator_implemented_in_javascript%EF%BC%89%EF%BC%9A">http://speakingjs.com/es5/ch17.html#_the_new_operator_implemented_in_javascript）：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function newOperator( Constr, arrayWithArgs )&#123;</span><br><span class="line">    var thisValue = Object.creat( Constr.prototype );</span><br><span class="line">    Constr.apply( thisValue, arrayWithArgs );</span><br><span class="line">    return thisValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-方法中的-this"><a href="#1-3-方法中的-this" class="headerlink" title="1.3 方法中的 this"></a>1.3 方法中的 this</h3><p>在方法中，所有的事情都和传统的面向对象语言类似： this 指向接受者，即方法被调用的那个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    method : function()&#123;</span><br><span class="line">        console.log( this === obj );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method();</span><br></pre></td></tr></table></figure>

<h2 id="2-顶级作用域的-this"><a href="#2-顶级作用域的-this" class="headerlink" title="2. 顶级作用域的 this"></a>2. 顶级作用域的 this</h2><p>在浏览器环境中，顶级作用域是全局作用域， this 指向全局作用域（诸如 window 之类）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log( this === window ); // true</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在 Node.js 中，你基本在模块中编写代码。那么当前顶级作用局就是一个特定的模块作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// （在 Node.js 的具体模块中）</span><br><span class="line">// &#x27;global&#x27;（非 window） 指向全局对象</span><br><span class="line">console.log( Math === global.Math ); // true</span><br><span class="line"></span><br><span class="line">// &#x27;this&#x27; 并不指向全局对象</span><br><span class="line">console.log( this !== global ); // true</span><br><span class="line">// &#x27;this&#x27; 指向模块的暴露接口</span><br><span class="line">console.log( this === module.exports );</span><br></pre></td></tr></table></figure>

<h2 id="3-eval-中的-this"><a href="#3-eval-中的-this" class="headerlink" title="3. eval() 中的 this"></a>3. eval() 中的 this</h2><p>eval() 既可以被直接调用（通过一个确切的方法调用）也可以被间接调用（通过另一些方式）。以下是具体解释。</p>
<p>如果 eavl() 被间接调用， this 指向全局对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 0, eval )( &quot; this === window&quot; );</span><br></pre></td></tr></table></figure>

<p>否者，如果 eval() 被直接调用，那么 this 指向 eval() 所处的执行环境。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function sloppyFunc()&#123;</span><br><span class="line">    console.log( eval(&quot;this&quot;) === window );</span><br><span class="line">&#125;</span><br><span class="line">sloppyFunc(); // true</span><br><span class="line"></span><br><span class="line">function strictFunc()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log( eval(&quot;this&quot;) === undefined );</span><br><span class="line">&#125;</span><br><span class="line">strictFunc(); // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var savedThis;</span><br><span class="line">function Constr()&#123;</span><br><span class="line">    savedThis =eval(&quot; this&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inst = new Constr();</span><br><span class="line">console.log( savedThis === inst ); // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    method : function()&#123;</span><br><span class="line">        console.log( eval(&quot;this&quot;) === obj );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method();</span><br></pre></td></tr></table></figure>

<h2 id="4-this-的相关陷阱"><a href="#4-this-的相关陷阱" class="headerlink" title="4. this 的相关陷阱"></a>4. this 的相关陷阱</h2><p>这里有3个值得注意的和 this 有关的陷阱。 记住，严格模式可以使得每种情况变得正常，因为在确切的函数中 this 都会为 undefined ，当出错的时候会得到警告。</p>
<h3 id="4-1-忘记-new"><a href="#4-1-忘记-new" class="headerlink" title="4.1 忘记 new"></a>4.1 忘记 new</h3><p>如果你调用构造函数却忘记了 new 操作符，那么你会意外的调用一个实实在在的函数。故而， this 就不会指向当前值。在松散模式中，this 指向window，并且会创建全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Point( x, y )&#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Point( 7, 5 ); // 忘记 new 操作符</span><br><span class="line">console.log( p === undefined ); // true</span><br><span class="line"></span><br><span class="line">//创建全局变量</span><br><span class="line">console.log( x ); // 7</span><br><span class="line">console.log( y );</span><br></pre></td></tr></table></figure>

<p>幸亏有严格模式，你可以获取到警告（this &#x3D;&#x3D;&#x3D; undefined）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Point( x, y )&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = Point( 7, 5 );</span><br></pre></td></tr></table></figure>

<h3 id="4-2-获取方法不当"><a href="#4-2-获取方法不当" class="headerlink" title="4.2 获取方法不当"></a>4.2 获取方法不当</h3><p>如果你获取方法的值（而非调用），你会将方法又转变为函数。结果值的调用为函数的调用而非方法的调用。这种获取方式发生在你将一个方法作为参数传递给一个函数或者方法的时候。实际环境中的例子包括 setTimeout() 和 时间注册处理程序。这边会使用函数 callIt() 来同时模拟用例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 与 setTimeout() 和 setImmediate() 类似 */</span><br><span class="line">function callIt( func )&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你调用一个松散模式下的函数， this 指向全局对象，并且创建全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">    count : 0,</span><br><span class="line">    inc : function()&#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">callIt( counter.inc );</span><br><span class="line"></span><br><span class="line">console.log( counter.inc ); // 0, 无效</span><br><span class="line">console.log( count );</span><br></pre></td></tr></table></figure>

<p>如果你调用严格模式下的函数，this 为undefined， 代码也将会无效。但是会得到一个警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">    count : 0,</span><br><span class="line">    inc : function()&#123;</span><br><span class="line">        &quot;use strict&quot;;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">callIt( counter.inc );</span><br></pre></td></tr></table></figure>

<p>可以使用 bind() 开解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var counter = &#123;</span><br><span class="line">    count : 0,</span><br><span class="line">    inc : function()&#123;</span><br><span class="line">        &quot;use strict&quot;;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">callIt( counter.inc.bind( counter ) ); </span><br><span class="line">console.log( counter.count );</span><br></pre></td></tr></table></figure>

<p>bind() 创建一个接受的 this 值为 counter 的新函数。</p>
<h3 id="4-3-this-跟踪"><a href="#4-3-this-跟踪" class="headerlink" title="4.3 this 跟踪"></a>4.3 this 跟踪</h3><p>当你使用一个确实的函数来代替方法，很容易忘记前者是有自己的 this值（尽管经常不使用）。因此你无法将前者的 this 指向方法的 this，由于它是跟踪状态的。看一下出错的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name : &#x27;Jane&#x27;,</span><br><span class="line">    friends : [ &#x27;Tarzan&#x27;, &#x27;Cheeta&#x27;],</span><br><span class="line">    loop : function()&#123;</span><br><span class="line">        &#x27;use strict&#x27;;</span><br><span class="line">        this.friends.forEach(function( friend )&#123;</span><br><span class="line">            console.log( this.name + &#x27; knows &#x27; + friend );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.loop(); // TypeError: Cannot read property &#x27;name&#x27; of undefined</span><br></pre></td></tr></table></figure>

<p>在上面例子中，this.name 获取出错，原因是函数的 this为undefined，他与方法 loop() 内的 this 不一样，来看看3中解决方案。</p>
<p><strong>解决方案1： that &#x3D; this。</strong>将 this 设置给一个变量，使其不再跟踪状态（另一个常用的变量名为 self）再使用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop : function()&#123;</span><br><span class="line">        &#x27;use strict&#x27;;</span><br><span class="line">        var that = this;</span><br><span class="line">        this.friends.forEach(function( friend )&#123;</span><br><span class="line">            console.log( that.name + &#x27; knows &#x27; + friend );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案2：bind()。</strong>使用 bind() 来创建一个 this 常指向当前值的函数（下面实例方法的 this）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop : function()&#123;</span><br><span class="line">        &#x27;use strict&#x27;;</span><br><span class="line">        this.friends.forEach(function( friend )&#123;</span><br><span class="line">            console.log( this.name + &#x27; knows &#x27; + friend );</span><br><span class="line">        &#125;.bind( this ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案3：forEach 的第二个参数。</strong>该方法有第二个参数用来传递回掉函数在某一目标上进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loop : function()&#123;</span><br><span class="line">        &#x27;use strict&#x27;;</span><br><span class="line">        this.friends.forEach(function( friend )&#123;</span><br><span class="line">            console.log( this.name + &#x27; knows &#x27; + friend );</span><br><span class="line">        &#125;, this );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><p>概念上来说，我认为确实的函数并不具有它们自己的 this，认为上述解决方案只是保持这个错觉。ECMAScript 6通过箭头函数来支持 this 的方法，函数没有其自己的 this 值。使用这些函数，你可以无忧无虑的使用 this，因为不会跟踪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loop : function()&#123;</span><br><span class="line">        &#x27;use strict&#x27;;</span><br><span class="line">        // forEach 的参数就是箭头函数</span><br><span class="line">        this.friends.forEach( friend =&gt;&#123;</span><br><span class="line">            // &#x27;this&#x27; 就是 loop 的 &#x27;this&#x27;</span><br><span class="line">            console.log( this.name + &#x27; knows &#x27; + friend );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我不喜欢 APIs 中像一些普通函数的参数那样使用 this：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(function()&#123;</span><br><span class="line">    this.addMatchers(&#123;</span><br><span class="line">        toBeInRange : function()&#123; ... &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>箭头函数将一个隐式的参数转变为显式的，使得行为更为明确和兼容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeEach( api =&gt; &#123;</span><br><span class="line">    api.addMatchers(&#123;</span><br><span class="line">        toBeInRange : function()&#123; ... &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/05/12/adapter-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/05/12/adapter-pattern/" class="post-title-link" itemprop="url">JS设计模式六：适配器模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2014-05-13T00:00:00+08:00">2014-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>适配器模式在维基百科上的属于 Wrapper function 包装函式，其目的是用来呼叫另一个函式。在面向对象编程中，又被称为方法委任，method delegation。而适配器模式可以说是包装函式其中一种功能形式的存在。</p>
<p>简单的说，适配模式主要是为了解决一些接口不兼容产生的解决方法。借助于适配器我们可以在不修改这些不兼容接口的情况下给使用者提供统一的包装过的适配接口。表面上又感觉和之前的门面模式比较像，均是对其他对象或者接口进行包装再呈现，而适配器模式偏向的是解决兼容性问题，门面模式则偏向方便性为原则。</p>
<p>比如一个简单的学生查询学科成绩的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function selectScore( name, id, course_id )&#123;</span><br><span class="line">    // arguments 姓名 学号 课程id</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我需要一个班级某门学科的整体成绩列表，而我手上只有每个学生如下的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; name: &#x27;lily&#x27;, studentID: &#x27;0911&#x27; &#125;,</span><br><span class="line">    &#123; name: &#x27;suny&#x27;, studentID: &#x27;0912&#x27; &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我需要查询 英语 其课程ID为  101，那么对于该任务，写一个适配器方式是很恰当不过的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function selectEnglishScore( stutentObj )&#123;</span><br><span class="line">    selectScore( stutentObj.name, stutentObj.studentID , 101);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个最简单的关于适配器来处理参数方面兼容的形式。</p>
<p>适配器模式可以想象为我们日常生活中经常使用的接口转换器，实现两个或者多个不同的数据存储器进行数据交换，适配各自不同数据输出口的工具，比如以前的一些PS2插口， USB接口，以及当前SD卡，移动硬盘各式各样的接口，接**换器是一件灰常有用的小工具。适配器模式的方法也是如此。</p>
<p>其实简单的来说，适配器模式意义上很简单 - 适配，解决兼容问题。对于应用场景来说，主要是为了解决新旧代码之间不想重构而实行的中庸的方式，或者更换一些类库，升级不兼容版本类库的时候的一种“懒惰”方法。对于适配器模式的确会造成一些不同的看法，比如说原本是需要完全重构的代码却使用了几个简单的适配器模式方法就搪塞过去了。随着这些行为的越来越过，使得代码的质量日渐不足，甚至令后来的程序猿感到愤愤不已。</p>
<p>所以对于适配器模式使用的情况我们需要做好多方面的考虑，其实对于所谓的程序设计模式而言均是如此。原本是为了优化而做的工作，可别到头来适得其反。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/04/08/facade-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/04/08/facade-pattern/" class="post-title-link" itemprop="url">JS设计模式五：门面模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-04-09 00:00:00" itemprop="dateCreated datePublished" datetime="2014-04-09T00:00:00+08:00">2014-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>拖拖拖拖啦啦啦啦啦~ n久未更新更新JS设计模式了，不能回家墓祭祖先，那就在此墓祭墓祭JS吧，T T（本文实例主要来自 JavaScript设计模式）。</p>
<p>之前在桥接模式中简单的说过（额，桥接模式有点混，下次再写一写），门面模式本质是实现一个简单的统一接口来处理对各个子系统接口的处理和调用。其和桥接模式的不同之处便在于桥接模式中的各个类是完全独立的，桥接模式只在必要的时候将这些类关联起来。</p>
<p>而门面模式则有点不同。门面模式其实可以很形象的比作为一家咖啡店的店面窗口，客户只需要说明自己是需要摩卡还是白咖啡，也就是说咖啡店提供给客户的只是各类咖啡的选择接口，而将内部的各个子类行为封装起来，比如磨咖啡豆，冲泡，加奶等过程并不展现给客户，因为每一种咖啡有其不同的生产形式，这样也使得客户更方便的选择所喜欢的咖啡。</p>
<p>门面模式的优点就在于我们将客户与较为复杂的子系统方法和接口分离开来，降低用户与各个子系统间耦合度来提高代码质量。</p>
<p><img src="http://image.freefe.cc/20170306195916.png"></p>
<p>下面是一个纯粹形式化的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a(x)&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line">function b(y)&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line">function ab( x, y )&#123;</span><br><span class="line">    a(x);</span><br><span class="line">    b(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然形式上与桥接模式有很大程度上的类似，下面的小例子可以感受下其和桥接模式的不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var N = window.N || &#123;&#125;;</span><br><span class="line">N.tools = &#123;</span><br><span class="line">    stopPropagation : function( e )&#123;</span><br><span class="line">        if( e.stopPropagation )&#123;</span><br><span class="line">            e.stopPropagation();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            e.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    preventDefault : function( e )&#123;</span><br><span class="line">        if( e.preventDefault )&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            e.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    stopEvent : function( e )&#123;</span><br><span class="line">        N.tools.stopPropagation( e );</span><br><span class="line">        N.tools.preventDefault( e );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个小的阻止事件冒泡以及阻止默认事件工具方法，从其代表性的 stopEvent 不难看出其实质与桥接模式的区别。其上面两个方法 stopPropagation 和 preventDefault 很会令人觉得类似于适配器模式，的确是很类似与适配器模式，不过适配器模式的主要针对于将接口进行适配包装，使其适用于各种不同兼容性的环境。按本人的理解则是，如果提供兼容性的信息使其方法在不同环境下生成不同的方法，比如一些匿名自调用函数根据判断返回不同函数的类似形式，而不是说每次运行再在函数内部进行判断运行，则称其为适配器模式可能为更恰当一些~</p>
<p>对于门面模式的一大好处就是对函数的组合上，犹如上面纯粹模式的例子，门面模式形成的组合函数又称为便利函数（convenience function），便利，便利，便利，好吧，可能对于门面模式的概念又要模糊了，来一例:</p>
<p>我们需要将id为content的div元素设置文本颜色 red，那么简单的代码,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&#x27;content&#x27;);</span><br><span class="line">content.style.color = &#x27;red&#x27;;</span><br><span class="line">//如还想设置字体大小为20px</span><br><span class="line">content.style.fontSize = &#x27;20px&#x27;;</span><br><span class="line"></span><br><span class="line">那么当有一个元素需要设置多种属性时，</span><br><span class="line"></span><br><span class="line">function setStyles( id, styles )&#123;</span><br><span class="line">    var element = document.getElementById( id );</span><br><span class="line">    for( var key in styles )&#123;</span><br><span class="line">        if( styles.hasOwnProperty( key ) )&#123;</span><br><span class="line">            element.style[ key ] = styles[ key ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setStyles( &#x27;content&#x27;, &#123;</span><br><span class="line">    color : &#x27;red&#x27;，</span><br><span class="line">    fontSize : &#x27;20px&#x27;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>setStyles就相当于一个便利函数，也可以视作为门面元素，不过是相对于最简单一类。</p>
<p>如果说是具有好几个元素，均需要设置相同的一批属性的话，那么将 setStyles 包装一下，将其嵌入在另一个门面元素之中，组合成为一个结构相对复杂的门面模式实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function setCSS( ids, styles )&#123;</span><br><span class="line">    for( var i = 0,len = ids.length; i&lt;len; i++ )&#123;</span><br><span class="line">         setStyles( ids[i], styles );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从setCSS中可以看出，对于使用setCSS的用户来说，根本不知道其内部的 setStyles 代码形式。可想而知，当一块代码逻辑较为复杂，调用许多各个接口等的时候，我们使用门面模式将其封装，可以带来很大的便利性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>门面模式大致上可以分为两个小类， 某块代码反复出现，比如函数a的调用基本都出现在函数b的调用之前（虽然基本上没有那么简单的形式），那么你可以考虑考虑将这块代码使用门面实例包装包装来优化结构。还有一种即是对于一些浏览器不兼容的API，放置在门面模式内部进行判断，处理这些问题最好的方式便是将跨浏览器差异全部集中放置到一个门面模式实例中来提供一个对外接口。</p>
<p>当然也需要很注意的是，对于门面模式的滥用其产生的结果是超级严重的，不但是代码整体结构感觉较为散架，还是代码可读性严重降低，不寻找一处BUG可能需要从一个门面实例中找到另一个，再联系到第三第四个，会使代码维护的程序崽子非常反感的~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2014/03/04/node-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/03/04/node-buffer/" class="post-title-link" itemprop="url">node之Buffer 介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-03-05 00:00:00" itemprop="dateCreated datePublished" datetime="2014-03-05T00:00:00+08:00">2014-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好吧，本以为node中的Buffer只是nodeJS中挺小的一块，仔细的翻阅了一些资料之后才发现，冰川总是将其巨大的屁股藏在海平面以下的，这次也是主要简单的讲一下关于Buffer比较浅的一些东西（针对Node初学者啦~）</p>
<h2 id="Buffer-是什么？"><a href="#Buffer-是什么？" class="headerlink" title="Buffer 是什么？"></a>Buffer 是什么？</h2><p>对于JavaScript来说，对Unicode编码的数据很容易处理的，但是对于二进制数据就没什么处理方法了。</p>
<p>但是在一些TCP数据流或者在操作一些文件数据流的时候，字节流的处理方法还是必须的。</p>
<p>nodeJS中便出了处理的策略方法~提供了与String类似对等的全局构造函数Buffer（与其说与String对等，还不如说与Array类似但是有些不同方面还是需要注意），全局那么自然就不要每次的require了。</p>
<blockquote>
<p>Buffer则node中储存二进制数据的中介者。</p>
</blockquote>
<p><strong>创建Buffer实例的方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Buffer( size );</span><br></pre></td></tr></table></figure>

<p>和数组类似，给定所需要创建Buffer对象的大小。</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_13957579146WFB.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Buffer( array );</span><br></pre></td></tr></table></figure>

<p>给定二进制数据的一个数组形式排列</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758011Knm0.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Buffer( str, [ encoding ] );</span><br></pre></td></tr></table></figure>

<p>给与某一特定数据类型数据，以及其编码类型（默认均为utf8）</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_13957580902cvk.png"></p>
<p><strong>以及还有一些操作Buffer实例的方法：</strong></p>
<p>一个Buffer的形式非常类似于一个整数数组，与字符串还是有一定的区别的。</p>
<p>JS程序员都比较熟悉，对于字符串来说可以视为可读的，每次的修改，复制都会得到一个新的字符串，不会影响之前的字符串，就如有一个字符串a，将 var b &#x3D; a;  a 和 b 是各会拥有独立的一份字符串数据，相互独立，与对象类似于指针的形式不同（按值传递和按址传递）。</p>
<p>不过对于字符串的兄弟Buffer来说，作为对象的Buffer含有的Array的血更多一点。</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758215FBRf.png"></p>
<p>但是对于Buffer的一些方法进行使用的时候，还是需要注意其和数组一些不一致的地方</p>
<p> <img src="http://blog.chinaunix.net/attachment/201403/25/26672038_139575828735ZY.png"></p>
<p>在将创建的Buffer截取一段之后，对返回的Buffer段进行修改，还是会影响原Buffer，两者仍是关联的。这类似于一个储存一个个对象的数组，Buffer这个类数组中每一个元素非原始值，而是引用值。</p>
<p>对于希望复制一份独立的Buffer拷贝，Buffer提供了专门的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]);</span><br></pre></td></tr></table></figure>

<p>相对来说并没有直接的直接拷贝副本的方法，只能新建一个长度相等的Buffer，然后在原Buffer上调用copy方法，参数中还可以设置copy的启事与结束位置等。</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758328p0MA.png"></p>
<p>对于更多的信息可以查看node的Buffer文档  <a target="_blank" rel="noopener" href="http://nodejs.org/api/buffer.html">http://nodejs.org/api/buffer.html</a></p>
<h2 id="什么时候才需要使用Buffer"><a href="#什么时候才需要使用Buffer" class="headerlink" title="什么时候才需要使用Buffer"></a>什么时候才需要使用Buffer</h2><p>好了，以上就是对Buffer的简单介绍，其实那都是虚的，什么时候才需要使用Buffer呢？</p>
<p>其实之前已经说过在Node中，许多地方的数据流均是使用的Buffer类型，以便于来处理一些二进制数据（比如读取文件数据，http请求中的post传递的数据等）。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">var rs = fs.createReadStream(&#x27;chinese.md&#x27;);</span><br><span class="line">rs.on(&quot;data&quot;, function (chunk)&#123;</span><br><span class="line">    console.log( Buffer.isBuffer( chunk ) )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758505cPtf.png"></p>
<p>从上面可知其均为 Buffer 类型片段，那么在一些情况下也会使得我们遇到一些隐藏的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">var rs = fs.createReadStream(&#x27;chinese.md&#x27; , &#123; highWaterMark: 5 &#125; );</span><br><span class="line">var data = &#x27;&#x27;;</span><br><span class="line">rs.on(&quot;data&quot;, function (chunk)&#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(&quot;end&quot;, function () &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758607bh1H.png"></p>
<p>会出现乱码现象，无法正常显示。</p>
<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_13957586459cC7.png"></p>
<p>一个中文字占了3个Buffer单位，但是在数据流分块的时候将一个中文的3个标识分开，再做 toString的时候救会发生出现这种乱码的情况。解决方式就是在拿到的分块数据千万不能直接进行类似toString式转义，将每段Buffer保存，最后合并成一个大的Buffer后在进行转义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">var rs = fs.createReadStream(&#x27;chinese.md&#x27;, &#123; highWaterMark: 5 &#125; );</span><br><span class="line">var dataArr = [], len = 0, data;</span><br><span class="line">rs.on(&quot;data&quot;, function (chunk)&#123;</span><br><span class="line">    dataArr.push(chunk);</span><br><span class="line">    len += chunk.length;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(&quot;end&quot;, function () &#123;</span><br><span class="line">    data = Buffer.concat( dataArr, len ).toString();</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_1395758710m428.png"></p>
<p>上述实例中我们可能还发现一个问题，将 { highWaterMark: 5 } 参数去掉后其实两个均没有问题，原因是因为默认的stream中切割data块单位是8K，所以可以在一个单位内容下这个小实例，所以没什么问题。一旦说数据很大，那么也会有相应的问题了。（之前一直拿txt测试了好久，发现怎么也不对，发现是编码方式问题）。</p>
<p>顺便说一下在拼接性能方面，其实Buffer与String相比并不是很差：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var buf = new Buffer(&#x27;this is text concat test&#x27;),</span><br><span class="line">	  str = &#x27;this is text concat test&#x27;;</span><br><span class="line">console.time(&#x27;buffer concat test&#x27;);</span><br><span class="line">var list = [];</span><br><span class="line">var len= 100000 * buf.length;</span><br><span class="line">for(var i=0;i&lt;100000;i++)&#123;</span><br><span class="line">    list.push(buf);</span><br><span class="line">    len += buf.length;</span><br><span class="line">&#125;</span><br><span class="line">var s1 = Buffer.concat(list, len).toString();</span><br><span class="line">console.timeEnd(&#x27;buffer concat test&#x27;);</span><br><span class="line">console.time(&#x27;string concat test&#x27;);</span><br><span class="line">var list = [];</span><br><span class="line">for (var i = 100000; i &gt;= 0; i--) &#123;</span><br><span class="line">    list.push(str);</span><br><span class="line">&#125;</span><br><span class="line">var s2 = list.join(&#x27;&#x27;);</span><br><span class="line">console.timeEnd(&#x27;string concat test&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201403/25/26672038_13957587702EjN.png"></p>
<p>好吧，我承认写的有点不耐烦了，那么就这样吧，相当于简单的做个标签，有需要再查吧~ 哦吼吼~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/06/25/javascript-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/06/25/javascript-note-1/" class="post-title-link" itemprop="url">编写可维护的JavaScript笔记（1-3章）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-06-26 00:00:00" itemprop="dateCreated datePublished" datetime="2013-06-26T00:00:00+08:00">2013-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 22:59:59" itemprop="dateModified" datetime="2022-03-14T22:59:59+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一部分-编程风格"><a href="#第一部分-编程风格" class="headerlink" title="第一部分 编程风格"></a>第一部分 编程风格</h3><p>每个人都有自己独特的编程风格，有情有独钟亦或恨之入骨的，每个人都希望用自己的方式制定规范来实施。这些应当被归为个人编程嗜好。我们需要的是在编程过程中尽早的确定统一的编程风格。 在团队开发中，编程风格一致性变得尤为重要，因为： 1 任何开发者都不在乎某个文件的作者是谁，也没有必要花费额外的精力去理解代码的逻辑并且重新排版，因为所有代码的排版风格都是非常一致的，因为风格不一致会导致我们打开代码文件的第一件事情不是立即工作，而是进行缩进的排版整理。 2 能很容易的辨别出有问题的代码并且发现错误，如果所有的代码风格很像，当看到一段与众不同的代码时，很肯能问题就出在这里。</p>
<blockquote>
<p>JSLint 和 JSHint 是两个检查编程风格的工作。不仅找出代码中潜在的错误，还能对潜在的风格问题给予提示警告。 “程序是写给人读的，只是偶尔让计算机执行一下” - Donald Knuth</p>
</blockquote>
<h3 id="第一章-基本的格式化"><a href="#第一章-基本的格式化" class="headerlink" title="第一章 基本的格式化"></a>第一章 基本的格式化</h3><p>编程风格的核心就是基本的格式化规范，这些规范决定着如何编写高水准的代码。</p>
<h4 id="1-1-缩进层级"><a href="#1-1-缩进层级" class="headerlink" title="1.1 缩进层级"></a>1.1 缩进层级</h4><p>所有语言都是如此，都会讨论如何对代码缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line">for(var i=0; i&lt;wl.length;i++)&#123;</span><br><span class="line">p = wl[i];</span><br><span class="line">        type=Y.Lang.type(wl[i]);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微编写过程序的都不会使用上面的格式，害人害己。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line">        for(var i=0; i&lt;wl.length;i++)&#123;</span><br><span class="line">                p = wl[i];</span><br><span class="line">                type=Y.Lang.type(wl[i]);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码应该如何统一缩进其实一直没有统一的共识。</p>
<ul>
<li>使用制表符缩进 。</li>
<li>使用空格缩进。</li>
</ul>
<blockquote>
<p>jQuery 明确规定使用制表符缩进。 Dauglas Crockford 的 JavaScript 规定使用4个空格缩进。 Google 的 JavaScript规定使用2个空格缩进。 Dojo 编程风格指南使用制表符缩进。</p>
</blockquote>
<p>尼古拉斯（作者）建议4个空格，或在编辑器中设置一个 制表符 替换为 4个空格。为一个缩进层。</p>
<h4 id="1-2-语句结尾"><a href="#1-2-语句结尾" class="headerlink" title="1.2 语句结尾"></a>1.2 语句结尾</h4><p>强制规定，语句结束插入分号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">        return</span><br><span class="line">        &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就会引起问题。</p>
<h4 id="1-3-行的长度"><a href="#1-3-行的长度" class="headerlink" title="1.3 行的长度"></a>1.3 行的长度</h4><p>很少有JS的规范提及到行的长度的风格的，很多语言都建议行的字数不超过 80 字，因为很早以前的编辑器，这是最大的行长度。</p>
<blockquote>
<p>Java语言规范中 源码单行长不超过 70 字，文档中单行长不超过 80 字。 Android开发者规范中规定不超过 100 字。 非官方的Ruby规定不操过 80 字。 Python编程规范规定单行不超过 79 字。</p>
</blockquote>
<p>JavaScript 在 Crockford 代码规范中规定为 80 字符。</p>
<h4 id="1-4-换行"><a href="#1-4-换行" class="headerlink" title="1.4 换行"></a>1.4 换行</h4><p>当一行字字符数超过了最大限制的时候就需要换行。通常会在运算符之后换行，下一行会增加2个层级的缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callFunction(document,&quot;aaaaaaaaaaaaaaa&quot;,&quot;bbbbbbbbbbbbbbbb&quot;,&quot;cccccccccccccccccccc&quot;,</span><br><span class="line">    &quot;bbbbbbbbbbbbbbbbbbb&quot;);//超出首字母c的2个层级</span><br></pre></td></tr></table></figure>

<p>需要注意的是规范为在运算符之后换行，以及增加2个层级的缩进。 当然如果是赋值的话就保持赋值运算符对其。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;aaaaaaaaaaaaaaaa&quot; + &quot;bbbbbbbbbbbbbbbb&quot; + &quot;ccccccccccccccccccc&quot; +</span><br><span class="line">                         &quot;ddddddddddddddddddddddddd&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-空行"><a href="#1-5-空行" class="headerlink" title="1.5 空行"></a>1.5 空行</h4><p>空行常常被忽略，但是空行也是提高代码可读性的强大武器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line"></span><br><span class="line">        for(var i=0; i</span><br><span class="line"></span><br><span class="line">                p = wl[i];</span><br><span class="line">                type=Y.Lang.type(wl[i]);</span><br><span class="line"></span><br><span class="line">                if(a)&#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空行一般来说不是很好在规范中规定，</p>
<ul>
<li>方法之间</li>
<li>方法中局部变量可第一条语句之间。</li>
<li>多行或者单行注释之前。</li>
<li>在方法内的逻辑片段之前。</li>
</ul>
<p>目前没有规范对空行进行明确的规定。</p>
<h3 id="1-6-命名"><a href="#1-6-命名" class="headerlink" title="1.6 命名"></a>1.6 命名</h3><blockquote>
<p>“计算机科学只存在两个难题：缓存失效和命名” - Phil Karlton</p>
</blockquote>
<p>只要写代码就会涉及到变量和函数，所以变量和函数的命名对于增强代码的可读性至关重要。 JavaScripe 遵循 ECMA ，即驼峰式大小写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myName;</span><br><span class="line">var anotherName;</span><br></pre></td></tr></table></figure>

<p>google Dojo等规范都规定使用小驼峰命名法。，当然还有一种曾经风光一时的 匈牙利命名法。 <code>1.6.1 变量和函数</code> 变量名总是应该遵循驼峰大小写命名法，并且命名的前缀应当是名词，使得可以将变量和函数区分开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以下OK</span><br><span class="line">var count = 10;</span><br><span class="line">var myName = &quot;Ni&quot;;</span><br><span class="line">var found = true;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 以下就需要重新命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var getCount = 10;</span><br><span class="line">var isFound = true;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;函数应当以动词开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var getName  = function()&#123;</span><br><span class="line">        return myName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一点示范</p>
<blockquote>
<p>can 函数返回布尔值 has 函数返回布尔值 is 函数返回布尔值 get 函数返回非布尔值 set 函数用来保存值</p>
</blockquote>
<p><code>1.6.2 常量</code> JS中没有常量的概念。来自C语言的约定，常量使用大写字母并且使用下划线命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var MAX_COUNT = 10；</span><br><span class="line">var URL = &quot;http://www.guokr.com&quot;;</span><br></pre></td></tr></table></figure>

<p>google Dojo 等编程风格指南都规定如此。 <code>1.6.3 构造函数</code> JS中的构造函数只不过是冠以 new 运算符的函数而已。采用大驼峰命名法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person( name )&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-直接量"><a href="#1-7-直接量" class="headerlink" title="1.7 直接量"></a>1.7 直接量</h4><p>JS中的原始值：字符串、数字、布尔值、null和underfined。 <code>1.7.1 字符串</code> JS中的字符串使用双引号和单引号是完全相同的。对于规范只需要统一即可。 jQuery 和 Crockford规范为双引号来括住字符串，google规范为单引号括住字符串。 <code>1.7.2 数字</code> JS中整数和浮点数都存储为相同的数据类型。 不推荐使用 10. 和 .1 的写法。会产生歧义，是否是我们漏掉了数字。</p>
<p><code>1.7.3 null</code> null 常会与 undefined 搞混淆。以下场景才应当使用null：</p>
<ul>
<li>用来初始化变量，该变量可能被赋值为对象。</li>
<li>用来和一个已经初始化的变量进行比较，这个变量可以是非对象。</li>
<li>当函数期望的参数是对象，用作参数传入。</li>
<li>当函数的返回值期望是对象时，用作返回值传出。</li>
</ul>
<p>以下场景不应当使用 null：</p>
<ul>
<li>不要使用null来检测是否传入了参数。</li>
<li>不要用null来检测一个未初始化的变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = null;</span><br><span class="line">function getPerson()&#123;</span><br><span class="line">    if( condition )&#123;</span><br><span class="line">        return new Person(&quot;ABC&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 null 的理解最好是当做对象的占位符使用，主流的规范没有提及。 <code>1.7.4 undefined</code> 由于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person;</span><br><span class="line">typeof person; //  undefined</span><br><span class="line">typeof foo;   // undefined</span><br></pre></td></tr></table></figure>

<p>以及<code>null == undefined</code>所以，禁止使用特殊值 undefined 可以有效地确保只在一种情况下 typeof 才返回 undefined。 <code>1.7.5 对象直接量 与 数组直接量（字面量）</code> 创建对象与数组最流行的方法为对象字面量和数组字面量，比相应的构造函数式创建更高效直接。</p>
<h3 id="第二章-注释"><a href="#第二章-注释" class="headerlink" title="第二章 注释"></a>第二章 注释</h3><h4 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h4><p>三种使用方法：</p>
<ul>
<li>独占一行，用来解释下一行，并且这行注释之前总有一行空行，缩进的层级与下一行代码保持一致。</li>
<li>在代码行的尾部注释。代码与注释之间至少有一个缩进。注释包括之前本行的代码不应该超过最大字符数限制。</li>
<li>注释掉大块代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 好的注释方法</span><br><span class="line">if( condition )&#123;</span><br><span class="line"></span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的注释方法</span><br><span class="line">if( condition )&#123;</span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( condition )&#123;</span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-多行注释"><a href="#2-2-多行注释" class="headerlink" title="2.2 多行注释"></a>2.2 多行注释</h4><p>偏向使用 Java 风格的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这里是注释</span><br><span class="line"> * 这里是注释</span><br><span class="line"> * 这里是注释</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>缩进的格式与单行注释表示一致。</p>
<h4 id="2-3-使用注释"><a href="#2-3-使用注释" class="headerlink" title="2.3 使用注释"></a>2.3 使用注释</h4><p>当代码不够清晰的时候使用注释，当代码很明了的时候不应当添加注释。 并且注释不应该只是解释变量名称或者函数名称式的那种废话。 当代码很难理解或者代码可能被误认为错误的代码的时候，需要添加注释。</p>
<h4 id="2-4-文档注释"><a href="#2-4-文档注释" class="headerlink" title="2.4 文档注释"></a>2.4 文档注释</h4><p>技术角度来说，文档注释并不是 JS 的组成部分，但是是一种普遍的实践。</p>
<ul>
<li>应当对所有的方法和可能的返回值添加描述。</li>
<li>对自定义的构造函数类型和期望的参数添加描述。</li>
<li>对于包含对象或者方法的对象进行描述。</li>
</ul>
<h3 id="第三章-语句和表达式"><a href="#第三章-语句和表达式" class="headerlink" title="第三章 语句和表达式"></a>第三章 语句和表达式</h3><p>JS中，诸如 if 和 for 之类的规定不管是单行代码还是多行代码，均使用 { }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">if( contidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( conidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法</span><br><span class="line">if( contidion )&#123; foo(); &#125;</span><br><span class="line">if( contidion )  foo();</span><br></pre></td></tr></table></figure>

<p>所有的语句块都应当使用 { }， if ， for ， while ，do while ， try catch finnally 。</p>
<h4 id="3-1-花括号对齐方式"><a href="#3-1-花括号对齐方式" class="headerlink" title="3.1 花括号对齐方式"></a>3.1 花括号对齐方式</h4><p>有两种对齐方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if( conidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if( conidion )</span><br><span class="line">&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然由于第二种又时候会会让浏览器执行代码的时候产生不一样的解析，所以使用第一种花括号对齐方式。</p>
<h4 id="3-2-块语句间隔"><a href="#3-2-块语句间隔" class="headerlink" title="3.2 块语句间隔"></a>3.2 块语句间隔</h4><p>语句块间隔有3中形式：</p>
<ul>
<li>语句名 圆括号 左花括号间没有空格间隔。</li>
<li>左圆括号之前 右圆括号之后添加一个空格。</li>
<li>左圆括号 右圆括号前后都添加一个空格。</li>
</ul>
<p>作者推荐一致使用第二种形式。</p>
<h4 id="3-3-switch-语句"><a href="#3-3-switch-语句" class="headerlink" title="3.3 switch 语句"></a>3.3 switch 语句</h4><p>JS中任何表达式都可以合法的用于case从句中，其他语言必须使用原始值和常量。 <code>3.3.1 缩进</code> JS的switch缩进一致是有争议的话题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break；</span><br><span class="line"></span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">                // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个case相对于switch都有一个缩进层。 第二个case开始之前都有一个空行。 另一种 Crockford 和Dojo编程风格为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break；</span><br><span class="line">case &quot;b&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break;</span><br><span class="line">default :</span><br><span class="line">        // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>3.3.2 case语句的连续执行（贯穿）</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">                // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Douglas 在 Crockford中禁止出现贯穿现象， 但是Nichlas认为只要程序逻辑很清楚，贯穿完全是一个可以接受的编程方式。Jquery 编程风格中也是允许的。 <code>3.3.3 default</code> 是否在任何时候都需要 default。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">     //没有 default :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更倾向于没有默认行为并且在注释中写入省略 default。</p>
<h4 id="3-4-with"><a href="#3-4-with" class="headerlink" title="3.4 with"></a>3.4 with</h4><p>with 语句可以更改包含上下文解析变量的方式。通过with可以使用局部变量的方式和函数的形式来访问特定对象中的属性和方法。可以缩短代码的长度。 但是是的JS引擎与压缩工具无法压缩。严格模式中 with 是禁止的。 基本所有的规范中都禁止使用 with。</p>
<h4 id="3-5-for-循环"><a href="#3-5-for-循环" class="headerlink" title="3.5 for 循环"></a>3.5 for 循环</h4><p>对于for循环中的 break 和 return 会改变循环的方向，尽量避免使用，但是不禁止。</p>
<h4 id="3-6-for-in-循环"><a href="#3-6-for-in-循环" class="headerlink" title="3.6 for-in 循环"></a>3.6 for-in 循环</h4><p>for-in循环建议与 hasOwnProperty 一起检测属性，除非你需要检查原型。 for-in是用来遍历对象的，不要用其来遍历数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">倪颖峰</p>
  <div class="site-description" itemprop="description">曾在果壳、百度蹦哒，目前在B站活跃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">倪颖峰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
