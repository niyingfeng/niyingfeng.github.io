<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"freefe.cc","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:type" content="website">
<meta property="og:title" content="NiYingfeng 的博客">
<meta property="og:url" content="http://freefe.cc/page/6/index.html">
<meta property="og:site_name" content="NiYingfeng 的博客">
<meta property="og:description" content="曾在果壳、百度蹦哒，目前在B站活跃">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="倪颖峰">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://freefe.cc/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>NiYingfeng 的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">NiYingfeng 的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、生活与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/06/25/javascript-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/06/25/javascript-note-1/" class="post-title-link" itemprop="url">编写可维护的JavaScript笔记（1-3章）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-06-26 00:00:00" itemprop="dateCreated datePublished" datetime="2013-06-26T00:00:00+08:00">2013-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/06/25/javascript-note-1/" class="post-meta-item leancloud_visitors" data-flag-title="编写可维护的JavaScript笔记（1-3章）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一部分-编程风格"><a href="#第一部分-编程风格" class="headerlink" title="第一部分 编程风格"></a>第一部分 编程风格</h3><p>每个人都有自己独特的编程风格，有情有独钟亦或恨之入骨的，每个人都希望用自己的方式制定规范来实施。这些应当被归为个人编程嗜好。我们需要的是在编程过程中尽早的确定统一的编程风格。 在团队开发中，编程风格一致性变得尤为重要，因为： 1 任何开发者都不在乎某个文件的作者是谁，也没有必要花费额外的精力去理解代码的逻辑并且重新排版，因为所有代码的排版风格都是非常一致的，因为风格不一致会导致我们打开代码文件的第一件事情不是立即工作，而是进行缩进的排版整理。 2 能很容易的辨别出有问题的代码并且发现错误，如果所有的代码风格很像，当看到一段与众不同的代码时，很肯能问题就出在这里。</p>
<blockquote>
<p>JSLint 和 JSHint 是两个检查编程风格的工作。不仅找出代码中潜在的错误，还能对潜在的风格问题给予提示警告。 “程序是写给人读的，只是偶尔让计算机执行一下” - Donald Knuth</p>
</blockquote>
<h3 id="第一章-基本的格式化"><a href="#第一章-基本的格式化" class="headerlink" title="第一章 基本的格式化"></a>第一章 基本的格式化</h3><p>编程风格的核心就是基本的格式化规范，这些规范决定着如何编写高水准的代码。</p>
<h4 id="1-1-缩进层级"><a href="#1-1-缩进层级" class="headerlink" title="1.1 缩进层级"></a>1.1 缩进层级</h4><p>所有语言都是如此，都会讨论如何对代码缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line">for(var i=0; i&lt;wl.length;i++)&#123;</span><br><span class="line">p = wl[i];</span><br><span class="line">        type=Y.Lang.type(wl[i]);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微编写过程序的都不会使用上面的格式，害人害己。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line">        for(var i=0; i&lt;wl.length;i++)&#123;</span><br><span class="line">                p = wl[i];</span><br><span class="line">                type=Y.Lang.type(wl[i]);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码应该如何统一缩进其实一直没有统一的共识。</p>
<ul>
<li>使用制表符缩进 。</li>
<li>使用空格缩进。</li>
</ul>
<blockquote>
<p>jQuery 明确规定使用制表符缩进。 Dauglas Crockford 的 JavaScript 规定使用4个空格缩进。 Google 的 JavaScript规定使用2个空格缩进。 Dojo 编程风格指南使用制表符缩进。</p>
</blockquote>
<p>尼古拉斯（作者）建议4个空格，或在编辑器中设置一个 制表符 替换为 4个空格。为一个缩进层。</p>
<h4 id="1-2-语句结尾"><a href="#1-2-语句结尾" class="headerlink" title="1.2 语句结尾"></a>1.2 语句结尾</h4><p>强制规定，语句结束插入分号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">        return</span><br><span class="line">        &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就会引起问题。</p>
<h4 id="1-3-行的长度"><a href="#1-3-行的长度" class="headerlink" title="1.3 行的长度"></a>1.3 行的长度</h4><p>很少有JS的规范提及到行的长度的风格的，很多语言都建议行的字数不超过 80 字，因为很早以前的编辑器，这是最大的行长度。</p>
<blockquote>
<p>Java语言规范中 源码单行长不超过 70 字，文档中单行长不超过 80 字。 Android开发者规范中规定不超过 100 字。 非官方的Ruby规定不操过 80 字。 Python编程规范规定单行不超过 79 字。</p>
</blockquote>
<p>JavaScript 在 Crockford 代码规范中规定为 80 字符。</p>
<h4 id="1-4-换行"><a href="#1-4-换行" class="headerlink" title="1.4 换行"></a>1.4 换行</h4><p>当一行字字符数超过了最大限制的时候就需要换行。通常会在运算符之后换行，下一行会增加2个层级的缩进。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callFunction(document,&quot;aaaaaaaaaaaaaaa&quot;,&quot;bbbbbbbbbbbbbbbb&quot;,&quot;cccccccccccccccccccc&quot;,</span><br><span class="line">    &quot;bbbbbbbbbbbbbbbbbbb&quot;);//超出首字母c的2个层级</span><br></pre></td></tr></table></figure>

<p>需要注意的是规范为在运算符之后换行，以及增加2个层级的缩进。 当然如果是赋值的话就保持赋值运算符对其。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = &quot;aaaaaaaaaaaaaaaa&quot; + &quot;bbbbbbbbbbbbbbbb&quot; + &quot;ccccccccccccccccccc&quot; +</span><br><span class="line">                         &quot;ddddddddddddddddddddddddd&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-空行"><a href="#1-5-空行" class="headerlink" title="1.5 空行"></a>1.5 空行</h4><p>空行常常被忽略，但是空行也是提高代码可读性的强大武器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(wl &amp;&amp; wl.length)&#123;</span><br><span class="line"></span><br><span class="line">        for(var i=0; i</span><br><span class="line"></span><br><span class="line">                p = wl[i];</span><br><span class="line">                type=Y.Lang.type(wl[i]);</span><br><span class="line"></span><br><span class="line">                if(a)&#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空行一般来说不是很好在规范中规定，</p>
<ul>
<li>方法之间</li>
<li>方法中局部变量可第一条语句之间。</li>
<li>多行或者单行注释之前。</li>
<li>在方法内的逻辑片段之前。</li>
</ul>
<p>目前没有规范对空行进行明确的规定。</p>
<h3 id="1-6-命名"><a href="#1-6-命名" class="headerlink" title="1.6 命名"></a>1.6 命名</h3><blockquote>
<p>“计算机科学只存在两个难题：缓存失效和命名” - Phil Karlton</p>
</blockquote>
<p>只要写代码就会涉及到变量和函数，所以变量和函数的命名对于增强代码的可读性至关重要。 JavaScripe 遵循 ECMA ，即驼峰式大小写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myName;</span><br><span class="line">var anotherName;</span><br></pre></td></tr></table></figure>

<p>google Dojo等规范都规定使用小驼峰命名法。，当然还有一种曾经风光一时的 匈牙利命名法。 <code>1.6.1 变量和函数</code> 变量名总是应该遵循驼峰大小写命名法，并且命名的前缀应当是名词，使得可以将变量和函数区分开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以下OK</span><br><span class="line">var count = 10;</span><br><span class="line">var myName = &quot;Ni&quot;;</span><br><span class="line">var found = true;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 以下就需要重新命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var getCount = 10;</span><br><span class="line">var isFound = true;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;函数应当以动词开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var getName  = function()&#123;</span><br><span class="line">        return myName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一点示范</p>
<blockquote>
<p>can 函数返回布尔值 has 函数返回布尔值 is 函数返回布尔值 get 函数返回非布尔值 set 函数用来保存值</p>
</blockquote>
<p><code>1.6.2 常量</code> JS中没有常量的概念。来自C语言的约定，常量使用大写字母并且使用下划线命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var MAX_COUNT = 10；</span><br><span class="line">var URL = &quot;http://www.guokr.com&quot;;</span><br></pre></td></tr></table></figure>

<p>google Dojo 等编程风格指南都规定如此。 <code>1.6.3 构造函数</code> JS中的构造函数只不过是冠以 new 运算符的函数而已。采用大驼峰命名法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person( name )&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-直接量"><a href="#1-7-直接量" class="headerlink" title="1.7 直接量"></a>1.7 直接量</h4><p>JS中的原始值：字符串、数字、布尔值、null和underfined。 <code>1.7.1 字符串</code> JS中的字符串使用双引号和单引号是完全相同的。对于规范只需要统一即可。 jQuery 和 Crockford规范为双引号来括住字符串，google规范为单引号括住字符串。 <code>1.7.2 数字</code> JS中整数和浮点数都存储为相同的数据类型。 不推荐使用 10. 和 .1 的写法。会产生歧义，是否是我们漏掉了数字。</p>
<p><code>1.7.3 null</code> null 常会与 undefined 搞混淆。以下场景才应当使用null：</p>
<ul>
<li>用来初始化变量，该变量可能被赋值为对象。</li>
<li>用来和一个已经初始化的变量进行比较，这个变量可以是非对象。</li>
<li>当函数期望的参数是对象，用作参数传入。</li>
<li>当函数的返回值期望是对象时，用作返回值传出。</li>
</ul>
<p>以下场景不应当使用 null：</p>
<ul>
<li>不要使用null来检测是否传入了参数。</li>
<li>不要用null来检测一个未初始化的变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = null;</span><br><span class="line">function getPerson()&#123;</span><br><span class="line">    if( condition )&#123;</span><br><span class="line">        return new Person(&quot;ABC&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 null 的理解最好是当做对象的占位符使用，主流的规范没有提及。 <code>1.7.4 undefined</code> 由于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person;</span><br><span class="line">typeof person; //  undefined</span><br><span class="line">typeof foo;   // undefined</span><br></pre></td></tr></table></figure>

<p>以及<code>null == undefined</code>所以，禁止使用特殊值 undefined 可以有效地确保只在一种情况下 typeof 才返回 undefined。 <code>1.7.5 对象直接量 与 数组直接量（字面量）</code> 创建对象与数组最流行的方法为对象字面量和数组字面量，比相应的构造函数式创建更高效直接。</p>
<h3 id="第二章-注释"><a href="#第二章-注释" class="headerlink" title="第二章 注释"></a>第二章 注释</h3><h4 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h4><p>三种使用方法：</p>
<ul>
<li>独占一行，用来解释下一行，并且这行注释之前总有一行空行，缩进的层级与下一行代码保持一致。</li>
<li>在代码行的尾部注释。代码与注释之间至少有一个缩进。注释包括之前本行的代码不应该超过最大字符数限制。</li>
<li>注释掉大块代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 好的注释方法</span><br><span class="line">if( condition )&#123;</span><br><span class="line"></span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的注释方法</span><br><span class="line">if( condition )&#123;</span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( condition )&#123;</span><br><span class="line">    // 解释下一行代码</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-多行注释"><a href="#2-2-多行注释" class="headerlink" title="2.2 多行注释"></a>2.2 多行注释</h4><p>偏向使用 Java 风格的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 这里是注释</span><br><span class="line"> * 这里是注释</span><br><span class="line"> * 这里是注释</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>缩进的格式与单行注释表示一致。</p>
<h4 id="2-3-使用注释"><a href="#2-3-使用注释" class="headerlink" title="2.3 使用注释"></a>2.3 使用注释</h4><p>当代码不够清晰的时候使用注释，当代码很明了的时候不应当添加注释。 并且注释不应该只是解释变量名称或者函数名称式的那种废话。 当代码很难理解或者代码可能被误认为错误的代码的时候，需要添加注释。</p>
<h4 id="2-4-文档注释"><a href="#2-4-文档注释" class="headerlink" title="2.4 文档注释"></a>2.4 文档注释</h4><p>技术角度来说，文档注释并不是 JS 的组成部分，但是是一种普遍的实践。</p>
<ul>
<li>应当对所有的方法和可能的返回值添加描述。</li>
<li>对自定义的构造函数类型和期望的参数添加描述。</li>
<li>对于包含对象或者方法的对象进行描述。</li>
</ul>
<h3 id="第三章-语句和表达式"><a href="#第三章-语句和表达式" class="headerlink" title="第三章 语句和表达式"></a>第三章 语句和表达式</h3><p>JS中，诸如 if 和 for 之类的规定不管是单行代码还是多行代码，均使用 { }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">if( contidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( conidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不好的写法</span><br><span class="line">if( contidion )&#123; foo(); &#125;</span><br><span class="line">if( contidion )  foo();</span><br></pre></td></tr></table></figure>

<p>所有的语句块都应当使用 { }， if ， for ， while ，do while ， try catch finnally 。</p>
<h4 id="3-1-花括号对齐方式"><a href="#3-1-花括号对齐方式" class="headerlink" title="3.1 花括号对齐方式"></a>3.1 花括号对齐方式</h4><p>有两种对齐方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if( conidion )&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if( conidion )</span><br><span class="line">&#123;</span><br><span class="line">        foo();</span><br><span class="line">        foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然由于第二种又时候会会让浏览器执行代码的时候产生不一样的解析，所以使用第一种花括号对齐方式。</p>
<h4 id="3-2-块语句间隔"><a href="#3-2-块语句间隔" class="headerlink" title="3.2 块语句间隔"></a>3.2 块语句间隔</h4><p>语句块间隔有3中形式：</p>
<ul>
<li>语句名 圆括号 左花括号间没有空格间隔。</li>
<li>左圆括号之前 右圆括号之后添加一个空格。</li>
<li>左圆括号 右圆括号前后都添加一个空格。</li>
</ul>
<p>作者推荐一致使用第二种形式。</p>
<h4 id="3-3-switch-语句"><a href="#3-3-switch-语句" class="headerlink" title="3.3 switch 语句"></a>3.3 switch 语句</h4><p>JS中任何表达式都可以合法的用于case从句中，其他语言必须使用原始值和常量。 <code>3.3.1 缩进</code> JS的switch缩进一致是有争议的话题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break；</span><br><span class="line"></span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">                // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个case相对于switch都有一个缩进层。 第二个case开始之前都有一个空行。 另一种 Crockford 和Dojo编程风格为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break；</span><br><span class="line">case &quot;b&quot;:</span><br><span class="line">        //代码</span><br><span class="line">        break;</span><br><span class="line">default :</span><br><span class="line">        // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>3.3.2 case语句的连续执行（贯穿）</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        default :</span><br><span class="line">                // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Douglas 在 Crockford中禁止出现贯穿现象， 但是Nichlas认为只要程序逻辑很清楚，贯穿完全是一个可以接受的编程方式。Jquery 编程风格中也是允许的。 <code>3.3.3 default</code> 是否在任何时候都需要 default。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch (condition) &#123;</span><br><span class="line">        case &quot;a&quot;:</span><br><span class="line">        case &quot;b&quot;:</span><br><span class="line">                //代码</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">     //没有 default :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更倾向于没有默认行为并且在注释中写入省略 default。</p>
<h4 id="3-4-with"><a href="#3-4-with" class="headerlink" title="3.4 with"></a>3.4 with</h4><p>with 语句可以更改包含上下文解析变量的方式。通过with可以使用局部变量的方式和函数的形式来访问特定对象中的属性和方法。可以缩短代码的长度。 但是是的JS引擎与压缩工具无法压缩。严格模式中 with 是禁止的。 基本所有的规范中都禁止使用 with。</p>
<h4 id="3-5-for-循环"><a href="#3-5-for-循环" class="headerlink" title="3.5 for 循环"></a>3.5 for 循环</h4><p>对于for循环中的 break 和 return 会改变循环的方向，尽量避免使用，但是不禁止。</p>
<h4 id="3-6-for-in-循环"><a href="#3-6-for-in-循环" class="headerlink" title="3.6 for-in 循环"></a>3.6 for-in 循环</h4><p>for-in循环建议与 hasOwnProperty 一起检测属性，除非你需要检查原型。 for-in是用来遍历对象的，不要用其来遍历数组。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/06/04/html5-canvas-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/06/04/html5-canvas-api/" class="post-title-link" itemprop="url">HTML5 Canvas API简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2013-06-05T00:00:00+08:00">2013-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/06/04/html5-canvas-api/" class="post-meta-item leancloud_visitors" data-flag-title="HTML5 Canvas API简介" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>canvas 其实对于HTML来说很简单，只是一个标签元素而已，自己并没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上，拥有绘制路径，矩形，圆，字符以及图像等功能。 所有的标签只是图形的容器，必须使用JavaScript的 API 操作绘图。</p>
<h3 id="canvas-浏览器支持性"><a href="#canvas-浏览器支持性" class="headerlink" title="canvas 浏览器支持性"></a>canvas 浏览器支持性</h3><p><img src="http://image.freefe.cc/20161010205158.png"></p>
<h3 id="canvas-绘图"><a href="#canvas-绘图" class="headerlink" title="canvas 绘图"></a>canvas 绘图</h3><p>首先是需要在页面中有 canvas 这个图形容器，为了方便在浏览器测试，直接控制台覆盖写入 canvas 标签页面、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.open();</span><br><span class="line">document.write();// 这边代码无法显示在编辑器下 插入一个canvas标签 </span><br><span class="line">document.close();</span><br></pre></td></tr></table></figure>

<p>接下来是使用接口获取并渲染为 2d 对象（目前只支持二维）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">var cantxt = canvas.getContext(&quot;2d&quot;);</span><br></pre></td></tr></table></figure>

<p>首先是获取到 canvas 对象，从 canvas 对象中得到二维对象进行处理。 如果使用 Object.prototype.toString 来检测 cantxt 的话， 类型为 [object CanvasRenderingContext2D] 获取了其 2d 的对象 便可以操作 canvas 了</p>
<h3 id="首先是一些路径的-API："><a href="#首先是一些路径的-API：" class="headerlink" title="首先是一些路径的 API："></a>首先是一些路径的 API：</h3><p><code>描绘路径的方法：</code> moveTo(x , y) : 显示的指定路径的起点为 x , y，左上角为原点，横向为 X 轴，纵向为 Y 轴。canvas 默认起点为 0 ， 0。 lineTo(x , y) : 描绘一条从起点到 (x , y) 点的直线，并且将起始位置设为 (x , y)。 rect(left , top , width , height) : 描绘一个已知左上角端点位置，以及高和宽的矩形。描绘完成后起点会一定到左上角位子。 arcTo( x1 , y1 , x2 , y2 , radius ) : 用于描绘一个与两条线段相切的圆弧，两条线段分别以当前Context绘制起点和(x2, y2)点为起点，都以(x1, y1)点为终点，圆弧的半径为radius。描绘完成后绘制起点会移动到以(x2, y2)为起点的线段与圆弧的切点。 arc( x , y , radius , startAngle , endAngle , anticlockwise ) : 用于描绘一个以(x, y)点为圆心，radius为半径，startAngle为起始弧度，endAngle为终止弧度的圆弧。anticlockwise为布尔型的参数，true表示逆时针，false表示顺时针。参数中的两个弧度以0表示0°，位置在3点钟方向；Math.PI值表示180°，位置在9点钟方向。 quadraticCurveTo( cpx , cpy , x , y) : 以当前Context绘制起点为起点，(cpx,cpy)点为控制点，(x, y)点为终点的二次样条曲线路径。 bezierCurveTo( cpx1 , cpy1 , cpx2 , cpy2 , x , y); ： 以当前Context绘制起点为起点，(cpx1,cpy1)点和(cpx2, cpy2)点为两个控制点，(x, y)点为终点的贝塞尔曲线路径。 <code>在描绘完路径之后，还需要使用以下方法 绘制路径或者填充颜色：</code> stroke() : 按照路线绘线条。 fill() : 使用当前设置好的 style 来填充路径区域。 clip() : 按照已有的路线在画布中设置剪辑区域，调用后图形编辑代码只会对编辑区域有效，对外界无效。如未调用则就是当前整个 canvas 为编辑区域。 <code>e.g.</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cantxt.rect(50,50,40,80);</span><br><span class="line">cantxt.fillStyle = &quot;#0F0&quot;; </span><br><span class="line">cantxt.fill();</span><br><span class="line"></span><br><span class="line">cantxt .moveTo(50,50); // 移动到坐标 50 50 </span><br><span class="line">cantxt.lineTo(150,150); // 划出轨迹到 150 150</span><br><span class="line">cantxt.stroke(); // 以线条显示轨迹</span><br><span class="line"></span><br><span class="line">// 突然会发现，颜色方面有点错误，线条的黑色会影响到矩形的绿色。所以需要使用 打开路径 关闭路径的方法隔断路径间的联系。</span><br><span class="line"></span><br><span class="line">cantxt.beginPath(); </span><br><span class="line">cantxt.rect(50,50,50,100);</span><br><span class="line">cantxt.fillStyle = &quot;#0F0&quot;; </span><br><span class="line">cantxt.fill();</span><br><span class="line">cantxt.closePath();</span><br><span class="line"></span><br><span class="line">cantxt.beginPath(); </span><br><span class="line">cantxt .moveTo(50,50); // 移动到坐标 50 50 </span><br><span class="line">cantxt.lineTo(150,150); // 划出轨迹到 150 150</span><br><span class="line">cantxt.stroke(); // 以线条显示轨迹</span><br><span class="line">cantxt.closePath();</span><br><span class="line"></span><br><span class="line">cantxt.beginPath();</span><br><span class="line">cantxt.moveTo(50,50); </span><br><span class="line">cantxt.arcTo(100,100,200,50,50);</span><br><span class="line">cantxt.stroke(); </span><br><span class="line">cantxt.closePath();</span><br></pre></td></tr></table></figure>

<p>以及其他的几个方法： fillText(text , left , top , [maxWidth]) : 字符串，相对与原点的坐标，字符串的最大长度。其中最大长度maxWidth是可选参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cantxt.fillText(&quot;abcde&quot;,100,300);</span><br></pre></td></tr></table></figure>

<p><code>还有一种方式是不使用路径，直接填上颜色：</code> fillRect( left , top , width , height ) : 直接填充矩形。 strokeRect( left , top , width , height ) : 划出矩形边框。 clearReck(left , top , width , height ) : 清除矩形内所有内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cantxt.strokeRect( 50,50,100,100 );</span><br><span class="line">cantxt.clearRect( 50,50,100,100 ); // 发现还会留下一圈边框</span><br><span class="line">cantxt.clearRect( 49,49,102,102 );</span><br></pre></td></tr></table></figure>

<p>fillRect没有上面的问题。 <code>还有几个可以设置的属性：</code> strokeStyle : 线条颜色，默认为 “#000000”，可设为 css颜色值，渐变对象，或者模式对象。 fillStyle : 填充的颜色。 lineWidth : 线条宽度。单位 px。 lineCap : 线条端点样式， butt 无，round 圆头， square 方头。 lineJoin : 线条转折的处理，round 圆角 , bevel 平角 , miter 尖角。 miterLimit : 尖角的锐利程度，默认 10. translate（x,y）：平移变换，原点移动到坐标（x，y）； rotate（a）：旋转变换，旋转a度角； scale（x，y）：伸缩变换； save（），restore（）：提供和一个堆栈，保存和恢复绘图状态，save将当前绘图状态压入堆栈，restore出栈，恢复绘图状态；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cantxt.translate(200,200);</span><br><span class="line">cantxt.rotate(1);</span><br><span class="line">cantxt.moveTo(0,0);</span><br><span class="line">cantxt.lineTo(100,100); </span><br><span class="line">cantxt.stroke();</span><br></pre></td></tr></table></figure>

<p><code>Context对象中拥有drawImage()方法可以将外部图片绘制到Canvas中。</code> drawImage()方法的3种原型如下： drawImage(image, dx, dy); drawImage(image, dx, dy,dw, dh); drawImage(image, sx, sy,sw, sh, dx, dy, dw, dh); 其中，image参数可以是HTMLImageElement、HTMLCanvasElement或者HTMLVideoElement。第三个方法原型中的sx、sy在前两个中均为0，sw、sh均为image本身的宽和高；第二和第三个原型中的dw、dh在第一个中也均为image本身的宽和高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/05/30/backbone-event-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/05/30/backbone-event-code/" class="post-title-link" itemprop="url">BackBone事件源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-05-31 00:00:00" itemprop="dateCreated datePublished" datetime="2013-05-31T00:00:00+08:00">2013-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/05/30/backbone-event-code/" class="post-meta-item leancloud_visitors" data-flag-title="BackBone事件源码" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="backbone-简介"><a href="#backbone-简介" class="headerlink" title="backbone 简介"></a>backbone 简介</h3><p>当我们在开发大量 JavaScript 的 web 应用的时候，很大的工作就是处理 DOM 以及 DOM 中数据的问题。如果没有很好的组装架构，那么就会带来混乱的结构与越来越复杂和麻烦的问题。 backbone 是一个重量级的 JavaScript 应用框架。 为复杂的 JavaScript 应用程序提供了模型（models）、集合（collections）、视图（views）的结构。</p>
<ul>
<li>模型：用于绑定键值数据和自定义事件</li>
<li>集合：附加有可枚举函数的丰富API</li>
<li>视图：声明事件处理函数，通过RESRful JSON接口连接到应用程序。</li>
</ul>
<p>backbone.js 对于 Underscore.js 是重度依赖，对于RESTful，history则依赖与Backbone.Router，DOM处理依赖于 Backbone.View，json2.js，Jquery或者Zepto。 Backbone 将数据呈现为模型，可以创建模型、验证模型、销毁模型和保存模型至服务器。当 UI 的改变引起模型属性变化的时候就会触发 “change” 事件，所显示模型数据的 视图 会接受到更改通知，重新渲染。</p>
<h3 id="backbone-使用"><a href="#backbone-使用" class="headerlink" title="backbone 使用"></a>backbone 使用</h3><p><code>backbone.Events</code> backbone 中的 event 模块可以被拓展到任意对象，使任何对象都可以使用自定义事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var Events = Backbone.Events = &#123;</span><br><span class="line">// 对一个事件绑定回调函数. 传递 &quot;all&quot; 则将绑定回调在所有事件触发时调用</span><br><span class="line">on: function(name, callback, context) &#123;</span><br><span class="line">  // API 检测 </span><br><span class="line">  if (!eventsApi(this, &#x27;on&#x27;, name, [callback, context]) || !callback) return this;</span><br><span class="line">  //相当于 this._events = this._events || &#123;&#125; 下面语法更容易用来赋值 如下下句</span><br><span class="line">  //在绑定时间的对象中 建立事件池 来进行事件管理</span><br><span class="line">  this._events || (this._events = &#123;&#125;); </span><br><span class="line">  // name 事件在事件池中的形式（数组形式） 存放当前对象绑定在name的所有事件</span><br><span class="line">  var events = this._events[name] || (this._events[name] = []);</span><br><span class="line">  // 将当前需要绑定的事件 push到事件池中的具体事件名称中</span><br><span class="line">  events.push(&#123;callback: callback, context: context, ctx: context || this&#125;);</span><br><span class="line">  return this;</span><br><span class="line">&#125;,</span><br><span class="line">off: function()&#123;&#125;,</span><br><span class="line">once: function()&#123;&#125;,</span><br><span class="line">trigger: function()&#123;&#125;,</span><br><span class="line">stopListening: function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其实以上方法和 Jquery 的实现类似，只不过更为简单，Jquery 中还对当前需要绑定事件的对象如果为 DOM 元素的话需要进一步处理来保证 IE 中内存遇到的问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 解绑一个或者多个回调.</span><br><span class="line">// 如果 `context` 是 null, 移除所有有该函数的回调.</span><br><span class="line">// 如果 `callback` 是 null, 移除该事件下的所有回调. </span><br><span class="line">// 如果 `name` 是 null, 移除所有帮定的回调函数</span><br><span class="line">off: function(name, callback, context) &#123;</span><br><span class="line">    var retain, ev, events, names, i, l, j, k;</span><br><span class="line">    if (!this._events || !eventsApi(this, &#x27;off&#x27;, name, [callback, context])) return this;</span><br><span class="line"></span><br><span class="line">    // obj.off() 移除所有事件</span><br><span class="line">    if (!name &amp;&amp; !callback &amp;&amp; !context) &#123;</span><br><span class="line">        this._events = &#123;&#125;;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 underscore 的 获取对象键值方法</span><br><span class="line">    names = name ? [name] : _.keys(this._events);</span><br><span class="line">    for (i = 0, l = names.length; i &lt; l; i++) &#123;</span><br><span class="line">        name = names[i];</span><br><span class="line">        // 移除某一事件下的回调</span><br><span class="line">        if (events = this._events[name]) &#123;</span><br><span class="line">            this._events[name] = retain = [];</span><br><span class="line">            if (callback || context) &#123;</span><br><span class="line">                for (j = 0, k = events.length; j &lt; k; j++) &#123;</span><br><span class="line">                    ev = events[j];</span><br><span class="line">                    if ((callback &amp;&amp; callback !== ev.callback &amp;&amp; callback !== ev.callback._callback) ||</span><br><span class="line">                            (context &amp;&amp; context !== ev.context)) &#123;</span><br><span class="line">                        // 不是所需要删除的事件 则重新扔回 事件池中的对应名称中</span><br><span class="line">                        retain.push(ev);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果对应的名称中没有事件，那么删除事件池对象的该属性</span><br><span class="line">            if (!retain.length) delete this._events[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事件移除，简单地说因为事件绑定是使用了 事件池 的方法处理，那么对于移除事件只需要在事件池中 delete 掉响应的事件即可，唯一需要做的是兼容参数个数不同情况下的移除事件情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 触发一个或多个事件, 触发所有绑定的回调.</span><br><span class="line">// 除了事件名称，回调函数会被传递&#x27;trigger&#x27;相同的参数。 </span><br><span class="line">// (如果你监听了 &#x27;all&#x27;, 会让你的回调函数将事件名称作为第一个参数).</span><br><span class="line">// obj.trigger(&quot;change&quot;,function()&#123;&#125;);</span><br><span class="line">// obj.trigger(&quot;all&quot;,function(eventName)&#123; alert(eventName) &#125;);</span><br><span class="line">trigger: function(name) &#123;</span><br><span class="line">    if (!this._events) return this;</span><br><span class="line">    var args = slice.call(arguments, 1);</span><br><span class="line">    if (!eventsApi(this, &#x27;trigger&#x27;, name, args)) return this;</span><br><span class="line">    var events = this._events[name];</span><br><span class="line">    //别忘了任何事件触发都要调用 all 中的事件</span><br><span class="line">    var allEvents = this._events.all;</span><br><span class="line">    if (events) triggerEvents(events, args);</span><br><span class="line">    if (allEvents) triggerEvents(allEvents, arguments);</span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 使这个对象或者所有监听特定事件的对象停止监听该特定的事件</span><br><span class="line">stopListening: function(obj, name, callback) &#123;</span><br><span class="line">    var listeners = this._listeners;</span><br><span class="line">    if (!listeners) return this;</span><br><span class="line">    var deleteListener = !name &amp;&amp; !callback;</span><br><span class="line">    if (typeof name === &#x27;object&#x27;) callback = this;</span><br><span class="line">    if (obj) (listeners = &#123;&#125;)[obj._listenerId] = obj;</span><br><span class="line">    for (var id in listeners) &#123;</span><br><span class="line">        listeners[id].off(name, callback, this);</span><br><span class="line">        if (deleteListener) delete this._listeners[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">触发与停止监听。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 分割事件字符串.</span><br><span class="line">var eventSplitter = /s+/;</span><br><span class="line">// 实现多样式化的事件功能的API </span><br><span class="line">//比如现有API中的多名称的change blur和jquery风格的事件映射 &#123;change: action&#125;</span><br><span class="line">var eventsApi = function(obj, action, name, rest) &#123;</span><br><span class="line">    if (!name) return true;</span><br><span class="line">    // 处理事件映射</span><br><span class="line">    if (typeof name === &#x27;object&#x27;) &#123;</span><br><span class="line">        for (var key in name) &#123;</span><br><span class="line">            obj[action].apply(obj, [key, name[key]].concat(rest));</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 处理空间分割的事件名称.</span><br><span class="line">    if (eventSplitter.test(name)) &#123;</span><br><span class="line">        var names = name.split(eventSplitter);</span><br><span class="line">        for (var i = 0, l = names.length; i &lt; l; i++) &#123;</span><br><span class="line">            obj[action].apply(obj, [names[i]].concat(rest));</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br><span class="line">// A difficult-to-believe, 在触发事件时优化内部调用. 尽可能快速到达最有可能的情况</span><br><span class="line">// (核心的3个 Backbone 事件参数).</span><br><span class="line">var triggerEvents = function(events, args) &#123;</span><br><span class="line">    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];</span><br><span class="line">    switch (args.length) &#123;</span><br><span class="line">        case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return;</span><br><span class="line">        case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return;</span><br><span class="line">        case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;</span><br><span class="line">        case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;</span><br><span class="line">        default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var listenMethods = &#123;listenTo: &#x27;on&#x27;, listenToOnce: &#x27;once&#x27;&#125;;</span><br><span class="line">// 使用listenTo 和 listenToOnce反转 on and once 控制. 将 *this* 对象监听另外一个对象中的事件</span><br><span class="line">// 保持对监听的跟踪</span><br><span class="line">_.each(listenMethods, function(implementation, method) &#123;</span><br><span class="line">    Events[method] = function(obj, name, callback) &#123;</span><br><span class="line">        var listeners = this._listeners || (this._listeners = &#123;&#125;);</span><br><span class="line">        var id = obj._listenerId || (obj._listenerId = _.uniqueId(&#x27;l&#x27;));</span><br><span class="line">        listeners[id] = obj;</span><br><span class="line">        if (typeof name === &#x27;object&#x27;) callback = this;</span><br><span class="line">        obj[implementation](name, callback, this);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">// 向后兼容的名称.</span><br><span class="line">Events.bind = Events.on;</span><br><span class="line">Events.unbind = Events.off;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用的实例为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123;&#125;;</span><br><span class="line">_.extend(object, Backbone.Events);</span><br><span class="line">object.bind(&quot;alert&quot;, function(msg) &#123;</span><br><span class="line">    alert(&quot;Triggered &quot; + msg);</span><br><span class="line">&#125;);</span><br><span class="line">object.trigger(&quot;alert&quot;, &quot;www.csser.com&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object.unbind(&quot;change&quot;, onChange); // 只移除onChange回调函数</span><br><span class="line">object.unbind(&quot;change&quot;); // 移除所有 &quot;change&quot; 回调函数</span><br><span class="line">object.unbind();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`backbone.sync` _backbone.sync( method, model, [option] )_</span><br><span class="line"></span><br><span class="line">*   method - CRUD 方法 (&quot;create&quot;, &quot;read&quot;, &quot;update&quot;, 或 &quot;delete&quot;)</span><br><span class="line">*   model - 要被保存的模型（或要被读取的集合）</span><br><span class="line">*   options - 成功和失败的回调函数，以及所有 jQuery 请求支持的选项</span><br><span class="line"></span><br><span class="line">是对于模型在服务器中读取和保存的函数,都为 json 格式进行数据传输。默认情况下是依赖于 jQuery或者Zepto 的 Ajax 方法进行的发送 RESTful json 请求。（关于 REST Representational State Transfer 表现层状态转化 可见阮一峰老师的 理解RESTful架构）。额~反正本人不是很了解。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">// Backbone.sync 同步</span><br><span class="line">// -------------</span><br><span class="line">// 重载这个方法来改变 Backbone 持久模型在服务器中的方式、</span><br><span class="line">// 通过请求类型和问题中的模型</span><br><span class="line">// 默认情况发送 RESTful Ajax 请求到模型中的`url()`.</span><br><span class="line">// 一些可行的自定义为:</span><br><span class="line">//</span><br><span class="line">// * 使用 `setTimeout` 在一个请求中批量的触发更新.</span><br><span class="line">// * 发送 XML 而不是 JSON.</span><br><span class="line">// * 坚持模型通过 WebSockets 而不是 Ajax.</span><br><span class="line">//</span><br><span class="line">// 开启 `Backbone.emulateHTTP` 为像 `POST` 一样发送 `PUT` 和 `DELETE` 请求</span><br><span class="line">// `_method` 参数中包含真正的 HTTP 方法,</span><br><span class="line">// 以及主体的所有请求 as `application/x-www-form-urlencoded`</span><br><span class="line">// 替换为 `application/json`参数名为 `model`的模块.</span><br><span class="line">// 当接口为服务器端语言，如**PHP**时很有用， 使得主体的&#x27;PUT&#x27;请求难以读取</span><br><span class="line">Backbone.sync = function(method, model, options) &#123;</span><br><span class="line">    var type = methodMap[method];</span><br><span class="line"></span><br><span class="line">    // 默认设置, 除非指定.</span><br><span class="line">    _.defaults(options || (options = &#123;&#125;), &#123;</span><br><span class="line">        emulateHTTP: Backbone.emulateHTTP,</span><br><span class="line">        emulateJSON: Backbone.emulateJSON</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 默认 JSON-request 设置.</span><br><span class="line">    var params = &#123;type: type, dataType: &#x27;json&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">    // 确保有一个 URL.</span><br><span class="line">    if (!options.url) &#123;</span><br><span class="line">        params.url = _.result(model, &#x27;url&#x27;) || urlError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 确保我们有正确的请求数据.</span><br><span class="line">    if (options.data == null &amp;&amp; model &amp;&amp; (method === &#x27;create&#x27; || method === &#x27;update&#x27; || method === &#x27;patch&#x27;)) &#123;</span><br><span class="line">        params.contentType = &#x27;application/json&#x27;;</span><br><span class="line">        params.data = JSON.stringify(options.attrs || model.toJSON(options));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于老的服务器, 模拟JSON以HTML形式的.</span><br><span class="line">    if (options.emulateJSON) &#123;</span><br><span class="line">        params.contentType = &#x27;application/x-www-form-urlencoded&#x27;;</span><br><span class="line">        params.data = params.data ? &#123;model: params.data&#125; : &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对于老的服务器, 模拟 HTTP 通过用 `_method` 方法仿造 HTTP </span><br><span class="line">    // 和一个 `X-HTTP-Method-Override` 头.</span><br><span class="line">    if (options.emulateHTTP &amp;&amp; (type === &#x27;PUT&#x27; || type === &#x27;DELETE&#x27; || type === &#x27;PATCH&#x27;)) &#123;</span><br><span class="line">        params.type = &#x27;POST&#x27;;</span><br><span class="line">        if (options.emulateJSON) params.data._method = type;</span><br><span class="line">        var beforeSend = options.beforeSend;</span><br><span class="line">        options.beforeSend = function(xhr) &#123;</span><br><span class="line">            xhr.setRequestHeader(&#x27;X-HTTP-Method-Override&#x27;, type);</span><br><span class="line">            if (beforeSend) return beforeSend.apply(this, arguments);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在 non-GET 请求中不传递数据.</span><br><span class="line">    if (params.type !== &#x27;GET&#x27; &amp;&amp; !options.emulateJSON) &#123;</span><br><span class="line">        params.processData = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果我们发送 `PATCH` 请求, </span><br><span class="line">    // 我们在一个老版本ActiveX默认启动的情况下，使用XHR来取代jQuery方法。</span><br><span class="line">    // 删除它当IE8支持 `PATCH` 的时候.</span><br><span class="line">    if (params.type === &#x27;PATCH&#x27; &amp;&amp; window.ActiveXObject &amp;&amp;</span><br><span class="line">                !(window.external &amp;&amp; window.external.msActiveXFilteringEnabled)) &#123;</span><br><span class="line">        params.xhr = function() &#123;</span><br><span class="line">            return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //提出请求, 允许用户自定义Ajax选项.</span><br><span class="line">    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));</span><br><span class="line">    model.trigger(&#x27;request&#x27;, model, xhr, options);</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 映射 CRUD 到 HTTP 为了默认的 `Backbone.sync` 执行.</span><br><span class="line">var methodMap = &#123;</span><br><span class="line">    &#x27;create&#x27;: &#x27;POST&#x27;,</span><br><span class="line">    &#x27;update&#x27;: &#x27;PUT&#x27;,</span><br><span class="line">    &#x27;patch&#x27;: &#x27;PATCH&#x27;,</span><br><span class="line">    &#x27;delete&#x27;: &#x27;DELETE&#x27;,</span><br><span class="line">    &#x27;read&#x27;: &#x27;GET&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 通过 `$` 代理来设置 `Backbone.ajax` 的默认执行.</span><br><span class="line">// 如果想要使用另一个库那么重载它.</span><br><span class="line">Backbone.ajax = function() &#123;</span><br><span class="line">    return Backbone.$.ajax.apply(Backbone.$, arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#96;&#96;&#96;</p>
<h3 id="backbone-源码注释"><a href="#backbone-源码注释" class="headerlink" title="backbone 源码注释"></a>backbone 源码注释</h3><p>以上为 bockbone 的2个核心的模块，另外模块将在下两篇中简单介绍。 由于源码过长，请 查看 Github 猛击这里 。这里只为对 backbone 原文注释的简单翻译，具体还需要研究。 对于 backbone 的中文文档，请 点击这里 这是一个不错的中文文档，各个接口均有详细说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/05/14/the-running-execution-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/05/14/the-running-execution-context/" class="post-title-link" itemprop="url">关于JavaScript的执行上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2013-05-15T00:00:00+08:00">2013-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/05/14/the-running-execution-context/" class="post-meta-item leancloud_visitors" data-flag-title="关于JavaScript的执行上下文" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h3><p>执行上下文是 ECMAScript 中最常提到的概念。 规范上是这么解释的：</p>
<blockquote>
<p>When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. 当控制器转入到ECMAScript可执行代码时，控制器就会进入一个执行上下文。激活的执行上下文形成一个逻辑上的堆栈。在这个逻辑堆栈的最上层的执行上下文就是目前运行中的执行上下文。</p>
</blockquote>
<p><code>e.g.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(func);</span><br><span class="line">function func()&#123;&#125;</span><br><span class="line">var func;</span><br><span class="line">console.log(func);</span><br><span class="line">func = &quot;abc&quot;;</span><br><span class="line">console.log(func);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201305/15/26672038_136859919084nK.png"> 是的，他和执行上下文有关。 <code>e.g.2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function show_arguments(a,b,c)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line"></span><br><span class="line">    console.log(arguments[0]);</span><br><span class="line">    console.log(arguments[1]);</span><br><span class="line">    console.log(arguments[2]);</span><br><span class="line"></span><br><span class="line">    arguments[0] = 0;</span><br><span class="line">    arguments[1] = 1;</span><br><span class="line">    arguments[2] = 2;</span><br><span class="line"></span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show_arguments(&quot;a&quot;,&quot;b&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201305/15/26672038_1368599382m21m.png"> 是的，也和执行上下文有关。 <code>e.g.3</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;I am window&quot;;</span><br><span class="line">function show_name()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var obj_test=&#123;</span><br><span class="line">    name:&quot;I am obj_test&quot;,</span><br><span class="line">    wait_show:function()&#123;</span><br><span class="line">     setTimeout(show_name,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show_name();</span><br><span class="line">obj_test.wait_show();</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201305/15/26672038_136859973999R9.png"> 这是一个之前在 this 中的例子，当然也与执行上下文有关。 执行上下文中东西非常的多。简单来说，执行上下文是有个抽象的对象，可以想象他是一块隐藏在JS控制器里面的内存，用来保存JS中的各种数据以便JS代码中使用这些数据，保证可以代码顺利执行。</p>
<h3 id="执行上下文与其他-某某某-的关系"><a href="#执行上下文与其他-某某某-的关系" class="headerlink" title="执行上下文与其他 某某某 的关系"></a>执行上下文与其他 某某某 的关系</h3><p>具体来说，一个执行上下文中包含了3部分， 变量对象，作用域链，this值。 <img src="http://blog.chinaunix.net/attachment/201305/15/26672038_1368600265Ht0T.png"> 这是一张很好的对执行上下文说明的图片，变量对象，作用域链，this值以及他们本身所包含的数据。可以理解为 EC在JS作用扮演着对JS代码执行控制的角色，其他所有的 变量啊 属性啊 函数啊都是隶属于他旗下的，由他进行把控。</p>
<h3 id="执行上下文是什么时候产生的"><a href="#执行上下文是什么时候产生的" class="headerlink" title="执行上下文是什么时候产生的"></a>执行上下文是什么时候产生的</h3><p>不同的函数为什么会有不同的作用域，其本质就是因为他们在不同的执行上下文中，执行上下文当然不只是一个，当控制器转入到一段ECMA可执行代码的时候就会进入一个新的执行上下文。 <code>e.g.4</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    ...//代码</span><br><span class="line">    function b()&#123;</span><br><span class="line">        ...//代码</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>形式上比如当我调用一个外部函数a，（不是函数定义时，而是函数调用的时候）</p>
<blockquote>
<p>-&gt;控制器转入外部a函数的代码时， -&gt;激活函数 a的执行上下文 ECa，将ECa放入EC堆栈，ECa变为当前激活的执行上下文， -&gt;进入a的代码并执行a中的代码， -&gt;执行中。。。 -&gt;遇到内部函数 b的调用， -&gt;激活函数 b的执行上下文 ECb，将ECb放入EC堆栈，ECb变为当前激活的执行上下文， -&gt;执行上下文堆栈 - ECb - ECa - …… - Global EC -&gt;进入b的代码并执行b中的代码， -&gt;执行完b代码，退出当前执行环境 ECb，将ECb从执行上下文堆栈中推出，ECa又变为当前激活的执行上下文。 -&gt; …….</p>
</blockquote>
<p>理解了执行上下文与执行上下文堆栈的运行原理，那么理解一些其他东西，调用2次函数a其实并不是同一个EC。 <code>e.g.5</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>为什么两次调用a函数都是返回 1，而不是1,2。 用上下文堆栈的原理来解释是因为 在执行第一个函数a的时候，被激活的上下文为 ECa’ 当执行完毕后就被推出堆栈。再执行第二个a的调用的时候，一个新的ECa’’ 被激活放入上下文堆栈，ECa’ 和 ECa’’是相互独立的，num都会在VO阶段声明，AO阶段赋值为0。</p>
<h3 id="eval-Function的执行上下文"><a href="#eval-Function的执行上下文" class="headerlink" title="eval,Function的执行上下文"></a>eval,Function的执行上下文</h3><p>eval会触发一个calling context的东西。会使eval影响当前的执行上下文。 <code>e.g.6</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;var x = 10&quot;);</span><br><span class="line">new Function(&quot;var z = 10&quot;);</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">    eval(&quot;var y = 10&quot;);</span><br><span class="line">    console.log(y);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(x);</span><br><span class="line">console.log(y);</span><br><span class="line">console.log(z);</span><br></pre></td></tr></table></figure>

<p><img src="http://blog.chinaunix.net/attachment/201305/15/26672038_1368611361BeEW.png"> eval会产生自己的一个 evalContext，并且设置一个calling Context为激活它的 EC，然后菜eval中声明的变量等行为会影响到当前的EC。 虽然 z 那边直接被外部的 y 报错给打断了，其实 z 也是报错的，显然就相当于 Function 其实和一般的方法是一样的。</p>
<h3 id="那么，执行上下文是什么？"><a href="#那么，执行上下文是什么？" class="headerlink" title="那么，执行上下文是什么？"></a>那么，执行上下文是什么？</h3><p>那么，执行上下文是什么？那么，执行上下文是什么？那么，执行上下文是什么？那么，执行上下文是什么？那么，执行上下文是什么？。。。 只能说，它是一个抽象的对象，与JS代码执行进程有很大关系。包含 VO，SC，thisValue。 本文为个人了解观点，有不足之处望指出，谢谢~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/05/08/jquery-mobile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/05/08/jquery-mobile/" class="post-title-link" itemprop="url">jQuery Mobile介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2013-05-09T00:00:00+08:00">2013-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/05/08/jquery-mobile/" class="post-meta-item leancloud_visitors" data-flag-title="jQuery Mobile介绍" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是jQuery-Mobile？"><a href="#什么是jQuery-Mobile？" class="headerlink" title="什么是jQuery Mobile？"></a>什么是jQuery Mobile？</h3><p>最初在没有接触 jQuery Mobile 之前，以为 jQuery Mobile 是独立的应用于移动端设备的 JS 库。但准确的来讲，jQuery Mobile是是一个依赖于 jQuery， 应用于手机和平板设备上的库。jQuery Mobile 不仅会给主流移动平台带来jQuery核心库，而且还包含一个完整统一的jQuery移动的UI框架。解决移动端样式兼容性问题，支持全球主流的移动平台。 下面是jQuery Mobile 兼容的移动操作系统。 <img src="http://image.freefe.cc/26672038_1368002755QVL2.png"> 以上8个主流系统应该涵盖了当前 90% 以上的移动端产品。Jquery mobile构建于Jquery ，为前端开发人员提供了一个兼容所有主流移动设备平台的统一UI接口系统。拥有出色的弹性，轻量化以及渐进增强特性与可访问性。 Jquery Mobile的策略可以很容易的概括：创建一个顶级的javascript库，在不同的智能手机和桌面电脑的web浏览器上,形成统一的用户ui. 目前Jquery Mobile的最新稳定版本为已经为正式版1.3,在2013年2月上旬发布，jQuery Mobile 1.3支持jQuery1.7.2或 1.9.1版本。</p>
<h3 id="jQuery-Mobile的特性"><a href="#jQuery-Mobile的特性" class="headerlink" title="jQuery Mobile的特性"></a>jQuery Mobile的特性</h3><ul>
<li>构建于jQuery的核心之上。使之兼容于jq的语法，对于开发人员有最易的开发曲线</li>
<li>兼容于所有的主流移动手机，平板电脑，电子书,和pc，iOS, Android, Blackberry, Palm WebOS, Nokia&#x2F;Symbian, Windows Phone 7, MeeGo, Opera Mobile&#x2F;Mini, Firefox Mobile, Kindle, Nook, 和所有的现代浏览器。</li>
<li>轻量级 压缩后只12k，对图片的依赖程度非常低，保证了速度</li>
<li>模块化的架构可以根据你的独特的需求用来构建最优化的应用</li>
<li>页面和行为均基于html5标记的驱动进行配，开发效率高，对脚本的需求小</li>
<li>渐进增强使所有的移动设备，平板电脑和pc电脑都支持核心的内容和方法。而对于新的移动平台，则可以展现像安装在设备中的应用程序一样出色的富媒体和交互的浏览体验</li>
<li>弹性的设计可以使同样的代码在智能设备上和桌面的屏幕上都自动缩放适应。</li>
<li>强大的ajax驱动的导航系统在保持后退按钮，收藏夹和干净的地址栏的同时完成页面转场。</li>
<li>优秀的可访问性 一些特性比如WAI-ARIA 也包含在内，以确保页面也可以在一些屏幕阅读器(比如苹果的VoiceOver)或者其他手持设备中正常工作.</li>
<li>支持触摸和鼠标事件增加了触摸屏设备支持的触摸，鼠标，和基于光标的输入方法的API</li>
<li>统一的UI组件增加了触摸屏设备支持的触摸，鼠标，和基于光标的输入方法的API</li>
<li>强大的主题样式框和主题编辑器能很容易的进行高度个性化和品牌化的的界面定制</li>
</ul>
<h3 id="jQuery-Mobile的不足"><a href="#jQuery-Mobile的不足" class="headerlink" title="jQuery Mobile的不足"></a>jQuery Mobile的不足</h3><p>下面也是查询网上，以及自己感觉的对于 jQuery Mobile 的不足。</p>
<ul>
<li>首先 jQuery Mobile 对于开发的简便性，兼容性 导致了需要对页面结构进行复杂化，ui组件对于元素 class 的泛滥。</li>
<li>在性能上的一些不足，会导致在一些移动端处很卡的现象。</li>
<li>jQuery Mobile 需要对页面进行从新的构建，所以对于一些异步加载的数据就会有一些问题。</li>
</ul>
<h3 id="代码示例-JM-重构HTML"><a href="#代码示例-JM-重构HTML" class="headerlink" title="代码示例 JM 重构HTML"></a>代码示例 JM 重构HTML</h3><p>下面是一段使用 JM 的HTML代码，看看 JM 对其做的重构</p>
<ul>
<li>Components</li>
<li>Pages &amp; dialogs</li>
<li>Toolbars</li>
<li>Buttons</li>
<li>Content formatting</li>
<li>Form elements</li>
<li>Listviews</li>
</ul>
<p>其中的 data-role，data-inset，data-theme等都是所谓的 HTML5 标记，JM是根据这些标记进行对页面的配置的。具体的每一个标记都是相当于 JM 中的一个控制器是。（标识数据属性） 然后结果 JM ui的从新构建后 会变成</p>
<ul>
<li>Components</li>
<li>Pages &amp; dialogs</li>
</ul>
<p>…</p>
<p>可以看到，原先的只是一个包含 a 标签的 li 元素被重新构建成了一个非常复杂的结构。并且自动添加很多 JM ui 的样式。 当然，最后的ui效果是很不错的。 <img src="http://image.freefe.cc/26672038_1368071567rLzo.png"> 当然这部分是需要后端渲染出来，如果是前端加载，AJAX的方式请求数据渲染的话，那么模板则需要使用 JM ui 重新构建之后的 HTML 格式了，并且还需要进行一些处理。（可能还有其他较为好的方法）。 总的来说，对于一些需要快速建立简单移动站，又希望兼容性比较高的WEB开发工程师来说，jquery mobile是非常好的选着。更多学习 JM 可以参考 <a target="_blank" rel="noopener" href="http://www.jqmapi.com/">http://www.jqmapi.com/</a> .</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/05/05/js-func-and-expression%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/05/05/js-func-and-expression%20/" class="post-title-link" itemprop="url">javascript的函数声明与函数表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-05-06 00:00:00" itemprop="dateCreated datePublished" datetime="2013-05-06T00:00:00+08:00">2013-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/05/05/js-func-and-expression%20/" class="post-meta-item leancloud_visitors" data-flag-title="javascript的函数声明与函数表达式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="函数定义方式"><a href="#函数定义方式" class="headerlink" title="函数定义方式"></a>函数定义方式</h3><p>在javascript中，定义一个函数大体上有3种方式：</p>
<ul>
<li>函数申明</li>
<li>函数表达式</li>
<li>通过 Function 函数构造函数定义。</li>
</ul>
<p>一般来说 方法3 不太常出现，仅仅只会在一些JS类库中实现比如解析json，解析函数的字符串格式等作用。今天主要来讲解下我所理解的前2种方式 <code>函数声明</code> 和 <code>函数表达式</code>。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>ECMA对于函数声明的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Identifier ( FormalParameterListopt ) &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure>

<p>使用函数申明的函数其名称会被提升，严格意义上讲就是在进入上下文阶段便已经处在的该上下文中的变量对象中（VO），位于代码执行之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(func);</span><br><span class="line">function func()&#123;</span><br><span class="line">    return &quot;a function&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，alert 为 func函数。 在line-1中便可以访问func，就是所谓的函数使用函数声明产生的函数提升。函数作为ECMAScript三种代码类型中的一种（还有global和eval），代码的执行都会依赖自身的一个上下文，执行上下文分为2个阶段 进入执行上下文 和 代码执行。 该处的函数声明名称被放入变量对象中，是在进入执行上下文阶段，是在代码执行阶段之前，所以可以在代码执行阶段被访问到，而无关于在代码中声明位子进行的函数声明。关于执行上下文可以参考TOM大叔的 javascript核心 和 执行上下文 ，讲的很有深度的。 对于函数声明也是有规范的：要么处于程序级别，要么处于其他函数中。除了这2处，其他位置都是违反规范的，也会导致一些浏览器的解析不正确。 比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    if(window===parent)&#123;</span><br><span class="line">        function bar()&#123;alert(1);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        function bar()&#123;alert(2);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>显然讲函数声明置于if的块中是不符合ECMA规范的，一般浏览器会将 <img src="http://image.freefe.cc/26672038_1367503582f6uL.png"> ECMA中作用域只有函数级的作用域，而没有块级作用域，所以if的块级作用域是无效的。而在与火狐下 <img src="http://image.freefe.cc/26672038_1367504437gxGP.png"> 该问题就是由于火狐浏览器下对块内函数声明与一般的浏览器有差异导致的，所以需要注意对于一般函数声明需要有规范。</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>函数表达式的声明为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Identifieropt ( FormalParameterListopt ) &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure>

<p>与函数声明的区别在于，标示符名称可以省略，并且处于表达式中，为表达式的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var func1 = function f()&#123;&#125;;</span><br><span class="line">var func2 = function()&#123;&#125;;</span><br><span class="line">(function func3()&#123;&#125;);</span><br><span class="line">~function func4()&#123;&#125;;</span><br><span class="line">!function func5()&#123;&#125;;</span><br><span class="line">true,function func6()&#123;&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上等等，函数部分均为自身表达式的一部分，所以都为函数表达式。 函数表达式与函数声明的一个重要的区别在于，对于 var func1 &#x3D; function f(){}; 来说，规范定义其中的 f 标示符不会暴露出来，仅仅可以供 f 函数内部进行访问。 当然在此对于IE8-版本的浏览器来说又有一个重大的BUG。 对于表达式 var func1 &#x3D; function f(){}; 来说，其解析就会出现较为严重的错误，它会现将表达式中的函数部分单独提取出来先进行函数声明，在进行函数表达式解析。更为严重的是，其中的 func1 ！&#x3D; f，相当于独自创建了 函数f ，再对表达式中的函数在创建一份，并且将地址赋予 func1。解决的办法就是尽量避免IE的这些特性保证兼容所有浏览器。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g.1"></a>e.g.1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">var a = 2;</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">alert(a)</span><br></pre></td></tr></table></figure>

<p>结果为 function a(){} 和 2。 首先在进入上下文阶段时 函数声明将变量声明覆盖掉（变量的赋值是处于代码执行阶段），所以第一个 alert 弹出的为函数，当代码执行过程中，a又被重新赋值为2，故第二个 alert 显示的为2。整个流程可以与 e.g.2 进行比较就不难理解了。</p>
<h4 id="e-g-2"><a href="#e-g-2" class="headerlink" title="e.g.2"></a>e.g.2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">var a;</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">alert(a)</span><br></pre></td></tr></table></figure>

<p>其结果均为 function a(){}。 就可以看出，将a赋值为2，是在代码执行阶段进行的。那么对于</p>
<h4 id="e-g-3"><a href="#e-g-3" class="headerlink" title="e.g.3"></a>e.g.3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">var a = 2;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>可以很清楚的知道 答案为 undefined 与 2 但是对于</p>
<h4 id="e-g-4"><a href="#e-g-4" class="headerlink" title="e.g.4"></a>e.g.4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">alert(a)</span><br></pre></td></tr></table></figure>

<p>为什么又是 function a(){} 和 2 为什么之后的变量声明中 a为undefined没有覆盖函数声明的a呢？ 一般的看法为权重说法，就是函数声明一个标示符之后，如果再对该标示符进行变量声明，那么该变量声明将视为无效。而另一种看法是对于函数声明其实其流程与变量声明是一直的，在进入上下文阶段 均赋值为undefined，但是函数声明将函数引用赋给标示符这一过程，是在代码执行之前触发那一刻。 就好第一个 alert 之前那一刻，a从undefined变为了function。个人偏向于后一种看法。当然如果要知道真正的流程那么还是需要去看 ECMA3或者ECMA5详细规范吧（<a target="_blank" rel="noopener" href="http://ecmascript.cn/">http://ecmascript.cn/</a> ）。 当然说到了函数，那么势必需要知道一下关于 this 的一些资料，可以参考下上篇文章 JS的this简单理解~ 文章下面有好几篇经典的 this 介绍。</p>
<h4 id="e-g-5"><a href="#e-g-5" class="headerlink" title="e.g.5"></a>e.g.5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f = function()&#123; return true; &#125;;</span><br><span class="line">var g = function()&#123; return false; &#125;;</span><br><span class="line">(function()&#123;</span><br><span class="line">    alert(f());</span><br><span class="line">    if(g() &amp;&amp; [] !== [])&#123;</span><br><span class="line">        f = function f()&#123; return false; &#125;</span><br><span class="line">        function g()&#123; return true; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">alert(f());</span><br></pre></td></tr></table></figure>

<p>这是一个比较绕的题目，考察的就是上面说的2点。 先来看下答案 chrome opera IE9+等普通浏览器 会弹出 true false ，火狐这个文艺浏览器 会弹出 true true 而IE8-这2B浏览器就会弹出false true。 呵呵开玩笑。 首先说下普通浏览器 true false 吧，JS中只有函数作用域，而没有块级作用域，所以匿名自执行函数中判断的中的 g() 就为块中定义的函数g（所谓的函数提升），然后 f 被重新指向返回 false 的函数了。 所以结果为 true false。 那么第二种 true true的话，由于规范中的函数声明只可以在 程序级 或者 其它函数中，位于 if 块语句中显然会有悖于这个规范，而火狐是无法忍受该错误的，会将块中的函数声明作为 函数表达式的形式来处理。那么在 if 判断的时候就直接米有通过 那么就为 2个true了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var g = function()&#123; return false; &#125;;</span><br><span class="line">(function()&#123;</span><br><span class="line">    alert(g());</span><br><span class="line">    &#123;</span><br><span class="line">        function g()&#123; return true; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(g());</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>从这段代码在火狐下执行可以看出来， false 和 true 相当于 火狐下，块中的函数声明被当做了函数表达式来处理（效果上可以这么说）。 最后对于IE8-下的浏览器来说对于有名称的函数表达式，该标示符会被暴露出来。确切的来讲 IE8-下 会将 f &#x3D; function f(){} 先进行函数声明一次，然后再进行一次函数声明，也导致了该处的 f 并不是会到全局变量下的 f ，而是因为已经在该函数作用域下有了f的函数声明，而覆盖该函数作用域下的 f。则有了 true false 的结果。 呵呵 能力有限，菜鸟观点，还有很多地方没有弄清楚，望大家多多指教。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/03/13/js-garbage-collecation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/03/13/js-garbage-collecation/" class="post-title-link" itemprop="url">JS垃圾回收机制简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2013-03-14T00:00:00+08:00">2013-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/03/13/js-garbage-collecation/" class="post-meta-item leancloud_visitors" data-flag-title="JS垃圾回收机制简介" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是JS的垃圾回收机制（Garbage-Collecation）"><a href="#什么是JS的垃圾回收机制（Garbage-Collecation）" class="headerlink" title="什么是JS的垃圾回收机制（Garbage Collecation）"></a>什么是JS的垃圾回收机制（Garbage Collecation）</h3><p>对于其他语言来说，如C,C++,需要开发者手动的来跟踪内存，而JS的垃圾回收机制使得JS开发人员无需再关系内存的情况，所有的内存分配以及回收都会由垃圾回收器自动完成，执行环境会对执行过程中占有的内存负责。其原理就是找出那些不在被使用的变量，然后释放其所占有的内存。回收器一般是按照固定的时间间隔或者预设的时间进行处理的。 <code>e.g. 1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">function test1()&#123;</span><br><span class="line">        var i =&#123;name:’nyf’&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test2()&#123;</span><br><span class="line">        var i =&#123;name:’nyf’&#125;;</span><br><span class="line">        return i;</span><br><span class="line">&#125;</span><br><span class="line">var m1 = test1();</span><br><span class="line">var m2 = test2();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一般来说在e.g.1中，当 test1调用时，进入 test1 的环境，那么内存中会开辟存放 &#123;name:’nyf’&#125; 对象的内存，当调用结束后，出了 test1 的环境，那么该内存会被JS引擎中的垃圾回收器自动释放其内存。 在test2中，对象被返回，并且被变量 m2 所指向，所以虽然说在调用完 test2 后出了其环境，但是由于m2仍然持续着对对象的链接关系，所以该对象不会被释放。 但是我们需要注意上述两个例子函数中其实均有2块的内存占用，一个是变量名 i 以及对象 &#123;name:’nyf’&#125; ，i中只是保存着对该对象的地址值。运行test2 未被释放的只是对象，变量名i在2个方法中均被释放，i值才是JS引擎真正需要处理的目标。对于返回的对象，已经返回到上一层的环境，当没有变量再对其进行引用的时候自然也会变会被释放（个人理解）</span><br><span class="line">### 垃圾回收机制的种类</span><br><span class="line">目前JS的垃圾回收机制无非就是两种：1.标记清除（make-and-sweep） 2.引用计数（reference counting）</span><br><span class="line"></span><br><span class="line">1.  `标记清除：`标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。</span><br><span class="line"></span><br><span class="line">2.  &gt; `引用计数：`（查了很多资料，还是无法找到其真正的计算方式） 一般来说，引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数便是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数为0时，说明没有办法访问到它了，因而可以将其占用的内存空间回收。（感觉是有问题的）</span><br><span class="line"></span><br><span class="line">&gt; 对于引用计数，我们需要知道如果具有循环引用，那么其计数问题就会暴露，导致计数永远不为0而无法释放内存，导致内存泄露，具体事例如下： `e.g.2`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    var b = &#123;&#125;;</span><br><span class="line">    b.pro = a;</span><br><span class="line">    a.pro=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果e.g.2使用引用计数的话就会导致问题，内存无法被释放，导致内存无故消耗占用。</span><br><span class="line">### IE的垃圾回收机制问题</span><br><span class="line">除了一些极老版本的IE，目前市面上的JS引擎基本采用标记清除来除了垃圾回收。但是需要注意的是IE中的DOM由于机制问题，是采用了引用计数的方式，所以会有循环引用的问题，如： `e.g.3`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ele = document.getElementById(“element”);</span><br><span class="line">var obj = new Object();</span><br><span class="line">ele.obj = obj;</span><br><span class="line">obj.ele = ele;</span><br></pre></td></tr></table></figure>
<p>&#96;&#96;&#96;</p>
<p>这边就会倒是问题，内存无法再执行完毕后释放 解决方法其实也很简单，当所有的代码完毕末尾处只需要对变量进行 null 赋值即可。 有很多不足与错误，希望各位指出<del>谢谢</del> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/03/09/javascript-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/03/09/javascript-closure/" class="post-title-link" itemprop="url">详谈JS闭包~</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2013-03-10T00:00:00+08:00">2013-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/03/09/javascript-closure/" class="post-meta-item leancloud_visitors" data-flag-title="详谈JS闭包~" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>首先也来简单的说说，JS的闭包到底是什么？较为官方的解释为：</p>
<blockquote>
<p>Closure : A “closure” is an expression (typically a function) that can have free variables together with an environment that binds those variables (that “closes” the expression). 所谓“闭包”，指的是一个拥有多个自由变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
</blockquote>
<p>还有一个对于闭包的描述我认为也挺不错的：</p>
<blockquote>
<p>A closure is a combination of a code block (in ECMAScript this is a function) and statically&#x2F;lexically saved all parent scopes.Thus, via these saved scopes a function may easily refer free variables. 闭包是一个组合的代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>
</blockquote>
<p>按照以上两条描述其实可以看出，闭包不是一个名词，而更偏向于一个形容词来形容一种结构，<code>闭包不仅仅是简单地是在外部函数返回一个内部函数那么简单，事实上从广义的理论上来讲ECMAScript中所有的函数均可以理解为闭包。</code>说了那么多模糊的，那么来具体理解下，到底，什么才是闭包。</p>
<h3 id="讲在闭包前的知识"><a href="#讲在闭包前的知识" class="headerlink" title="讲在闭包前的知识"></a>讲在闭包前的知识</h3><p>首先要了解一些基本的与闭包有关的知识。(以下并不完全正确~) <code>执行上下文(execution context)：</code>执行上下文是ECMAScript中用来描述JS代码执行的一个抽象概念。所有的JS代码都是在某个执行上下文的环境中运行的。在当前执行上下文中调用另一个function的时候就会进入一个新的执行上下文环境，直到当前function执行完毕的时候就会离开此新的执行上下文环境，重新返回之前的执行上下文环境。来回的切换上下文执行环境也就构成了一个执行上下文堆栈。 <code>作用域链(scope chain)：</code>每一个执行上下文环境都会和一个作用域链相互关联。作用域链可在进入某一个执行上下文环境的时候来进行对标识符(identifier)求值。很多时候作用域链中不仅仅只有一个对象，可以想象作用域链也为一个堆栈，查找标识符会从链首开始，然后依次往后从对象中查找标识符，在对每个对象进行查找时也对其原型链进行查找。 当切换一个执行上下文环境的时候会进行以下的操作：</p>
<ol>
<li>当函数创建时(注意不是调用时)的时候已经静态的确定了[[scope]]属性(稍后会详细讲一下)。</li>
<li>该处才是切换的时候进行的第一步操作，创建活动对象(activation object)，活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化，在函数执行上下文的时候变量对象(variable object)是无法直接访问的，所以由AO扮演VO角色，包括arguments属性等。</li>
<li>创建作用域链，作用域链 &#x3D; 活动对象(AO) + [[scope]]，[[scope]]为function的一个内部属性，与function的创建方式与所在代码位置相关。</li>
<li>变量的初始化。这个就简单的理解了，在函数运行时对一些变量进行赋值等一些操作。</li>
</ol>
<h3 id="我们所了解的闭包"><a href="#我们所了解的闭包" class="headerlink" title="我们所了解的闭包"></a>我们所了解的闭包</h3><p><code>E.g 1：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var x = 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        alert(x++);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">var retFunc = foo();</span><br><span class="line">//foo内部返回一个function 可以随意访问foo的内部变量 x </span><br><span class="line">retFunc (); // 0</span><br><span class="line">retFunc (); // 1</span><br><span class="line">var x = 0;</span><br><span class="line">retFunc (); // 2</span><br></pre></td></tr></table></figure>

<p>这是我们最常见的使用闭包特性来进行的处理。此处的 x 是从返回的内部函数的[[scope]]上搜索而来的，静态作用域。 再来一个例子可能可以更鲜明一点的理解静态的含义 <code>E.g 2：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var x = 1;</span><br><span class="line">    foo();</span><br><span class="line">&#125;)();// 弹出 0</span><br></pre></td></tr></table></figure>

<p>静态就是在此处并不弹出0的原因，因为每个函数的[[scope]]均是在函数定义的时候就已经确定，并且不再修改了的，知道与函数一起销毁。 foo在定义的时候[[scope]]中就为全局变量的 x ，而在哪里调用是不会再影响foo的[[scope]]的。 我们最常遇到的闭包带来的问题就是循环中的闭包影响(更多的时候是在操作DOM节点的时候的循环绑定事件，并且还是用的循环中的循环数值作为参数)： <code>E.g 3：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var data =  [];</span><br><span class="line">    for(var i =0;i&lt;3;i++)&#123;</span><br><span class="line">        data[i] = function()&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在调用data<a href="">1</a>，data<a href="">2</a>，data<a href="">3</a>时均会返回 3。因为data数组中的每个函数的[[scope]]都存放着全局的 i，当在调用的时候 i 已经在循环中被赋值为3，故而不管调用哪一个方法，均会从该方法的[[scope]]中查找 i，便是目前的全局i，值为3。 解决办法便是在多制造出一层函数。(在[[scope]]中后进入的优先级更高，从栈首开始搜索。) <code>E.g 4：</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data =  [];</span><br><span class="line">for(var i =0;i&lt;3;i++)&#123;</span><br><span class="line">    data[i] = (function(x)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            alert(x);// 此处便有所不同</span><br><span class="line">            alert(i); // 此处仍是3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使得每次alert的值并不是从[[scope]]中查询全局的i值。</p>
<h3 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h3><p>闭包是代码块和创建该代码块的上下文中数据的结合。技术上来说创建函数的父级上下文中的数据是完全保持在该函数的内部属性[[scope]]中的，这也是的我们的内部函数能够访问外部函数的自由变量。所以理论上来说，所有函数都可以当做闭包。 闭包实质上是通过函数内部的[[scope]]属性来实现的。[[scope]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。 [[scope]]在函数创建时被存储－－静态（不变的）直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。</p>
<h3 id="我所认为的闭包"><a href="#我所认为的闭包" class="headerlink" title="我所认为的闭包"></a>我所认为的闭包</h3><p>闭包不简单，也不复杂。在JS中纯粹只是JS实现机制的一种产物，为我们所利用。理解作用域，作用域链，[[scope]]等JS知识，闭包自然而然的就会有了一定了解。本文如有错误，请各位矫正，谢谢~ 才疏学浅，无法将闭包讲的更深入，具体可以参考一下文章： <a target="_blank" rel="noopener" href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html">http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html</a> <a target="_blank" rel="noopener" href="http://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html">http://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html</a> <a target="_blank" rel="noopener" href="http://baike.baidu.com/view/648413.htm">http://baike.baidu.com/view/648413.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2013/01/29/lazyload-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/01/29/lazyload-code/" class="post-title-link" itemprop="url">JavaScript的LazyLoad源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-01-30 00:00:00" itemprop="dateCreated datePublished" datetime="2013-01-30T00:00:00+08:00">2013-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2013/01/29/lazyload-code/" class="post-meta-item leancloud_visitors" data-flag-title="JavaScript的LazyLoad源码分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Lazyload"><a href="#Lazyload" class="headerlink" title="Lazyload"></a>Lazyload</h3><p>Lazyload 是通过延时加载JS和CSS文件来实现按需加载，以保证在页面刚刚开始呈现的时候提高速度，提高用户体验。 并且LazyLoad是非常小的，压缩完后（gzipped后只有 996 bite）,很容易实现装载外部JavaScript和CSS文件的需求。并且当你指定数组的 url 时,LazyLoad将自动加载资源,同时保证并行执行顺序加载。 其实现的对JS动态加载在不同浏览器的处理，以及CSS加载在不同浏览器的处理。实现了支持 Firefox 2+, IE6+, Safari 3+ (包括移动Safari), Google Chrome, and Opera 9+.</p>
<h3 id="Lazyload-实例"><a href="#Lazyload-实例" class="headerlink" title="Lazyload 实例"></a>Lazyload 实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Load a single JavaScript file and execute a callback when it finishes.</span><br><span class="line">LazyLoad.js(&quot;http://example.com/foo.js&quot;, function () &#123;</span><br><span class="line">    alert(&quot;foo.js has been loaded&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Load multiple JS files and execute a callback when they&#x27;ve all finished.</span><br><span class="line">LazyLoad.js([&quot;foo.js&quot;, &quot;bar.js&quot;, &quot;baz.js&quot;], function () &#123;</span><br><span class="line">    alert(&quot;all files have been loaded&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Load a CSS file and pass an argument to the callback function.</span><br><span class="line">LazyLoad.css(&quot;foo.css&quot;, function (arg) &#123;</span><br><span class="line">    alert(arg);</span><br><span class="line">&#125;, &quot;foo.css has been loaded&quot;);</span><br><span class="line"></span><br><span class="line">// Load a CSS file and execute the callback in a different scope.</span><br><span class="line">LazyLoad.css(&quot;foo.css&quot;, function () &#123;</span><br><span class="line">    alert(this.foo); // displays &quot;bar&quot;</span><br><span class="line">&#125;, null, &#123;foo: &quot;bar&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Lazyload-源码分析"><a href="#Lazyload-源码分析" class="headerlink" title="Lazyload 源码分析"></a>Lazyload 源码分析</h3><p>LazyLoad 更容易的无阻塞延时加载一个或多个JavaScript 或 CSS 文件 在需求期间或之后呈现的web页面。 支撑 Firefox 2+, IE6+, Safari 3+ (包括移动Safari), Google Chrome, and Opera 9+. 其他浏览器为官方不标注支持。 关注 <a target="_blank" rel="noopener" href="https://github.com/rgrove/lazyload/">https://github.com/rgrove/lazyload/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) 2011 Ryan Grove &lt;ryan@wonko.com&gt;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">LazyLoad = (function (doc) &#123;</span><br><span class="line">    // -- 私有变量 ------------------------------------------------------</span><br><span class="line">    // 用户代理和功能测试信息</span><br><span class="line">    var env,</span><br><span class="line">    // 指向元素 用来延迟填充.</span><br><span class="line">    head,</span><br><span class="line">    // 任何目前在进行的请求</span><br><span class="line">    pending = &#123;&#125;,</span><br><span class="line">    // 使用次数来判断样式表是否已经加载 数值太高可能停滞。</span><br><span class="line">    pollCount = 0,</span><br><span class="line">    // 请求队列</span><br><span class="line">    queue = &#123;css: [], js: []&#125;,</span><br><span class="line">    // 指向 文档的样式表列表</span><br><span class="line">    styleSheets = doc.styleSheets;</span><br><span class="line"></span><br><span class="line">    // -- 私有方法 --------------------------------------------------------</span><br><span class="line">    /**</span><br><span class="line">    创建并返回一个制定名和属性的 HTML 元素</span><br><span class="line">    @method createNode</span><br><span class="line">    @param &#123;String&#125; name element name</span><br><span class="line">    @param &#123;Object&#125; attrs name/value mapping of element attributes</span><br><span class="line">    @return &#123;HTMLElement&#125;</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function createNode(name, attrs) &#123;</span><br><span class="line">        var node = doc.createElement(name), attr;</span><br><span class="line">        for (attr in attrs) &#123;</span><br><span class="line">            if (attrs.hasOwnProperty(attr)) &#123;</span><br><span class="line">                node.setAttribute(attr, attrs[attr]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    当当前指定类型的资源完成加载时调用。执行回调并加载下一个队列中的资源（如果有）</span><br><span class="line">    @method finish</span><br><span class="line">    @param &#123;String&#125; type resource type (&#x27;css&#x27; or &#x27;js&#x27;)</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function finish(type) &#123;</span><br><span class="line">        var p = pending[type],</span><br><span class="line">                callback,</span><br><span class="line">                urls;</span><br><span class="line">      // 判断是否有当前类型的资源加载</span><br><span class="line">        if (p) &#123;</span><br><span class="line">            callback = p.callback;</span><br><span class="line">            urls     = p.urls;</span><br><span class="line"></span><br><span class="line">            urls.shift();</span><br><span class="line">            pollCount = 0;</span><br><span class="line"></span><br><span class="line">          // 如果为最后一个待加载的URL 执行回调并且开始下一个队列中的请求（如果有）</span><br><span class="line">            if (!urls.length) &#123;</span><br><span class="line">                callback &amp;amp;&amp;amp; callback.call(p.context, p.obj);// 若有回调 以panding[type]中属性来执行</span><br><span class="line">                pending[type] = null;</span><br><span class="line">                queue[type].length &amp;amp;&amp;amp; load(type);// 队列中如还有当前类型的资源 加载该类型资源</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    当前代码 the &lt;code&gt;env&lt;/code&gt; 环境变量和用户代理和功能测试信息。</span><br><span class="line">    @method getEnv</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function getEnv() &#123;</span><br><span class="line">        var ua = navigator.userAgent;</span><br><span class="line">        env = &#123;</span><br><span class="line">            // 如果这个浏览器支持禁用异步模式动态创建脚本节点</span><br><span class="line">            // http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order</span><br><span class="line">            async: doc.createElement(&#x27;script&#x27;).async === true</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        (env.webkit = /AppleWebKit\//.test(ua))</span><br><span class="line">            || (env.ie = /MSIE/.test(ua))</span><br><span class="line">            || (env.opera = /Opera/.test(ua))</span><br><span class="line">            || (env.gecko = /Gecko\//.test(ua))</span><br><span class="line">            || (env.unknown = true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    加载指定的资源，或者在队列中如果没有指定的资源加载下一个指定类型资源。</span><br><span class="line">    如果一个指定类型资源已经被加载,新的请求将被排队,直到第一个请求完成。</span><br><span class="line">    当数组指定的资源urls,这些url将被载入并行如果它可行,同时保留执行顺序。所有</span><br><span class="line">    浏览器支持并行加载CSS,但只有Firefox和Opera支持并行加载的脚本。在其他浏览器,脚本将</span><br><span class="line">    排队并且在一个时间片段加载一次,以确保正确的执行顺序。</span><br><span class="line">    @method load</span><br><span class="line">    @param &#123;String&#125; type 资源类型 (&#x27;css&#x27; or &#x27;js&#x27;)</span><br><span class="line">    @param &#123;String|Array&#125; urls (可选) 需加载的URL或者URLs数组</span><br><span class="line">    @param &#123;Function&#125; callback (可选) 当资源加载完毕后</span><br><span class="line">    @param &#123;Object&#125; obj (可选) 传递给回调函数的对象参数</span><br><span class="line">    @param &#123;Object&#125; context (可选) 如果提供, 回调函数将被执行在这个对象的上下文参数中</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function load(type, urls, callback, obj, context) &#123;</span><br><span class="line">        var _finish = function () &#123; finish(type); &#125;,</span><br><span class="line">                isCSS   = type === &#x27;css&#x27;,</span><br><span class="line">                nodes   = [],</span><br><span class="line">                i, len, node, p, pendingUrls, url;</span><br><span class="line">        env || getEnv();</span><br><span class="line"></span><br><span class="line">        if (urls) &#123; // 有urls参数</span><br><span class="line">            // 当 urls 为 string 类型，处理为单元素数组  </span><br><span class="line">        // urls.concat()为复制数组（深度复制）使处理其不影响方法调用时的参数（对象在参数传递时是传址传递） </span><br><span class="line">            urls = typeof urls === &#x27;string&#x27; ? [urls] : urls.concat();</span><br><span class="line"></span><br><span class="line">        // 为每个URL创建一个请求对象，如果指定为多个url，则当所有url加载完毕后执行回调</span><br><span class="line">            //</span><br><span class="line">            // 可惜,Firefox和Opera浏览器是唯一能够并行加载并且同时保留执行顺序的浏览器。</span><br><span class="line">            // 在其他浏览器 脚本必须被逐一加载来保证顺序</span><br><span class="line">            //</span><br><span class="line">            // 所有浏览器对于 CSS 样式表的话 并行加载无先后顺序影响 都是简单的下载</span><br><span class="line">            if (isCSS || env.async || env.gecko || env.opera) &#123;</span><br><span class="line">                // 并行加载 当为CSS样式表 异步加载 Firefox和Opera 时 直接扔进队列中并行加载。</span><br><span class="line">                queue[type].push(&#123;</span><br><span class="line">                    urls    : urls,</span><br><span class="line">                    callback: callback,</span><br><span class="line">                    obj     : obj,</span><br><span class="line">                    context : context</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 否则 逐一加载保证顺序。</span><br><span class="line">                for (i = 0, len = urls.length; i &amp;lt; len; ++i) &#123;</span><br><span class="line">                    queue[type].push(&#123;</span><br><span class="line">                        urls    : [urls[i]],</span><br><span class="line">                        callback: i === len - 1 ? callback : null, // 只在最后一个时放入回调函数</span><br><span class="line">                        obj     : obj,</span><br><span class="line">                        context : context</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    // 处理完urls参数进行队列处理</span><br><span class="line"></span><br><span class="line">    // 如果之前加载的要求这种类型目前还在进行中,将等待。否则,抓住队列中的下一项。</span><br><span class="line">        if (pending[type] || !(p = pending[type] = queue[type].shift())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head || (head = doc.head || doc.getElementsByTagName(&#x27;head&#x27;)[0]);</span><br><span class="line">        pendingUrls = p.urls;</span><br><span class="line"></span><br><span class="line">    //  循环建立请求</span><br><span class="line">        for (i = 0, len = pendingUrls.length; i &amp;lt; len; ++i) &#123;</span><br><span class="line">            url = pendingUrls[i];</span><br><span class="line"></span><br><span class="line">            // 火狐下不支持link节点的onload事件 以创建 style 标签 @import 引用来实现调用回调</span><br><span class="line">            if (isCSS) &#123;</span><br><span class="line">                    node = env.gecko ? createNode(&#x27;style&#x27;) : createNode(&#x27;link&#x27;, &#123;</span><br><span class="line">                        href: url,</span><br><span class="line">                        rel : &#x27;stylesheet&#x27;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = createNode(&#x27;script&#x27;, &#123;src: url&#125;);</span><br><span class="line">                node.async = false;// 设为同步加载 保证顺序</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.className = &#x27;lazyload&#x27;;</span><br><span class="line">            node.setAttribute(&#x27;charset&#x27;, &#x27;utf-8&#x27;);</span><br><span class="line"></span><br><span class="line">            if (env.ie &amp;amp;&amp;amp; !isCSS) &#123;// IE的 script 加载完毕触发回调条件</span><br><span class="line">                node.onreadystatechange = function () &#123;</span><br><span class="line">                    if (/loaded|complete/.test(node.readyState)) &#123;</span><br><span class="line">                        node.onreadystatechange = null;</span><br><span class="line">                        _finish();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; else if (isCSS &amp;amp;&amp;amp; (env.gecko || env.webkit)) &#123;</span><br><span class="line">        // Gecko和WebKit不支持link节点的onload事件。</span><br><span class="line">                if (env.webkit) &#123;</span><br><span class="line">                    // 在WebKit,我们可以轮询修改文档。样式表找出当样式表已经加载。</span><br><span class="line">                    p.urls[i] = node.href; // 解决相对url(或轮询不会工作)</span><br><span class="line">                    pollWebKit();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">            // 在Gecko,我们可以导入请求的URL到</span><br><span class="line">&lt;style&gt;节点和轮询node.sheet.cssRules的存在。</span><br><span class="line">                    node.innerHTML = &#x27;@import &quot;&#x27; + url + &#x27;&quot;;&#x27;;</span><br><span class="line">                    pollGecko(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.onload = node.onerror = _finish;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nodes.push(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i = 0, len = nodes.length; i &lt; len; ++i) &#123;</span><br><span class="line">            head.appendChild(nodes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    当样式表在Gecko中加载的时候 开始轮询来判断是否完成加载。在所有样式表完成加载 或者10S之后停止轮询防止无限循环</span><br><span class="line">    在此使用基于@import的跨域技术,和一个同域的实现 </span><br><span class="line">    http://www.zachleat.com/web/2010/07/29/load-css-dynamically/</span><br><span class="line">    @method pollGecko</span><br><span class="line">    @param &#123;HTMLElement&#125; node Style node to poll.</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function pollGecko(node) &#123;</span><br><span class="line">        var hasRules;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 无需存储或者在此引用该值 但是如果不引用 编辑器就认为是无用的并且移除它。</span><br><span class="line">            hasRules = !!node.sheet.cssRules;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">            // 一个例外意味着样式表仍然是在加载。</span><br><span class="line">            pollCount += 1;</span><br><span class="line"></span><br><span class="line">            if (pollCount &lt; 200) &#123; // 循环次数限制 共10s</span><br><span class="line">                setTimeout(function () &#123; pollGecko(node); &#125;, 50);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 轮询10秒后,还是没有结果发生。那么停止轮询和完成未决请求进一步判断 避免阻塞请求。</span><br><span class="line">                hasRules &amp;&amp; finish(&#x27;css&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    // 如果执行到此,则样式表加载。</span><br><span class="line">        finish(&#x27;css&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    在WebKit中 开始轮询来判断当等待样式表已经完成加载，在所有样式表完成加载 或者10S之后停止轮询防止无限循环</span><br><span class="line">    @method pollWebKit</span><br><span class="line">    @private</span><br><span class="line">    */</span><br><span class="line">    function pollWebKit() &#123;</span><br><span class="line">        var css = pending.css, i;</span><br><span class="line">        if (css) &#123;</span><br><span class="line">            i = styleSheets.length;</span><br><span class="line">          // 匹配styleSheet中的href 来判断是否加载完毕</span><br><span class="line">            while (--i &gt;= 0) &#123;</span><br><span class="line">                if (styleSheets[i].href === css.urls[0]) &#123;</span><br><span class="line">                    finish(&#x27;css&#x27;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pollCount += 1;</span><br><span class="line"></span><br><span class="line">            if (css) &#123;</span><br><span class="line">                if (pollCount &lt; 200) &#123;</span><br><span class="line">                    setTimeout(pollWebKit, 50);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 轮询10秒,但是什么也没有发生,这可能表明,样式表中已删除文件之前就有机会负载。停止轮询和完成等待请求以防止阻塞进一步的请求。</span><br><span class="line">                    finish(&#x27;css&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">    模块模式来暴露接口</span><br><span class="line"></span><br><span class="line">    请求指定CSS URL或URLs，当他们完成加载执行指定的回调函数(如果有的话)。</span><br><span class="line">    如果指定的是一个一个数组的urls,样式表将被并行加载在和所有的样式表加载完毕后执行回调。</span><br><span class="line"></span><br><span class="line">        @method css</span><br><span class="line">        @param &#123;String|Array&#125; urls 需要加载的单个或者数组形式的url</span><br><span class="line">        @param &#123;Function&#125; callback (可选)加载完毕所需要执行的回调函数</span><br><span class="line">        @param &#123;Object&#125; obj (可选) 回调函数需要传递的参数</span><br><span class="line">        @param &#123;Object&#125; context (可选) 提供回调函数的执行上下文</span><br><span class="line">        @static</span><br><span class="line">        */</span><br><span class="line">        css: function (urls, callback, obj, context) &#123;</span><br><span class="line">            load(&#x27;css&#x27;, urls, callback, obj, context);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">    请求指定的JavaScriptURL或URLs并当他们完成加载执行指定的回调函数(如果有的话)。</span><br><span class="line">    如果是指定一个url的数组和当浏览器支持,脚本将被并行载入，当完成所有的脚本加载后执行回调。</span><br><span class="line"></span><br><span class="line">    目前,只有Firefox和Opera支持并行加载脚本并且保存执行顺序。</span><br><span class="line">    在其他浏览器,脚本将排队和逐一加载一次,以确保正确的执行顺序。</span><br><span class="line"></span><br><span class="line">        @method js</span><br><span class="line">        @param &#123;String|Array&#125; urls 需要加载的单个或者数组形式的url</span><br><span class="line">        @param &#123;Function&#125; callback (可选) callback 加载完毕所需要执行的回调函数</span><br><span class="line">        @param &#123;Object&#125; obj (可选) 回调函数需要传递的参数</span><br><span class="line">        @param &#123;Object&#125; context (可选) 提供回调函数的执行上下文</span><br><span class="line">        @static</span><br><span class="line">        */</span><br><span class="line">        js: function (urls, callback, obj, context) &#123;</span><br><span class="line">            load(&#x27;js&#x27;, urls, callback, obj, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(this.document);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://freefe.cc/2012/11/26/settimeout-and-setinterval/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="倪颖峰">
      <meta itemprop="description" content="曾在果壳、百度蹦哒，目前在B站活跃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NiYingfeng 的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2012/11/26/settimeout-and-setinterval/" class="post-title-link" itemprop="url">setTimeout与setInterval</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2012-11-27 00:00:00" itemprop="dateCreated datePublished" datetime="2012-11-27T00:00:00+08:00">2012-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 11:28:25" itemprop="dateModified" datetime="2022-03-25T11:28:25+08:00">2022-03-25</time>
              </span>

          
            <span id="/2012/11/26/settimeout-and-setinterval/" class="post-meta-item leancloud_visitors" data-flag-title="setTimeout与setInterval" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近找了一些关于setTimeout与setInterval的一些资料，发现对于偏好各个都有。 但是我认为setTimeout与setInterval既然存在，总有他们自己的意义，过分的去深究到底孰优孰略是完全没有什么必要的，虽然本人更偏向setTimeout一些，但我绝对不会排斥setInterval。 我一般喜欢使用一段简单的代码来用 setTimeout 模拟 setInterval</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    //... 执行代码</span><br><span class="line">    setTimeout(foo,2000);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>上述代码可以很好的模拟 setInterval 。 首先看一段实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">        var flog = +new Date();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">                if(+new Date() - flog &gt; 3000)&#123;</span><br><span class="line">                        console.log(&quot;after&quot;);</span><br><span class="line">                        console.log((+new Date()/1000).toFixed(0) + &quot;s&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">function foo()&#123;</span><br><span class="line">            test();</span><br><span class="line">            setTimeout(foo,2000);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>test()中我使用while来占有内存，达到控制进程的效果（大量消耗内存，仅供测试）。下面为控制台的一段输出，间隔为5s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">after </span><br><span class="line">1354024132s </span><br><span class="line">after </span><br><span class="line">1354024137s </span><br><span class="line">after </span><br><span class="line">1354024142s</span><br></pre></td></tr></table></figure>

<p>感觉是理所当然的，而 setInterval 就不一样了，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">        var flog = +new Date();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">                if(+new Date() - flog &gt; 3000)&#123;</span><br><span class="line">                        console.log(&quot;after&quot;);</span><br><span class="line">                        console.log((+new Date()/1000).toFixed(0) + &quot;s&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(test,2000);</span><br></pre></td></tr></table></figure>

<p>其结果片段就不一样了，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">after </span><br><span class="line">1354024417s </span><br><span class="line">after </span><br><span class="line">1354024420s </span><br><span class="line">after </span><br><span class="line">1354024423s</span><br></pre></td></tr></table></figure>

<p>其间隔为3s。 上述为什么会有不一致性呢？ 这个可能需要从2个的根本区别说起， setTimeout() : 用于在指定的毫秒数后调用函数或计算表达式; setInterval() : 按照指定的周期(以毫秒计)来调用函数或计算表达式. 会不停地调用函数,直 到 clearInterval() 借用大牛的几句话：</p>
<ol>
<li>JavaScript引擎是单线程的，强制所有的异步事件排队等待执行</li>
<li>setTimeout 和 setInterval 在执行异步代码的时候有着根本的不同</li>
<li>如果一个计时器被阻塞而不能立即执行，它将延迟执行直到下一次可能执行的时间点才被执行（比期望的时间间隔要长些）</li>
<li>如果setInterval回调函数的执行时间将足够长（比指定的时间间隔长），它们将连续执行并且彼此之间没有时间间隔。</li>
</ol>
<p>举个例子： 我有一个需要执行1s的方法，我如果是 setTimeout 延时2s执行，那么从0开始 在 2 5 8···的时间点开始执行，而setInterval却在 2 4 6···时刻开始执行。 可以想象，当延时时间比执行时间短的时候 setInterval 会出现什么情况，当不断叠加不断消耗内存的风险。 总而言之，setTimeout 唯一存在的问题就是对于执行的时间点误差较大，但对于性能方面会比较友好，当然如果所需执行的为每一时间段，并且运行量较小，那就考虑选择 setIntervsl。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">倪颖峰</p>
  <div class="site-description" itemprop="description">曾在果壳、百度蹦哒，目前在B站活跃</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/niyingfeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;niyingfeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yingfeng.ni@gmail.com" title="E-Mail → mailto:yingfeng.ni@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">倪颖峰</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
     & <a target="_blank" href="https://beian.miit.gov.cn/" title="Semantic Personal Publishing Platform">浙ICP备16020323号-1</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"z3J5VC7OBuKe3Bs1ApRTYaT8-gzGzoHsz","app_key":"jijPF2bP4TXvA3lY4rddhVVF","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
